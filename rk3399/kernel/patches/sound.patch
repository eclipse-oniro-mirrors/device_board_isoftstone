From 59711af04d605fdb7b63bdf4472e23313fd19da2 Mon Sep 17 00:00:00 2001
From: jiewangdp <jiewangdp@isoftstone.com>
Date: Sat, 11 Jun 2022 16:16:45 +0800
Subject: [PATCH] sound

Change-Id: I6fbd5384bbd23d470abd4f4193a9341981fa28af
---
 sound/drivers/aloop.c                        |   30 +-
 sound/soc/codecs/Kconfig                     |   13 +-
 sound/soc/codecs/Makefile                    |    4 +
 sound/soc/codecs/bt-sco.c                    |    8 +-
 sound/soc/codecs/dummy-codec.c               |  115 ++
 sound/soc/codecs/es8328.c                    |   18 +
 sound/soc/codecs/rk_codec_digital.c          | 1109 ++++++++++
 sound/soc/codecs/rk_codec_digital.h          |  319 +++
 sound/soc/codecs/rt5640.c                    |    4 +-
 sound/soc/codecs/rt5651.c                    |   85 +-
 sound/soc/codecs/rt5651.h                    |    3 +
 sound/soc/codecs/wm8974.c                    |   38 +
 sound/soc/rockchip/Kconfig                   |   55 +
 sound/soc/rockchip/Makefile                  |   21 +-
 sound/soc/rockchip/rockchip_audio_pwm.c      |  372 ++++
 sound/soc/rockchip/rockchip_audio_pwm.h      |   48 +
 sound/soc/rockchip/rockchip_cdndp.c          |  166 ++
 sound/soc/rockchip/rockchip_da7219.c         |  235 +++
 sound/soc/rockchip/rockchip_hdmi.c           |  279 +++
 sound/soc/rockchip/rockchip_hdmi_analog.c    |  222 ++
 sound/soc/rockchip/rockchip_hdmi_dp.c        |  193 ++
 sound/soc/rockchip/rockchip_i2s.c            |  230 ++-
 sound/soc/rockchip/rockchip_i2s.h            |   10 +-
 sound/soc/rockchip/rockchip_i2s_tdm.c        | 1952 ++++++++++++++++++
 sound/soc/rockchip/rockchip_i2s_tdm.h        |  393 ++++
 sound/soc/rockchip/rockchip_multi_dais.c     |  541 +++++
 sound/soc/rockchip/rockchip_multi_dais.h     |   33 +
 sound/soc/rockchip/rockchip_multi_dais_pcm.c |  704 +++++++
 sound/soc/rockchip/rockchip_multicodecs.c    |  809 ++++++++
 sound/soc/rockchip/rockchip_pdm.c            |  136 +-
 sound/soc/rockchip/rockchip_pdm.h            |    6 +
 sound/soc/rockchip/rockchip_rt5651.c         |  245 +++
 sound/soc/rockchip/rockchip_spdif.c          |   45 +-
 sound/soc/rockchip/rockchip_spdifrx.c        |  415 ++++
 sound/soc/rockchip/rockchip_spdifrx.h        |  113 +
 sound/soc/rockchip/rockchip_vad.c            | 1316 ++++++++++++
 sound/soc/rockchip/rockchip_vad.h            |  231 +++
 sound/soc/rockchip/vad_preprocess.h          |   29 +
 sound/soc/rockchip/vad_preprocess_arm.S      |  348 ++++
 sound/soc/rockchip/vad_preprocess_arm64.S    |  273 +++
 sound/soc/rockchip/vad_preprocess_thumb.S    |  360 ++++
 sound/usb/quirks.c                           |    6 +
 42 files changed, 11402 insertions(+), 130 deletions(-)
 create mode 100644 sound/soc/codecs/dummy-codec.c
 create mode 100644 sound/soc/codecs/rk_codec_digital.c
 create mode 100644 sound/soc/codecs/rk_codec_digital.h
 create mode 100644 sound/soc/rockchip/rockchip_audio_pwm.c
 create mode 100644 sound/soc/rockchip/rockchip_audio_pwm.h
 create mode 100644 sound/soc/rockchip/rockchip_cdndp.c
 create mode 100644 sound/soc/rockchip/rockchip_da7219.c
 create mode 100644 sound/soc/rockchip/rockchip_hdmi.c
 create mode 100644 sound/soc/rockchip/rockchip_hdmi_analog.c
 create mode 100644 sound/soc/rockchip/rockchip_hdmi_dp.c
 create mode 100644 sound/soc/rockchip/rockchip_i2s_tdm.c
 create mode 100644 sound/soc/rockchip/rockchip_i2s_tdm.h
 create mode 100644 sound/soc/rockchip/rockchip_multi_dais.c
 create mode 100644 sound/soc/rockchip/rockchip_multi_dais.h
 create mode 100644 sound/soc/rockchip/rockchip_multi_dais_pcm.c
 create mode 100644 sound/soc/rockchip/rockchip_multicodecs.c
 create mode 100644 sound/soc/rockchip/rockchip_rt5651.c
 create mode 100644 sound/soc/rockchip/rockchip_spdifrx.c
 create mode 100644 sound/soc/rockchip/rockchip_spdifrx.h
 create mode 100644 sound/soc/rockchip/rockchip_vad.c
 create mode 100644 sound/soc/rockchip/rockchip_vad.h
 create mode 100644 sound/soc/rockchip/vad_preprocess.h
 create mode 100644 sound/soc/rockchip/vad_preprocess_arm.S
 create mode 100644 sound/soc/rockchip/vad_preprocess_arm64.S
 create mode 100644 sound/soc/rockchip/vad_preprocess_thumb.S

diff --git a/sound/drivers/aloop.c b/sound/drivers/aloop.c
index 2c5f7e905..51821334f 100644
--- a/sound/drivers/aloop.c
+++ b/sound/drivers/aloop.c
@@ -37,6 +37,7 @@ MODULE_SUPPORTED_DEVICE("{{ALSA,Loopback soundcard}}");
 
 #define MAX_PCM_SUBSTREAMS	8
 
+static bool use_raw_jiffies;
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static bool enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
@@ -44,6 +45,8 @@ static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 static int pcm_notify[SNDRV_CARDS];
 static char *timer_source[SNDRV_CARDS];
 
+module_param(use_raw_jiffies, bool, 0444);
+MODULE_PARM_DESC(use_raw_jiffies, "Use raw jiffies follows local clocks.");
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for loopback soundcard.");
 module_param_array(id, charp, NULL, 0444);
@@ -163,6 +166,22 @@ struct loopback_pcm {
 
 static struct platform_device *devices[SNDRV_CARDS];
 
+static inline unsigned long get_raw_jiffies(void)
+{
+	struct timespec64 ts64;
+
+	ktime_get_raw_ts64(&ts64);
+	return timespec64_to_jiffies(&ts64);
+}
+
+static inline unsigned long cycles_to_jiffies(void)
+{
+	if (likely(use_raw_jiffies))
+		return get_raw_jiffies();
+
+	return jiffies;
+}
+
 static inline unsigned int byte_pos(struct loopback_pcm *dpcm, unsigned int x)
 {
 	if (dpcm->pcm_rate_shift == NO_PITCH) {
@@ -387,7 +406,7 @@ static int loopback_trigger(struct snd_pcm_substream *substream, int cmd)
 		err = loopback_check_format(cable, substream->stream);
 		if (err < 0)
 			return err;
-		dpcm->last_jiffies = jiffies;
+		dpcm->last_jiffies = cycles_to_jiffies();
 		dpcm->pcm_rate_shift = 0;
 		dpcm->last_drift = 0;
 		spin_lock(&cable->lock);	
@@ -419,7 +438,7 @@ static int loopback_trigger(struct snd_pcm_substream *substream, int cmd)
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
 		spin_lock(&cable->lock);
-		dpcm->last_jiffies = jiffies;
+		dpcm->last_jiffies = cycles_to_jiffies();
 		cable->pause &= ~stream;
 		err = cable->ops->start(dpcm);
 		spin_unlock(&cable->lock);
@@ -608,15 +627,16 @@ static unsigned int loopback_jiffies_timer_pos_update
 			cable->streams[SNDRV_PCM_STREAM_CAPTURE];
 	unsigned long delta_play = 0, delta_capt = 0;
 	unsigned int running, count1, count2;
+	unsigned long cur_jiffies = cycles_to_jiffies();
 
 	running = cable->running ^ cable->pause;
 	if (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) {
-		delta_play = jiffies - dpcm_play->last_jiffies;
+		delta_play = cur_jiffies - dpcm_play->last_jiffies;
 		dpcm_play->last_jiffies += delta_play;
 	}
 
 	if (running & (1 << SNDRV_PCM_STREAM_CAPTURE)) {
-		delta_capt = jiffies - dpcm_capt->last_jiffies;
+		delta_capt = cur_jiffies - dpcm_capt->last_jiffies;
 		dpcm_capt->last_jiffies += delta_capt;
 	}
 
@@ -842,7 +862,7 @@ static void loopback_jiffies_timer_dpcm_info(struct loopback_pcm *dpcm,
 	snd_iprintf(buffer, "    irq_pos:\t\t%u\n", dpcm->irq_pos);
 	snd_iprintf(buffer, "    period_frac:\t%u\n", dpcm->period_size_frac);
 	snd_iprintf(buffer, "    last_jiffies:\t%lu (%lu)\n",
-		    dpcm->last_jiffies, jiffies);
+		    dpcm->last_jiffies, cycles_to_jiffies());
 	snd_iprintf(buffer, "    timer_expires:\t%lu\n", dpcm->timer.expires);
 }
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 34c6dd04b..b380d0b31 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -89,10 +89,12 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_DA732X
 	imply SND_SOC_DA9055
 	imply SND_SOC_DMIC
+	imply SND_SOC_DUMMY_CODEC
 	imply SND_SOC_ES8316
 	imply SND_SOC_ES8328_SPI
 	imply SND_SOC_ES8328_I2C
 	imply SND_SOC_ES7134
+	imply SND_SOC_ES7202
 	imply SND_SOC_ES7241
 	imply SND_SOC_GTM601
 	imply SND_SOC_HDAC_HDMI
@@ -761,6 +763,9 @@ config SND_SOC_DMIC
 	  Enable support for the Generic Digital Microphone CODEC.
 	  Select this if your sound card has DMICs.
 
+config SND_SOC_DUMMY_CODEC
+	tristate "Dummy CODEC"
+
 config SND_SOC_HDMI_CODEC
 	tristate
 	select SND_PCM_ELD
@@ -776,6 +781,7 @@ config SND_SOC_ES7241
 config SND_SOC_ES8316
 	tristate "Everest Semi ES8316 CODEC"
 	depends on I2C
+	depends on I2C
 
 config SND_SOC_ES8328
 	tristate
@@ -1024,6 +1030,9 @@ config SND_SOC_RK3328
 	tristate "Rockchip RK3328 audio CODEC"
 	select REGMAP_MMIO
 
+config SND_SOC_RK_CODEC_DIGITAL
+	tristate "Rockchip Codec Digital Interface"
+
 config SND_SOC_RL6231
 	tristate
 	default y if SND_SOC_RT5514=y
@@ -1130,7 +1139,7 @@ config SND_SOC_RT5631
 	depends on I2C
 
 config SND_SOC_RT5640
-	tristate
+	tristate "Realtek ALC5640 CODEC"
 	depends on I2C
 
 config SND_SOC_RT5645
@@ -1138,7 +1147,7 @@ config SND_SOC_RT5645
 	depends on I2C
 
 config SND_SOC_RT5651
-	tristate
+	tristate "Realtek ALC5651 CODEC"
 	depends on I2C
 
 config SND_SOC_RT5659
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 11ce98c25..5e2b27de3 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -84,6 +84,7 @@ snd-soc-da7219-objs := da7219.o da7219-aad.o
 snd-soc-da732x-objs := da732x.o
 snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
+snd-soc-dummy-codec-objs := dummy-codec.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es7241-objs := es7241.o
 snd-soc-es8316-objs := es8316.o
@@ -156,6 +157,7 @@ snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
 snd-soc-rk3328-objs := rk3328_codec.o
+snd-soc-rk-codec-digital-objs := rk_codec_digital.o
 snd-soc-rl6231-objs := rl6231.o
 snd-soc-rl6347a-objs := rl6347a.o
 snd-soc-rt1011-objs := rt1011.o
@@ -393,6 +395,7 @@ obj-$(CONFIG_SND_SOC_DA7219)	+= snd-soc-da7219.o
 obj-$(CONFIG_SND_SOC_DA732X)	+= snd-soc-da732x.o
 obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
+obj-$(CONFIG_SND_SOC_DUMMY_CODEC)	+= snd-soc-dummy-codec.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES7241)	+= snd-soc-es7241.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
@@ -465,6 +468,7 @@ obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
 obj-$(CONFIG_SND_SOC_RK3328)	+= snd-soc-rk3328.o
+obj-$(CONFIG_SND_SOC_RK_CODEC_DIGITAL)	+= snd-soc-rk-codec-digital.o
 obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
 obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
 obj-$(CONFIG_SND_SOC_RT1011)	+= snd-soc-rt1011.o
diff --git a/sound/soc/codecs/bt-sco.c b/sound/soc/codecs/bt-sco.c
index 4d286844e..2be7ba425 100644
--- a/sound/soc/codecs/bt-sco.c
+++ b/sound/soc/codecs/bt-sco.c
@@ -26,14 +26,14 @@ static struct snd_soc_dai_driver bt_sco_dai[] = {
 		.playback = {
 			.stream_name = "Playback",
 			.channels_min = 1,
-			.channels_max = 1,
+			.channels_max = 2,
 			.rates = SNDRV_PCM_RATE_8000,
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
 		.capture = {
 			 .stream_name = "Capture",
 			.channels_min = 1,
-			.channels_max = 1,
+			.channels_max = 2,
 			.rates = SNDRV_PCM_RATE_8000,
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
@@ -43,14 +43,14 @@ static struct snd_soc_dai_driver bt_sco_dai[] = {
 		.playback = {
 			.stream_name = "Playback",
 			.channels_min = 1,
-			.channels_max = 1,
+			.channels_max = 2,
 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
 		.capture = {
 			 .stream_name = "Capture",
 			.channels_min = 1,
-			.channels_max = 1,
+			.channels_max = 2,
 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
diff --git a/sound/soc/codecs/dummy-codec.c b/sound/soc/codecs/dummy-codec.c
new file mode 100644
index 000000000..35756c753
--- /dev/null
+++ b/sound/soc/codecs/dummy-codec.c
@@ -0,0 +1,115 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// dummy_codec.c  --  dummy audio codec for rockchip
+//
+// Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+
+struct dummy_codec_priv {
+	struct snd_soc_component *component;
+	struct clk *mclk;
+};
+
+static int dummy_codec_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct dummy_codec_priv *dcp = snd_soc_component_get_drvdata(dai->component);
+
+	if (!IS_ERR(dcp->mclk))
+		clk_prepare_enable(dcp->mclk);
+
+	return 0;
+}
+
+static void dummy_codec_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct dummy_codec_priv *dcp = snd_soc_component_get_drvdata(dai->component);
+
+	if (!IS_ERR(dcp->mclk))
+		clk_disable_unprepare(dcp->mclk);
+}
+
+static struct snd_soc_dai_ops dummy_codec_dai_ops = {
+	.startup	= dummy_codec_startup,
+	.shutdown	= dummy_codec_shutdown,
+};
+
+struct snd_soc_dai_driver dummy_dai = {
+	.name = "dummy_codec",
+	.playback = {
+		.stream_name = "Dummy Playback",
+		.channels_min = 2,
+		.channels_max = 384,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE |
+			    SNDRV_PCM_FMTBIT_S32_LE),
+	},
+	.capture = {
+		.stream_name = "Dummy Capture",
+		.channels_min = 2,
+		.channels_max = 384,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE |
+			    SNDRV_PCM_FMTBIT_S32_LE),
+	},
+	.ops = &dummy_codec_dai_ops,
+};
+
+static const struct snd_soc_component_driver soc_dummy_codec;
+
+static int rockchip_dummy_codec_probe(struct platform_device *pdev)
+{
+	struct dummy_codec_priv *dcp;
+
+	dcp = devm_kzalloc(&pdev->dev, sizeof(*dcp), GFP_KERNEL);
+	if (!dcp)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, dcp);
+
+	/* optional mclk, if needs, assign mclk in dts node */
+	dcp->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(dcp->mclk)) {
+		if (PTR_ERR(dcp->mclk) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		else if (PTR_ERR(dcp->mclk) != -ENOENT)
+			return -EINVAL;
+	}
+
+	return devm_snd_soc_register_component(&pdev->dev, &soc_dummy_codec,
+					       &dummy_dai, 1);
+}
+
+static const struct of_device_id rockchip_dummy_codec_of_match[] = {
+	{ .compatible = "rockchip,dummy-codec", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_dummy_codec_of_match);
+
+static struct platform_driver rockchip_dummy_codec_driver = {
+	.driver = {
+		.name = "dummy_codec",
+		.of_match_table = of_match_ptr(rockchip_dummy_codec_of_match),
+	},
+	.probe = rockchip_dummy_codec_probe,
+};
+
+module_platform_driver(rockchip_dummy_codec_driver);
+
+MODULE_AUTHOR("Sugar <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip Dummy Codec Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/es8328.c b/sound/soc/codecs/es8328.c
index 7e26231a5..1d27a26e0 100644
--- a/sound/soc/codecs/es8328.c
+++ b/sound/soc/codecs/es8328.c
@@ -36,6 +36,16 @@ static const struct snd_pcm_hw_constraint_list constraints_12288 = {
 	.list	= rates_12288,
 };
 
+static unsigned int ratios_12000[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	48000, 88235, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12000 = {
+	.count = ARRAY_SIZE(ratios_12000),
+	.list = ratios_12000,
+};
+
 static const unsigned int rates_11289[] = {
 	8018, 11025, 22050, 44100, 88200,
 };
@@ -574,6 +584,14 @@ static int es8328_set_sysclk(struct snd_soc_dai *codec_dai,
 		es8328->sysclk_constraints = &constraints_12288;
 		es8328->mclk_ratios = ratios_12288;
 		break;
+
+	case 24000000:
+		mclkdiv2 = 1;
+		fallthrough;
+	case 12000000:
+		es8328->sysclk_constraints = &constraints_12000;
+		es8328->mclk_ratios = ratios_12000;
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/sound/soc/codecs/rk_codec_digital.c b/sound/soc/codecs/rk_codec_digital.c
new file mode 100644
index 000000000..ec91b72fa
--- /dev/null
+++ b/sound/soc/codecs/rk_codec_digital.c
@@ -0,0 +1,1109 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Rockchip Audio Codec Digital Interface
+ *
+ * Copyright (C) 2020 Rockchip Electronics Co.,Ltd
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/tlv.h>
+#include "rk_codec_digital.h"
+
+#define RK3568_GRF_SOC_CON2 (0x0508)
+#define RV1126_GRF_SOC_CON2 (0x0008)
+
+struct rk_codec_digital_soc_data {
+	int (*init)(struct device *dev);
+	void (*deinit)(struct device *dev);
+};
+
+struct rk_codec_digital_priv {
+	struct regmap *grf;
+	struct regmap *regmap;
+	struct clk *clk_adc;
+	struct clk *clk_dac;
+	struct clk *clk_i2c;
+	struct clk *pclk;
+	bool pwmout;
+	bool sync;
+	unsigned int pa_ctl_delay_ms;
+	struct gpio_desc *pa_ctl;
+	struct reset_control *rc;
+	const struct rk_codec_digital_soc_data *data;
+};
+
+/* ADC digital gain */
+static const DECLARE_TLV_DB_SCALE(adc_tlv, -95625, 375, 0);
+/* PGA gain */
+static const DECLARE_TLV_DB_SCALE(pga_tlv, -18, 3, 0);
+/* DAC digital gain */
+static const DECLARE_TLV_DB_SCALE(dac_tlv, -95625, 375, 0);
+
+/* ADC Cutoff Freq for High Pass Filter */
+static const char * const adc_hpf_cutoff_text[] = {
+	"3.79Hz", "60Hz", "243Hz", "493Hz",
+};
+
+static SOC_ENUM_SINGLE_DECL(adc_hpf_cutoff_enum, ADCHPFCF, 0,
+			    adc_hpf_cutoff_text);
+
+/* DAC Cutoff for High Pass Filter */
+static const char * const dac_hpf_cutoff_text[] = {
+	"80Hz", "100Hz", "120Hz", "140Hz",
+};
+
+static SOC_ENUM_SINGLE_DECL(dac_hpf_cutoff_enum, DACHPF, 4,
+			    dac_hpf_cutoff_text);
+
+static const char * const pa_ctl[] = {"Off", "On"};
+
+static const struct soc_enum pa_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(pa_ctl), pa_ctl);
+
+static int rk_codec_digital_adc_vol_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int val = snd_soc_component_read(component, mc->reg);
+	unsigned int sign = snd_soc_component_read(component, ADCVOGP);
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int shift = mc->shift;
+	int mid = mc->max / 2;
+	int uv;
+
+	switch (mc->reg) {
+	case ADCVOLL0:
+		sign &= ACDCDIG_ADCVOGP_VOLGPL0_MASK;
+		break;
+	case ADCVOLL1:
+		sign &= ACDCDIG_ADCVOGP_VOLGPL1_MASK;
+		break;
+	case ADCVOLR0:
+		sign &= ACDCDIG_ADCVOGP_VOLGPR0_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	uv = (val >> shift) & mask;
+	if (sign)
+		uv = mid + uv;
+	else
+		uv = mid - uv;
+
+	ucontrol->value.integer.value[0] = uv;
+
+	return 0;
+}
+
+static int rk_codec_digital_adc_vol_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int val, val_mask, sign, sign_mask;
+	int uv = ucontrol->value.integer.value[0];
+	int min = mc->min;
+	int mid = mc->max / 2;
+	bool pos = (uv > mid);
+
+	switch (mc->reg) {
+	case ADCVOLL0:
+		sign_mask = ACDCDIG_ADCVOGP_VOLGPL0_MASK;
+		sign = pos ? ACDCDIG_ADCVOGP_VOLGPL0_POS : ACDCDIG_ADCVOGP_VOLGPL0_NEG;
+		break;
+	case ADCVOLL1:
+		sign_mask = ACDCDIG_ADCVOGP_VOLGPL1_MASK;
+		sign = pos ? ACDCDIG_ADCVOGP_VOLGPL1_POS : ACDCDIG_ADCVOGP_VOLGPL1_NEG;
+		break;
+	case ADCVOLR0:
+		sign_mask = ACDCDIG_ADCVOGP_VOLGPR0_MASK;
+		sign = pos ? ACDCDIG_ADCVOGP_VOLGPR0_POS : ACDCDIG_ADCVOGP_VOLGPR0_NEG;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	uv = pos ? (uv - mid) : (mid - uv);
+
+	val = ((uv + min) & mask);
+	val_mask = mask << shift;
+	val = val << shift;
+
+	snd_soc_component_update_bits(component, reg, val_mask, val);
+	snd_soc_component_update_bits(component, ADCVOGP, sign_mask, sign);
+
+	return 0;
+}
+
+static int rk_codec_digital_dac_vol_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int val = snd_soc_component_read(component, mc->reg);
+	unsigned int sign = snd_soc_component_read(component, DACVOGP);
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int shift = mc->shift;
+	int mid = mc->max / 2;
+	int uv;
+
+	uv = (val >> shift) & mask;
+	if (sign)
+		uv = mid + uv;
+	else
+		uv = mid - uv;
+
+	ucontrol->value.integer.value[0] = uv;
+	ucontrol->value.integer.value[1] = uv;
+
+	return 0;
+}
+
+static int rk_codec_digital_dac_vol_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int val, val_mask, sign;
+	int uv = ucontrol->value.integer.value[0];
+	int min = mc->min;
+	int mid = mc->max / 2;
+
+	if (uv > mid) {
+		sign = ACDCDIG_DACVOGP_VOLGPL0_POS | ACDCDIG_DACVOGP_VOLGPR0_POS;
+		uv = uv - mid;
+	} else {
+		sign = ACDCDIG_DACVOGP_VOLGPL0_NEG | ACDCDIG_DACVOGP_VOLGPR0_NEG;
+		uv = mid - uv;
+	}
+
+	val = ((uv + min) & mask);
+	val_mask = mask << shift;
+	val = val << shift;
+
+	snd_soc_component_update_bits(component, reg, val_mask, val);
+	snd_soc_component_update_bits(component, rreg, val_mask, val);
+	snd_soc_component_write(component, DACVOGP, sign);
+
+	return 0;
+}
+
+static int rk_codec_digital_dac_pa_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk_codec_digital_priv *rcd = snd_soc_component_get_drvdata(component);
+
+	if (!rcd->pa_ctl)
+		return -EINVAL;
+
+	ucontrol->value.enumerated.item[0] = gpiod_get_value(rcd->pa_ctl);
+
+	return 0;
+}
+
+static int rk_codec_digital_dac_pa_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk_codec_digital_priv *rcd = snd_soc_component_get_drvdata(component);
+
+	if (!rcd->pa_ctl)
+		return -EINVAL;
+
+	gpiod_set_value(rcd->pa_ctl, ucontrol->value.enumerated.item[0]);
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new rk_codec_digital_snd_controls[] = {
+	SOC_SINGLE_EXT_TLV("ADCL0 Digital Volume",
+			   ADCVOLL0, 0, 0X1fe, 0,
+			   rk_codec_digital_adc_vol_get,
+			   rk_codec_digital_adc_vol_put,
+			   adc_tlv),
+	SOC_SINGLE_EXT_TLV("ADCL1 Digital Volume",
+			   ADCVOLL1, 0, 0x1fe, 0,
+			   rk_codec_digital_adc_vol_get,
+			   rk_codec_digital_adc_vol_put,
+			   adc_tlv),
+	SOC_SINGLE_EXT_TLV("ADCR0 Digital Volume",
+			   ADCVOLR0, 0, 0x1fe, 0,
+			   rk_codec_digital_adc_vol_get,
+			   rk_codec_digital_adc_vol_put,
+			   adc_tlv),
+
+	SOC_SINGLE_TLV("ADCL0 PGA Gain",
+		       ADCPGL0, 0, 0Xf, 0, pga_tlv),
+	SOC_SINGLE_TLV("ADCL1 PGA Gain",
+		       ADCPGL1, 0, 0xf, 0, pga_tlv),
+	SOC_SINGLE_TLV("ADCR0 PGA Gain",
+		       ADCPGR0, 0, 0xf, 0, pga_tlv),
+
+	SOC_DOUBLE_R_EXT_TLV("DAC Digital Volume",
+			     DACVOLL0, DACVOLR0, 0, 0x1fe, 0,
+			     rk_codec_digital_dac_vol_get,
+			     rk_codec_digital_dac_vol_put,
+			     dac_tlv),
+
+	SOC_ENUM("ADC HPF Cutoff", adc_hpf_cutoff_enum),
+	SOC_SINGLE("ADC L0 HPF Switch", ADCHPFEN, 0, 1, 0),
+	SOC_SINGLE("ADC R0 HPF Switch", ADCHPFEN, 1, 1, 0),
+	SOC_SINGLE("ADC L1 HPF Switch", ADCHPFEN, 2, 1, 0),
+
+	SOC_ENUM("DAC HPF Cutoff", dac_hpf_cutoff_enum),
+	SOC_SINGLE("DAC HPF Switch", DACHPF, 0, 1, 0),
+	SOC_ENUM_EXT("Power Amplifier", pa_enum,
+		     rk_codec_digital_dac_pa_get,
+		     rk_codec_digital_dac_pa_put),
+};
+
+static void rk_codec_digital_reset(struct rk_codec_digital_priv *rcd)
+{
+	if (IS_ERR(rcd->rc))
+		return;
+
+	reset_control_assert(rcd->rc);
+	udelay(1);
+	reset_control_deassert(rcd->rc);
+}
+
+/*
+ * ACDC_CLK  D2A_CLK   D2A_SYNC Sample rates supported
+ * 49.152MHz 49.152MHz 6.144MHz 12/24/48/96/192kHz
+ * 45.154MHz 45.154MHz 5.644MHz 11.025/22.05/44.1/88.2/176.4kHz
+ * 32.768MHz 32.768MHz 4.096MHz 8/16/32/64/128kHz
+ *
+ */
+static void rk_codec_digital_get_clk(unsigned int samplerate,
+				     unsigned int *mclk,
+				     unsigned int *sclk)
+{
+	switch (samplerate) {
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+		*mclk = 49152000;
+		*sclk = 6144000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		*mclk = 45158400;
+		*sclk = 5644800;
+		break;
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+		*mclk = 32768000;
+		*sclk = 4096000;
+		break;
+	default:
+		*mclk = 0;
+		*sclk = 0;
+		break;
+	}
+}
+
+static void rk_codec_digital_enable_clk_adc(struct rk_codec_digital_priv *rcd)
+{
+	regmap_update_bits(rcd->regmap, ADCCLKCTRL,
+			   ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_MASK |
+			   ACDCDIG_ADCCLKCTRL_ADC_CKE_MASK |
+			   ACDCDIG_ADCCLKCTRL_I2STX_CKE_MASK |
+			   ACDCDIG_ADCCLKCTRL_CKE_BCLKTX_MASK |
+			   ACDCDIG_ADCCLKCTRL_FILTER_GATE_EN_MASK |
+			   ACDCDIG_ADCCLKCTRL_ADC_SYNC_ENA_MASK,
+			   ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_16 |
+			   ACDCDIG_ADCCLKCTRL_ADC_CKE_EN |
+			   ACDCDIG_ADCCLKCTRL_I2STX_CKE_EN |
+			   ACDCDIG_ADCCLKCTRL_CKE_BCLKTX_EN |
+			   ACDCDIG_ADCCLKCTRL_FILTER_GATE_EN |
+			   ACDCDIG_ADCCLKCTRL_ADC_SYNC_ENA_EN);
+}
+
+static void rk_codec_digital_enable_clk_dac(struct rk_codec_digital_priv *rcd)
+{
+	regmap_update_bits(rcd->regmap, DACCLKCTRL,
+			   ACDCDIG_DACCLKCTRL_DAC_CKE_MASK |
+			   ACDCDIG_DACCLKCTRL_I2SRX_CKE_MASK |
+			   ACDCDIG_DACCLKCTRL_CKE_BCLKRX_MASK |
+			   ACDCDIG_DACCLKCTRL_DAC_SYNC_ENA_MASK |
+			   ACDCDIG_DACCLKCTRL_DAC_MODE_ATTENU_MASK,
+			   ACDCDIG_DACCLKCTRL_DAC_CKE_EN |
+			   ACDCDIG_DACCLKCTRL_I2SRX_CKE_EN |
+			   ACDCDIG_DACCLKCTRL_CKE_BCLKRX_EN |
+			   ACDCDIG_DACCLKCTRL_DAC_SYNC_ENA_EN |
+			   ACDCDIG_DACCLKCTRL_DAC_MODE_ATTENU_EN);
+}
+
+static int rk_codec_digital_set_clk_sync(struct rk_codec_digital_priv *rcd,
+					 unsigned int mclk,
+					 unsigned int sclk,
+					 unsigned int bclk)
+{
+	unsigned int div_sync, div_bclk;
+
+	div_bclk = DIV_ROUND_CLOSEST(mclk, bclk);
+	div_sync = DIV_ROUND_CLOSEST(mclk, sclk);
+
+	clk_set_rate(rcd->clk_adc, mclk);
+	clk_set_rate(rcd->clk_dac, mclk);
+
+	/* select clock sync is from ADC. */
+	regmap_update_bits(rcd->regmap, SYSCTRL0,
+			   ACDCDIG_SYSCTRL0_SYNC_MODE_MASK |
+			   ACDCDIG_SYSCTRL0_CLK_COM_SEL_MASK,
+			   ACDCDIG_SYSCTRL0_SYNC_MODE_SYNC |
+			   ACDCDIG_SYSCTRL0_CLK_COM_SEL_ADC);
+
+	regmap_update_bits(rcd->regmap, ADCINT_DIV,
+			   ACDCDIG_ADCINT_DIV_INT_DIV_CON_MASK,
+			   ACDCDIG_ADCINT_DIV_INT_DIV_CON(div_sync));
+	regmap_update_bits(rcd->regmap, DACINT_DIV,
+			   ACDCDIG_DACINT_DIV_INT_DIV_CON_MASK,
+			   ACDCDIG_DACINT_DIV_INT_DIV_CON(div_sync));
+
+	rk_codec_digital_enable_clk_adc(rcd);
+	rk_codec_digital_enable_clk_dac(rcd);
+
+	regmap_update_bits(rcd->regmap, DACSCLKRXINT_DIV,
+			   ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV_MASK,
+			   ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV(div_bclk));
+	regmap_update_bits(rcd->regmap, I2S_CKR0,
+			   ACDCDIG_I2S_CKR0_RSD_MASK,
+			   ACDCDIG_I2S_CKR0_RSD(64));
+	regmap_update_bits(rcd->regmap, ADCSCLKTXINT_DIV,
+			   ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV_MASK,
+			   ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV(div_bclk));
+	regmap_update_bits(rcd->regmap, I2S_CKR0,
+			   ACDCDIG_I2S_CKR0_TSD_MASK,
+			   ACDCDIG_I2S_CKR0_TSD(64));
+
+	return 0;
+}
+
+static int rk_codec_digital_set_clk(struct rk_codec_digital_priv *rcd,
+				    struct snd_pcm_substream *substream,
+				    unsigned int samplerate)
+{
+	unsigned int mclk, sclk, bclk;
+	unsigned int div_sync, div_bclk;
+
+	rk_codec_digital_get_clk(samplerate, &mclk, &sclk);
+	if (!mclk || !sclk)
+		return -EINVAL;
+
+	bclk = 64 * samplerate;
+	div_bclk = DIV_ROUND_CLOSEST(mclk, bclk);
+	div_sync = DIV_ROUND_CLOSEST(mclk, sclk);
+
+	if (rcd->sync)
+		return rk_codec_digital_set_clk_sync(rcd, mclk, sclk, bclk);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		clk_set_rate(rcd->clk_dac, mclk);
+
+		regmap_update_bits(rcd->regmap, DACINT_DIV,
+				   ACDCDIG_DACINT_DIV_INT_DIV_CON_MASK,
+				   ACDCDIG_DACINT_DIV_INT_DIV_CON(div_sync));
+
+		rk_codec_digital_enable_clk_dac(rcd);
+
+		regmap_update_bits(rcd->regmap, DACSCLKRXINT_DIV,
+				   ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV_MASK,
+				   ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV(div_bclk));
+		regmap_update_bits(rcd->regmap, I2S_CKR0,
+				   ACDCDIG_I2S_CKR0_RSD_MASK,
+				   ACDCDIG_I2S_CKR0_RSD(64));
+	} else {
+		clk_set_rate(rcd->clk_adc, mclk);
+
+		regmap_update_bits(rcd->regmap, ADCINT_DIV,
+				   ACDCDIG_ADCINT_DIV_INT_DIV_CON_MASK,
+				   ACDCDIG_ADCINT_DIV_INT_DIV_CON(div_sync));
+
+		rk_codec_digital_enable_clk_adc(rcd);
+		regmap_update_bits(rcd->regmap, ADCSCLKTXINT_DIV,
+				   ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV_MASK,
+				   ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV(div_bclk));
+		regmap_update_bits(rcd->regmap, I2S_CKR0,
+				   ACDCDIG_I2S_CKR0_TSD_MASK,
+				   ACDCDIG_I2S_CKR0_TSD(64));
+	}
+
+	return 0;
+}
+
+static int rk_codec_digital_set_dai_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+	struct rk_codec_digital_priv *rcd =
+		snd_soc_component_get_drvdata(dai->component);
+	unsigned int mask = 0, val = 0;
+
+	/* master mode only */
+	regmap_update_bits(rcd->regmap, I2S_CKR1,
+			   ACDCDIG_I2S_CKR1_MSS_MASK,
+			   ACDCDIG_I2S_CKR1_MSS_MASTER);
+
+	mask = ACDCDIG_I2S_CKR1_CKP_MASK |
+	       ACDCDIG_I2S_CKR1_RLP_MASK |
+	       ACDCDIG_I2S_CKR1_TLP_MASK;
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		val = ACDCDIG_I2S_CKR1_CKP_NORMAL |
+		      ACDCDIG_I2S_CKR1_RLP_NORMAL |
+		      ACDCDIG_I2S_CKR1_TLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		val = ACDCDIG_I2S_CKR1_CKP_INVERTED |
+		      ACDCDIG_I2S_CKR1_RLP_INVERTED |
+		      ACDCDIG_I2S_CKR1_TLP_INVERTED;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		val = ACDCDIG_I2S_CKR1_CKP_INVERTED |
+		      ACDCDIG_I2S_CKR1_RLP_NORMAL |
+		      ACDCDIG_I2S_CKR1_TLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		val = ACDCDIG_I2S_CKR1_CKP_NORMAL |
+		      ACDCDIG_I2S_CKR1_RLP_INVERTED |
+		      ACDCDIG_I2S_CKR1_TLP_INVERTED;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(rcd->regmap, I2S_CKR1, mask, val);
+
+	return 0;
+}
+
+static int rk_codec_digital_enable_sync(struct rk_codec_digital_priv *rcd)
+{
+	regmap_update_bits(rcd->regmap, I2S_XFER,
+			   ACDCDIG_I2S_XFER_RXS_MASK |
+			   ACDCDIG_I2S_XFER_TXS_MASK,
+			   ACDCDIG_I2S_XFER_RXS_START |
+			   ACDCDIG_I2S_XFER_TXS_START);
+
+	regmap_update_bits(rcd->regmap, SYSCTRL0,
+			   ACDCDIG_SYSCTRL0_GLB_CKE_MASK,
+			   ACDCDIG_SYSCTRL0_GLB_CKE_EN);
+
+	regmap_update_bits(rcd->regmap, ADCDIGEN,
+			   ACDCDIG_ADCDIGEN_ADC_GLBEN_MASK |
+			   ACDCDIG_ADCDIGEN_ADCEN_L2_MASK |
+			   ACDCDIG_ADCDIGEN_ADCEN_L0R1_MASK,
+			   ACDCDIG_ADCDIGEN_ADC_GLBEN_EN |
+			   ACDCDIG_ADCDIGEN_ADCEN_L2_EN |
+			   ACDCDIG_ADCDIGEN_ADCEN_L0R1_EN);
+
+	regmap_update_bits(rcd->regmap, DACDIGEN,
+			   ACDCDIG_DACDIGEN_DAC_GLBEN_MASK |
+			   ACDCDIG_DACDIGEN_DACEN_L0R1_MASK,
+			   ACDCDIG_DACDIGEN_DAC_GLBEN_EN |
+			   ACDCDIG_DACDIGEN_DACEN_L0R1_EN);
+
+	return 0;
+}
+
+static int rk_codec_digital_disable_sync(struct rk_codec_digital_priv *rcd)
+{
+	regmap_update_bits(rcd->regmap, I2S_XFER,
+			   ACDCDIG_I2S_XFER_RXS_MASK |
+			   ACDCDIG_I2S_XFER_TXS_MASK,
+			   ACDCDIG_I2S_XFER_RXS_STOP |
+			   ACDCDIG_I2S_XFER_TXS_STOP);
+
+	regmap_update_bits(rcd->regmap, I2S_CLR,
+			   ACDCDIG_I2S_CLR_RXC_MASK |
+			   ACDCDIG_I2S_CLR_TXC_MASK,
+			   ACDCDIG_I2S_CLR_RXC_CLR |
+			   ACDCDIG_I2S_CLR_TXC_CLR);
+
+	regmap_update_bits(rcd->regmap, SYSCTRL0,
+			   ACDCDIG_SYSCTRL0_GLB_CKE_MASK,
+			   ACDCDIG_SYSCTRL0_GLB_CKE_DIS);
+
+	regmap_update_bits(rcd->regmap, ADCDIGEN,
+			   ACDCDIG_ADCDIGEN_ADC_GLBEN_MASK |
+			   ACDCDIG_ADCDIGEN_ADCEN_L2_MASK |
+			   ACDCDIG_ADCDIGEN_ADCEN_L0R1_MASK,
+			   ACDCDIG_ADCDIGEN_ADC_GLBEN_DIS |
+			   ACDCDIG_ADCDIGEN_ADCEN_L2_DIS |
+			   ACDCDIG_ADCDIGEN_ADCEN_L0R1_DIS);
+
+	regmap_update_bits(rcd->regmap, DACDIGEN,
+			   ACDCDIG_DACDIGEN_DAC_GLBEN_MASK |
+			   ACDCDIG_DACDIGEN_DACEN_L0R1_MASK,
+			   ACDCDIG_DACDIGEN_DAC_GLBEN_DIS |
+			   ACDCDIG_DACDIGEN_DACEN_L0R1_DIS);
+
+	return 0;
+}
+
+static int rk_codec_digital_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct rk_codec_digital_priv *rcd =
+		snd_soc_component_get_drvdata(dai->component);
+	unsigned int srt = 0, val = 0;
+
+	rk_codec_digital_set_clk(rcd, substream, params_rate(params));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (params_rate(params)) {
+		case 8000:
+		case 11025:
+		case 12000:
+			srt = 0;
+			break;
+		case 16000:
+		case 22050:
+		case 24000:
+			srt = 1;
+			break;
+		case 32000:
+		case 44100:
+		case 48000:
+			srt = 2;
+			break;
+		case 64000:
+		case 88200:
+		case 96000:
+			srt = 3;
+			break;
+		case 128000:
+		case 176400:
+		case 192000:
+			srt = 4;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		regmap_update_bits(rcd->regmap, DACCFG1,
+				   ACDCDIG_DACCFG1_DACSRT_MASK,
+				   ACDCDIG_DACCFG1_DACSRT(srt));
+
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			val = 16;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+		case SNDRV_PCM_FORMAT_S32_LE:
+			val = 24;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		regmap_update_bits(rcd->regmap, I2S_RXCR0,
+				   ACDCDIG_I2S_RXCR0_VDW_MASK,
+				   ACDCDIG_I2S_RXCR0_VDW(val));
+		if (rcd->pwmout)
+			regmap_update_bits(rcd->regmap, DACPWM_CTRL,
+					   ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_MASK |
+					   ACDCDIG_DACPWM_CTRL_PWM_EN_MASK,
+					   ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_EN |
+					   ACDCDIG_DACPWM_CTRL_PWM_EN);
+	} else {
+		switch (params_rate(params)) {
+		case 8000:
+		case 11025:
+		case 12000:
+			srt = 0;
+			break;
+		case 16000:
+		case 22050:
+		case 24000:
+			srt = 1;
+			break;
+		case 32000:
+			srt = 2;
+			break;
+		case 44100:
+		case 48000:
+			srt = 3;
+			break;
+		case 64000:
+		case 88200:
+		case 96000:
+			srt = 4;
+			break;
+		case 128000:
+		case 176400:
+		case 192000:
+			srt = 5;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		regmap_update_bits(rcd->regmap, ADCCFG1,
+				   ACDCDIG_ADCCFG1_ADCSRT_MASK,
+				   ACDCDIG_ADCCFG1_ADCSRT(srt));
+
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			val = 16;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+		case SNDRV_PCM_FORMAT_S32_LE:
+			val = 24;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		regmap_update_bits(rcd->regmap, I2S_TXCR0,
+				   ACDCDIG_I2S_TXCR0_VDW_MASK,
+				   ACDCDIG_I2S_TXCR0_VDW(val));
+
+		switch (params_channels(params)) {
+		case 4:
+			val = ACDCDIG_I2S_TXCR1_TCSR_4CH;
+			break;
+		case 2:
+			val = ACDCDIG_I2S_TXCR1_TCSR_2CH;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		regmap_update_bits(rcd->regmap, I2S_TXCR1,
+				   ACDCDIG_I2S_TXCR1_TCSR_MASK, val);
+	}
+
+	if (rcd->sync)
+		return rk_codec_digital_enable_sync(rcd);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(rcd->regmap, I2S_XFER,
+				   ACDCDIG_I2S_XFER_RXS_MASK,
+				   ACDCDIG_I2S_XFER_RXS_START);
+		regmap_update_bits(rcd->regmap, DACDIGEN,
+				   ACDCDIG_DACDIGEN_DAC_GLBEN_MASK |
+				   ACDCDIG_DACDIGEN_DACEN_L0R1_MASK,
+				   ACDCDIG_DACDIGEN_DAC_GLBEN_EN |
+				   ACDCDIG_DACDIGEN_DACEN_L0R1_EN);
+	} else {
+		regmap_update_bits(rcd->regmap, I2S_XFER,
+				   ACDCDIG_I2S_XFER_TXS_MASK,
+				   ACDCDIG_I2S_XFER_TXS_START);
+		regmap_update_bits(rcd->regmap, ADCDIGEN,
+				   ACDCDIG_ADCDIGEN_ADC_GLBEN_MASK |
+				   ACDCDIG_ADCDIGEN_ADCEN_L2_MASK |
+				   ACDCDIG_ADCDIGEN_ADCEN_L0R1_MASK,
+				   ACDCDIG_ADCDIGEN_ADC_GLBEN_EN |
+				   ACDCDIG_ADCDIGEN_ADCEN_L2_EN |
+				   ACDCDIG_ADCDIGEN_ADCEN_L0R1_EN);
+	}
+
+	return 0;
+}
+
+static int rk_codec_digital_pcm_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	struct rk_codec_digital_priv *rcd =
+		snd_soc_component_get_drvdata(dai->component);
+
+	if (rcd->pa_ctl) {
+		gpiod_set_value_cansleep(rcd->pa_ctl, 1);
+		if (rcd->pa_ctl_delay_ms)
+			msleep(rcd->pa_ctl_delay_ms);
+	}
+
+	return 0;
+}
+
+static void rk_codec_digital_pcm_shutdown(struct snd_pcm_substream *substream,
+					  struct snd_soc_dai *dai)
+{
+	struct rk_codec_digital_priv *rcd =
+		snd_soc_component_get_drvdata(dai->component);
+
+	if (rcd->pa_ctl)
+		gpiod_set_value_cansleep(rcd->pa_ctl, 0);
+
+	if (rcd->sync) {
+		if (!snd_soc_component_active(dai->component)) {
+			rk_codec_digital_disable_sync(rcd);
+			rk_codec_digital_reset(rcd);
+		}
+
+		return;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (rcd->pwmout)
+			regmap_update_bits(rcd->regmap, DACPWM_CTRL,
+					   ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_MASK |
+					   ACDCDIG_DACPWM_CTRL_PWM_EN_MASK,
+					   ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_DIS |
+					   ACDCDIG_DACPWM_CTRL_PWM_DIS);
+		regmap_update_bits(rcd->regmap, I2S_XFER,
+				   ACDCDIG_I2S_XFER_RXS_MASK,
+				   ACDCDIG_I2S_XFER_RXS_STOP);
+		regmap_update_bits(rcd->regmap, I2S_CLR,
+				   ACDCDIG_I2S_CLR_RXC_MASK,
+				   ACDCDIG_I2S_CLR_RXC_CLR);
+		regmap_update_bits(rcd->regmap, DACDIGEN,
+				   ACDCDIG_DACDIGEN_DAC_GLBEN_MASK |
+				   ACDCDIG_DACDIGEN_DACEN_L0R1_MASK,
+				   ACDCDIG_DACDIGEN_DAC_GLBEN_DIS |
+				   ACDCDIG_DACDIGEN_DACEN_L0R1_DIS);
+	} else {
+		regmap_update_bits(rcd->regmap, I2S_XFER,
+				   ACDCDIG_I2S_XFER_TXS_MASK,
+				   ACDCDIG_I2S_XFER_TXS_STOP);
+		regmap_update_bits(rcd->regmap, I2S_CLR,
+				   ACDCDIG_I2S_CLR_TXC_MASK,
+				   ACDCDIG_I2S_CLR_TXC_CLR);
+
+		regmap_update_bits(rcd->regmap, ADCDIGEN,
+				   ACDCDIG_ADCDIGEN_ADC_GLBEN_MASK |
+				   ACDCDIG_ADCDIGEN_ADCEN_L2_MASK |
+				   ACDCDIG_ADCDIGEN_ADCEN_L0R1_MASK,
+				   ACDCDIG_ADCDIGEN_ADC_GLBEN_DIS |
+				   ACDCDIG_ADCDIGEN_ADCEN_L2_DIS |
+				   ACDCDIG_ADCDIGEN_ADCEN_L0R1_DIS);
+	}
+}
+
+static const struct snd_soc_dai_ops rcd_dai_ops = {
+	.hw_params = rk_codec_digital_hw_params,
+	.set_fmt = rk_codec_digital_set_dai_fmt,
+	.startup = rk_codec_digital_pcm_startup,
+	.shutdown = rk_codec_digital_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver rcd_dai[] = {
+	{
+		.name = "rk_codec_digital",
+		.id = 0,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 4,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rcd_dai_ops,
+	},
+};
+
+static const struct snd_soc_component_driver soc_codec_dev_rcd = {
+	.controls = rk_codec_digital_snd_controls,
+	.num_controls = ARRAY_SIZE(rk_codec_digital_snd_controls),
+};
+
+static const struct regmap_config rcd_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = VERSION,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int rk3568_soc_init(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+
+	if (IS_ERR(rcd->grf))
+		return PTR_ERR(rcd->grf);
+
+	/* enable internal codec to i2s3 */
+	return regmap_write(rcd->grf, RK3568_GRF_SOC_CON2,
+			    (BIT(13) << 16 | BIT(13)));
+}
+
+static void rk3568_soc_deinit(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+
+	if (IS_ERR(rcd->grf))
+		return;
+
+	regmap_write(rcd->grf, RK3568_GRF_SOC_CON2, (BIT(13) << 16));
+}
+
+static const struct rk_codec_digital_soc_data rk3568_data = {
+	.init = rk3568_soc_init,
+	.deinit = rk3568_soc_deinit,
+};
+
+static int rv1126_soc_init(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+
+	if (IS_ERR(rcd->grf))
+		return PTR_ERR(rcd->grf);
+
+	/* enable internal codec to i2s0 */
+	return regmap_write(rcd->grf, RV1126_GRF_SOC_CON2,
+			    (BIT(13) << 16 | BIT(13)));
+}
+
+static void rv1126_soc_deinit(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+
+	if (IS_ERR(rcd->grf))
+		return;
+
+	regmap_write(rcd->grf, RV1126_GRF_SOC_CON2, (BIT(13) << 16));
+}
+
+static const struct rk_codec_digital_soc_data rv1126_data = {
+	.init = rv1126_soc_init,
+	.deinit = rv1126_soc_deinit,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id rcd_of_match[] = {
+	{ .compatible = "rockchip,codec-digital-v1", },
+	{ .compatible = "rockchip,rk3568-codec-digital", .data = &rk3568_data },
+	{ .compatible = "rockchip,rv1126-codec-digital", .data = &rv1126_data },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rcd_of_match);
+#endif
+
+#ifdef CONFIG_PM
+static int rk_codec_digital_runtime_resume(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = clk_prepare_enable(rcd->pclk);
+	if (ret)
+		return ret;
+
+	regcache_cache_only(rcd->regmap, false);
+	regcache_mark_dirty(rcd->regmap);
+
+	ret = regcache_sync(rcd->regmap);
+	if (ret)
+		goto err;
+
+	ret = clk_prepare_enable(rcd->clk_adc);
+	if (ret)
+		goto err;
+
+	ret = clk_prepare_enable(rcd->clk_dac);
+	if (ret)
+		goto err_adc;
+
+	ret = clk_prepare_enable(rcd->clk_i2c);
+	if (ret)
+		goto err_dac;
+
+	return 0;
+
+err_dac:
+	clk_disable_unprepare(rcd->clk_dac);
+err_adc:
+	clk_disable_unprepare(rcd->clk_adc);
+err:
+	clk_disable_unprepare(rcd->pclk);
+
+	return ret;
+}
+
+static int rk_codec_digital_runtime_suspend(struct device *dev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(dev);
+
+	regcache_cache_only(rcd->regmap, true);
+	clk_disable_unprepare(rcd->clk_adc);
+	clk_disable_unprepare(rcd->clk_dac);
+	clk_disable_unprepare(rcd->clk_i2c);
+	clk_disable_unprepare(rcd->pclk);
+
+	return 0;
+}
+#endif
+
+static int rk_codec_digital_platform_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct rk_codec_digital_priv *rcd;
+	struct resource *res;
+	void __iomem *base;
+	int ret = 0;
+
+	rcd = devm_kzalloc(&pdev->dev, sizeof(*rcd), GFP_KERNEL);
+	if (!rcd)
+		return -ENOMEM;
+
+	rcd->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	rcd->pwmout = of_property_read_bool(np, "rockchip,pwm-output-mode");
+	rcd->sync = of_property_read_bool(np, "rockchip,clk-sync-mode");
+	if (of_property_read_u32(np, "rockchip,pa-ctl-delay-ms",
+				 &rcd->pa_ctl_delay_ms))
+		rcd->pa_ctl_delay_ms = 0;
+
+	rcd->rc = devm_reset_control_get(&pdev->dev, "reset");
+
+	rcd->clk_adc = devm_clk_get(&pdev->dev, "adc");
+	if (IS_ERR(rcd->clk_adc))
+		return PTR_ERR(rcd->clk_adc);
+
+	rcd->clk_dac = devm_clk_get(&pdev->dev, "dac");
+	if (IS_ERR(rcd->clk_dac))
+		return PTR_ERR(rcd->clk_dac);
+
+	/* optional on some platform */
+	rcd->clk_i2c = devm_clk_get_optional(&pdev->dev, "i2c");
+	if (IS_ERR(rcd->clk_i2c))
+		return PTR_ERR(rcd->clk_i2c);
+
+	rcd->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(rcd->pclk))
+		return PTR_ERR(rcd->pclk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	rcd->regmap =
+		devm_regmap_init_mmio(&pdev->dev, base, &rcd_regmap_config);
+	if (IS_ERR(rcd->regmap))
+		return PTR_ERR(rcd->regmap);
+
+	platform_set_drvdata(pdev, rcd);
+
+	rcd->data = of_device_get_match_data(&pdev->dev);
+	if (rcd->data && rcd->data->init) {
+		ret = rcd->data->init(&pdev->dev);
+		if (ret)
+			return ret;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = rk_codec_digital_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	if (rcd->pwmout)
+		regmap_update_bits(rcd->regmap, DACPWM_CTRL,
+				   ACDCDIG_DACPWM_CTRL_PWM_MODE_MASK,
+				   ACDCDIG_DACPWM_CTRL_PWM_MODE_0);
+
+	rcd->pa_ctl = devm_gpiod_get_optional(&pdev->dev, "pa-ctl",
+					       GPIOD_OUT_LOW);
+
+	if (!rcd->pa_ctl) {
+		dev_info(&pdev->dev, "no need pa-ctl gpio\n");
+	} else if (IS_ERR(rcd->pa_ctl)) {
+		ret = PTR_ERR(rcd->pa_ctl);
+		dev_err(&pdev->dev, "fail to request gpio pa-ctl\n");
+		goto err_suspend;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_rcd,
+					      rcd_dai, ARRAY_SIZE(rcd_dai));
+
+	if (ret)
+		goto err_suspend;
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_codec_digital_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	if (rcd->data && rcd->data->deinit)
+		rcd->data->deinit(&pdev->dev);
+
+	return ret;
+}
+
+static int rk_codec_digital_platform_remove(struct platform_device *pdev)
+{
+	struct rk_codec_digital_priv *rcd = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_codec_digital_runtime_suspend(&pdev->dev);
+
+	if (rcd->data && rcd->data->deinit)
+		rcd->data->deinit(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rcd_pm = {
+	SET_RUNTIME_PM_OPS(rk_codec_digital_runtime_suspend,
+		rk_codec_digital_runtime_resume, NULL)
+};
+
+static struct platform_driver rk_codec_digital_driver = {
+	.driver = {
+		.name = "rk_codec_digital",
+		.of_match_table = of_match_ptr(rcd_of_match),
+		.pm = &rcd_pm,
+	},
+	.probe = rk_codec_digital_platform_probe,
+	.remove = rk_codec_digital_platform_remove,
+};
+module_platform_driver(rk_codec_digital_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("ASoC Rockchip codec digital driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/rk_codec_digital.h b/sound/soc/codecs/rk_codec_digital.h
new file mode 100644
index 000000000..4bb409b8d
--- /dev/null
+++ b/sound/soc/codecs/rk_codec_digital.h
@@ -0,0 +1,319 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip Audio Codec Digital driver
+ *
+ * Copyright (C) 2020 Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _RK_CODEC_DIGITAL_H
+#define _RK_CODEC_DIGITAL_H
+
+#define SYSCTRL0		0x0000
+#define ADCVUCTL		0x0040
+#define ADCVUCTIME		0x0044
+#define ADCDIGEN		0x0048
+#define ADCCLKCTRL		0x004C
+#define ADCINT_DIV		0x0054
+#define ADCSCLKTXINT_DIV	0x006C
+#define ADCCFG1			0x0084
+#define ADCVOLL0		0x0088
+#define ADCVOLL1		0x008C
+#define ADCVOLR0		0x0098
+#define ADCVOGP			0x00A8
+#define ADCRVOLL0		0x00AC
+#define ADCRVOLL1		0x00B0
+#define ADCRVOLR0		0x00BC
+#define ADCALC0			0x00CC
+#define ADCALC1			0x00D0
+#define ADCALC2			0x00D4
+#define ADCNG			0x00D8
+#define ADCNGST			0x00DC
+#define ADCHPFEN		0x00E0
+#define ADCHPFCF		0x00E4
+#define ADCPGL0			0x00EC
+#define ADCPGL1			0x00F0
+#define ADCPGR0			0x00FC
+#define ADCLILMT0		0x010C
+#define ADCLILMT1		0x0110
+#define ADCDMICNG0		0x0114
+#define ADCDMICNG1		0x0118
+#define DACVUCTL		0x0140
+#define DACVUCTIME		0x0144
+#define DACDIGEN		0x0148
+#define DACCLKCTRL		0x014C
+#define DACINT_DIV		0x0154
+#define DACSCLKRXINT_DIV	0x0160
+#define DACPWM_DIV		0x0164
+#define DACPWM_CTRL		0x0168
+#define DACCFG1			0x0184
+#define DACMUTE			0x0188
+#define DACMUTEST		0x018C
+#define DACVOLL0		0x0190
+#define DACVOLR0		0x01A0
+#define DACVOGP			0x01B0
+#define DACRVOLL0		0x01B4
+#define DACRVOLR0		0x01C4
+#define DACLMT0			0x01D4
+#define DACLMT1			0x01D8
+#define DACLMT2			0x01DC
+#define DACMIXCTRLL		0x01E0
+#define DACMIXCTRLR		0x01E4
+#define DACHPF			0x01E8
+#define I2S_TXCR0		0x0300
+#define I2S_TXCR1		0x0304
+#define I2S_TXCR2		0x0308
+#define I2S_RXCR0		0x030C
+#define I2S_RXCR1		0x0310
+#define I2S_CKR0		0x0314
+#define I2S_CKR1		0x0318
+#define I2S_XFER		0x031C
+#define I2S_CLR			0x0320
+#define VERSION			0x0380
+
+/* SYSCTRL0 */
+#define ACDCDIG_SYSCTRL0_SYNC_SEL_MASK		BIT(1)
+#define ACDCDIG_SYSCTRL0_SYNC_SEL_DAC		BIT(1)
+#define ACDCDIG_SYSCTRL0_SYNC_SEL_ADC		0
+#define ACDCDIG_SYSCTRL0_GLB_CKE_MASK		BIT(3)
+#define ACDCDIG_SYSCTRL0_GLB_CKE_EN		BIT(3)
+#define ACDCDIG_SYSCTRL0_GLB_CKE_DIS		0
+#define ACDCDIG_SYSCTRL0_CLK_COM_SEL_MASK	BIT(4)
+#define ACDCDIG_SYSCTRL0_CLK_COM_SEL_DAC	BIT(4)
+#define ACDCDIG_SYSCTRL0_CLK_COM_SEL_ADC	0
+#define ACDCDIG_SYSCTRL0_SYNC_MODE_MASK		BIT(5)
+#define ACDCDIG_SYSCTRL0_SYNC_MODE_SYNC		BIT(5)
+#define ACDCDIG_SYSCTRL0_SYNC_MODE_ASYNC	0
+/* ADCVUCTL */
+#define ACDCDIG_ADCVUCTL_ADC_BYPS_MASK		BIT(2)
+#define ACDCDIG_ADCVUCTL_ADC_BYPS		BIT(2)
+/* ADCDIGEN */
+#define ACDCDIG_ADCDIGEN_ADCEN_L0R1_MASK	BIT(0)
+#define ACDCDIG_ADCDIGEN_ADCEN_L0R1_EN		BIT(0)
+#define ACDCDIG_ADCDIGEN_ADCEN_L0R1_DIS		0
+#define ACDCDIG_ADCDIGEN_ADCEN_L2_MASK		BIT(1)
+#define ACDCDIG_ADCDIGEN_ADCEN_L2_EN		BIT(1)
+#define ACDCDIG_ADCDIGEN_ADCEN_L2_DIS		0
+#define ACDCDIG_ADCDIGEN_ADC_GLBEN_MASK		BIT(4)
+#define ACDCDIG_ADCDIGEN_ADC_GLBEN_EN		BIT(4)
+#define ACDCDIG_ADCDIGEN_ADC_GLBEN_DIS		0
+/* ADCCLKCTRL */
+#define ACDCDIG_ADCCLKCTRL_ADC_SYNC_STATUS_MASK	BIT(0)
+#define ACDCDIG_ADCCLKCTRL_ADC_SYNC_ENA_MASK	BIT(1)
+#define ACDCDIG_ADCCLKCTRL_ADC_SYNC_ENA_EN	BIT(1)
+#define ACDCDIG_ADCCLKCTRL_ADC_SYNC_ENA_DIS	0
+#define ACDCDIG_ADCCLKCTRL_FILTER_GATE_EN_MASK	BIT(2)
+#define ACDCDIG_ADCCLKCTRL_FILTER_GATE_EN	BIT(2)
+#define ACDCDIG_ADCCLKCTRL_CKE_BCLKTX_MASK	BIT(3)
+#define ACDCDIG_ADCCLKCTRL_CKE_BCLKTX_EN	BIT(3)
+#define ACDCDIG_ADCCLKCTRL_CKE_BCLKTX_DIS	0
+#define ACDCDIG_ADCCLKCTRL_I2STX_CKE_MASK	BIT(4)
+#define ACDCDIG_ADCCLKCTRL_I2STX_CKE_EN		BIT(4)
+#define ACDCDIG_ADCCLKCTRL_I2STX_CKE_DIS	0
+#define ACDCDIG_ADCCLKCTRL_ADC_CKE_MASK		BIT(5)
+#define ACDCDIG_ADCCLKCTRL_ADC_CKE_EN		BIT(5)
+#define ACDCDIG_ADCCLKCTRL_ADC_CKE_DIS		0
+#define ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_MASK	GENMASK(7, 6)
+#define ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_16	(0x0 << 6)
+#define ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_8	(0x1 << 6)
+#define ACDCDIG_ADCCLKCTRL_CIC_DS_RATIO_4	(0x2 << 6)
+/* ADCINT_DIV */
+#define ACDCDIG_ADCINT_DIV_INT_DIV_CON_MASK	GENMASK(7, 0)
+#define ACDCDIG_ADCINT_DIV_INT_DIV_CON(x)	((x) - 1)
+/* ADCSCLKTXINT_DIV */
+#define ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV_MASK	GENMASK(7, 0)
+#define ACDCDIG_ADCSCLKTXINT_DIV_SCKTXDIV(x)	((x) - 1)
+/* ADCCFG1 */
+#define ACDCDIG_ADCCFG1_FIR_COM_BPS_MASK	BIT(0)
+#define ACDCDIG_ADCCFG1_FIR_COM_BPS_EN		BIT(0)
+#define ACDCDIG_ADCCFG1_SIG_SCALE_MODE_MASK	BIT(1)
+#define ACDCDIG_ADCCFG1_SIG_SCALE_MODE_HALF	BIT(1)
+#define ACDCDIG_ADCCFG1_ADCSRT_MASK		GENMASK(4, 2)
+#define ACDCDIG_ADCCFG1_ADCSRT(x)		(((x) & 0x7) << 2)
+/* ADCVOLL0 */
+#define ACDCDIG_ADCVOLL0_ADCLV0_MASK		GENMASK(7, 0)
+#define ACDCDIG_ADCVOLL0_ADCLV0(x)		(x)
+/* ADCVOLL1 */
+#define ACDCDIG_ADCVOLL1_ADCLV1_MASK		GENMASK(7, 0)
+#define ACDCDIG_ADCVOLL1_ADCLV1(x)		(x)
+/* ADCVOLR0 */
+#define ACDCDIG_ADCVOLR0_ADCRV0_MASK		GENMASK(7, 0)
+#define ACDCDIG_ADCVOLR0_ADCRV0(x)		(x)
+/* ADCVOGP */
+#define ACDCDIG_ADCVOGP_VOLGPL0_MASK		BIT(0)
+#define ACDCDIG_ADCVOGP_VOLGPL0_POS		BIT(0)
+#define ACDCDIG_ADCVOGP_VOLGPL0_NEG		0
+#define ACDCDIG_ADCVOGP_VOLGPR0_MASK		BIT(1)
+#define ACDCDIG_ADCVOGP_VOLGPR0_POS		BIT(1)
+#define ACDCDIG_ADCVOGP_VOLGPR0_NEG		0
+#define ACDCDIG_ADCVOGP_VOLGPL1_MASK		BIT(2)
+#define ACDCDIG_ADCVOGP_VOLGPL1_POS		BIT(2)
+#define ACDCDIG_ADCVOGP_VOLGPL1_NEG		0
+/* ADCALC0 */
+#define ACDCDIG_ADCALC0_ALCL0_MASK		BIT(0)
+#define ACDCDIG_ADCALC0_ALCL0_EN		BIT(0)
+#define ACDCDIG_ADCALC0_ALCR0_MASK		BIT(1)
+#define ACDCDIG_ADCALC0_ALCR0_EN		BIT(1)
+#define ACDCDIG_ADCALC0_ALCL1_MASK		BIT(2)
+#define ACDCDIG_ADCALC0_ALCL1_EN		BIT(2)
+/* ADCALC1 */
+#define ACDCDIG_ADCALC1_ALCRRATE_MASK		GENMASK(3, 0)
+#define ACDCDIG_ADCALC1_ALCRRATE(x)		((x) & 0xf)
+#define ACDCDIG_ADCALC1_ALCARATE_MASK		GENMASK(7, 4)
+#define ACDCDIG_ADCALC1_ALCARATE(x)		(((x) & 0xf) << 4)
+/* ADCALC2 */
+#define ACDCDIG_ADCALC2_ALCMIN_MASK		GENMASK(2, 0)
+#define ACDCDIG_ADCALC2_ALCMIN(x)		((x) & 0x7)
+#define ACDCDIG_ADCALC2_ALCMAX_MASK		GENMASK(6, 4)
+#define ACDCDIG_ADCALC2_ALCMAX(x)		(((x) & 0x7) << 4)
+/* ADCHPFEN */
+#define ACDCDIG_ADCHPFEN_HPFEN_L0_MASK		BIT(0)
+#define ACDCDIG_ADCHPFEN_HPFEN_L0_EN		BIT(0)
+#define ACDCDIG_ADCHPFEN_HPFEN_R0_MASK		BIT(1)
+#define ACDCDIG_ADCHPFEN_HPFEN_R0_EN		BIT(1)
+#define ACDCDIG_ADCHPFEN_HPFEN_L1_MASK		BIT(2)
+#define ACDCDIG_ADCHPFEN_HPFEN_L1_EN		BIT(2)
+/* ADCHPFCF */
+#define ACDCDIG_ADCHPFCF_HPFCF_MASK		GENMASK(1, 0)
+#define ACDCDIG_ADCHPFCF_HPFCF_493HZ		3
+#define ACDCDIG_ADCHPFCF_HPFCF_243HZ		2
+#define ACDCDIG_ADCHPFCF_HPFCF_60HZ		1
+#define ACDCDIG_ADCHPFCF_HPFCF_3P79HZ		0
+/* ADCPGL0 */
+#define ACDCDIG_ADCPGL0_PGA_L0_MASK		GENMASK(3, 0)
+/* ADCPGL1 */
+#define ACDCDIG_ADCPGL1_PGA_L1_MASK		GENMASK(3, 0)
+/* ADCPGR0 */
+#define ACDCDIG_ADCPGR0_PGA_R0_MASK		GENMASK(3, 0)
+/* DACDIGEN */
+#define ACDCDIG_DACDIGEN_DACEN_L0R1_MASK	BIT(0)
+#define ACDCDIG_DACDIGEN_DACEN_L0R1_EN		BIT(0)
+#define ACDCDIG_DACDIGEN_DACEN_L0R1_DIS		0
+#define ACDCDIG_DACDIGEN_DAC_GLBEN_MASK		BIT(4)
+#define ACDCDIG_DACDIGEN_DAC_GLBEN_EN		BIT(4)
+#define ACDCDIG_DACDIGEN_DAC_GLBEN_DIS		0
+/* DACCLKCTRL */
+#define ACDCDIG_DACCLKCTRL_DAC_MODE_ATTENU_MASK	BIT(0)
+#define ACDCDIG_DACCLKCTRL_DAC_MODE_ATTENU_EN	BIT(0)
+#define ACDCDIG_DACCLKCTRL_DAC_MODE_ATTENU_DIS	0
+#define ACDCDIG_DACCLKCTRL_DAC_SYNC_STATUS_MASK	BIT(1)
+#define ACDCDIG_DACCLKCTRL_DAC_SYNC_STATUS_DONE	0
+#define ACDCDIG_DACCLKCTRL_DAC_SYNC_ENA_MASK	BIT(2)
+#define ACDCDIG_DACCLKCTRL_DAC_SYNC_ENA_EN	BIT(2)
+#define ACDCDIG_DACCLKCTRL_DAC_SYNC_ENA_DIS	0
+#define ACDCDIG_DACCLKCTRL_CKE_BCLKRX_MASK	BIT(3)
+#define ACDCDIG_DACCLKCTRL_CKE_BCLKRX_EN	BIT(3)
+#define ACDCDIG_DACCLKCTRL_CKE_BCLKRX_DIS	0
+#define ACDCDIG_DACCLKCTRL_I2SRX_CKE_MASK	BIT(4)
+#define ACDCDIG_DACCLKCTRL_I2SRX_CKE_EN		BIT(4)
+#define ACDCDIG_DACCLKCTRL_I2SRX_CKE_DIS	0
+#define ACDCDIG_DACCLKCTRL_DAC_CKE_MASK		BIT(5)
+#define ACDCDIG_DACCLKCTRL_DAC_CKE_EN		BIT(5)
+#define ACDCDIG_DACCLKCTRL_DAC_CKE_DIS		0
+/* DACINT_DIV */
+#define ACDCDIG_DACINT_DIV_INT_DIV_CON_MASK	GENMASK(7, 0)
+#define ACDCDIG_DACINT_DIV_INT_DIV_CON(x)	((x) - 1)
+/* DACSCLKRXINT_DIV */
+#define ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV_MASK	GENMASK(7, 0)
+#define ACDCDIG_DACSCLKRXINT_DIV_SCKRXDIV(x)	((x) - 1)
+/* DACPWM_DIV */
+#define ACDCDIG_DACPWM_DIV_AUDIO_PWM_DIV_MASK	GENMASK(7, 0)
+#define ACDCDIG_DACPWM_DIV_AUDIO_PWM_DIV(x)	((x) - 1)
+/* DACPWM_CTRL */
+#define ACDCDIG_DACPWM_CTRL_DITH_SEL_MASK	GENMASK(2, 0)
+#define ACDCDIG_DACPWM_CTRL_DITH_SEL(x)		(x)
+#define ACDCDIG_DACPWM_CTRL_PWM_EN_MASK		BIT(3)
+#define ACDCDIG_DACPWM_CTRL_PWM_EN		BIT(3)
+#define ACDCDIG_DACPWM_CTRL_PWM_DIS		0
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_MASK	GENMASK(5, 4)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_1		(0x2 << 4)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_0		(0x1 << 4)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_DAC	(0x0 << 4)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_MASK	BIT(6)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_EN	BIT(6)
+#define ACDCDIG_DACPWM_CTRL_PWM_MODE_CKE_DIS	0
+/* DACCFG1 */
+#define ACDCDIG_DACCFG1_DACSRT_MASK		GENMASK(4, 2)
+#define ACDCDIG_DACCFG1_DACSRT(x)		((x) << 2)
+/* DACMUTE */
+#define ACDCDIG_DACMUTE_DACMT_MASK		BIT(0)
+#define ACDCDIG_DACMUTE_DACUNMT_MASK		BIT(1)
+/* DACVOLL0 */
+#define ACDCDIG_DACVOLL0_DACLV0_MASK		GENMASK(7, 0)
+#define ACDCDIG_DACVOLL0_DACLV0(x)		(x)
+/* DACVOLR0 */
+#define ACDCDIG_DACVOLR0_DACRV0_MASK		GENMASK(7, 0)
+#define ACDCDIG_DACVOLR0_DACRV0(x)		(x)
+/* DACVOGP */
+#define ACDCDIG_DACVOGP_VOLGPL0_MASK		BIT(0)
+#define ACDCDIG_DACVOGP_VOLGPL0_POS		BIT(0)
+#define ACDCDIG_DACVOGP_VOLGPL0_NEG		0
+#define ACDCDIG_DACVOGP_VOLGPR0_MASK		BIT(1)
+#define ACDCDIG_DACVOGP_VOLGPR0_POS		BIT(1)
+#define ACDCDIG_DACVOGP_VOLGPR0_NEG		0
+/* DACMIXCTRLL */
+#define ACDCDIG_DACMIXCTRLL_MIXMODE_L0_MASK	GENMASK(1, 0)
+#define ACDCDIG_DACMIXCTRLL_MIXMODE_L0_LR	2
+#define ACDCDIG_DACMIXCTRLL_MIXMODE_L0_R	1
+#define ACDCDIG_DACMIXCTRLL_MIXMODE_L0_L	0
+/* DACMIXCTRLR */
+#define ACDCDIG_DACMIXCTRLR_MIXMODE_R0_MASK	GENMASK(1, 0)
+#define ACDCDIG_DACMIXCTRLR_MIXMODE_R0_LR	2
+#define ACDCDIG_DACMIXCTRLR_MIXMODE_R0_L	1
+#define ACDCDIG_DACMIXCTRLR_MIXMODE_R0_R	0
+/* DACHPF */
+#define ACDCDIG_DACHPF_HPFEN_L0R0_MASK		BIT(0)
+#define ACDCDIG_DACHPF_HPFEN_L0R0_EN		BIT(0)
+#define ACDCDIG_DACHPF_HPFCF_MASK		GENMASK(5, 4)
+#define ACDCDIG_DACHPF_HPFCF_140HZ		(0x3 << 4)
+#define ACDCDIG_DACHPF_HPFCF_120HZ		(0x2 << 4)
+#define ACDCDIG_DACHPF_HPFCF_100HZ		(0x1 << 4)
+#define ACDCDIG_DACHPF_HPFCF_80HZ		(0x0 << 4)
+/* I2S_TXCR0 */
+#define ACDCDIG_I2S_TXCR0_VDW_MASK		GENMASK(4, 0)
+#define ACDCDIG_I2S_TXCR0_VDW(x)		((x) - 1)
+/* I2S_TXCR1 */
+#define ACDCDIG_I2S_TXCR1_CEX_MASK		BIT(4)
+#define ACDCDIG_I2S_TXCR1_CEX_EXCHANGE		BIT(4)
+#define ACDCDIG_I2S_TXCR1_TCSR_MASK		GENMASK(7, 6)
+#define ACDCDIG_I2S_TXCR1_TCSR_4CH		(0x1 << 6)
+#define ACDCDIG_I2S_TXCR1_TCSR_2CH		(0x0 << 6)
+/* I2S_RXCR0 */
+#define ACDCDIG_I2S_RXCR0_VDW_MASK		GENMASK(4, 0)
+#define ACDCDIG_I2S_RXCR0_VDW(x)		((x) - 1)
+/* I2S_RXCR1 */
+#define ACDCDIG_I2S_RXCR1_CEX_MASK		BIT(4)
+#define ACDCDIG_I2S_RXCR1_CEX_EXCHANGE		BIT(4)
+#define ACDCDIG_I2S_RXCR1_RCSR_MASK		GENMASK(7, 6)
+#define ACDCDIG_I2S_RXCR1_RCSR_2CH		(0x0 << 6)
+/* I2S_CKR0 */
+#define ACDCDIG_I2S_CKR0_TSD_MASK		GENMASK(1, 0)
+#define ACDCDIG_I2S_CKR0_TSD(x)			((x) << 0)
+#define ACDCDIG_I2S_CKR0_RSD_MASK		GENMASK(3, 2)
+#define ACDCDIG_I2S_CKR0_RSD(x)			((x) << 2)
+/* I2S_CKR1 */
+#define ACDCDIG_I2S_CKR1_TLP_MASK		BIT(0)
+#define ACDCDIG_I2S_CKR1_TLP_INVERTED		BIT(0)
+#define ACDCDIG_I2S_CKR1_TLP_NORMAL		0
+#define ACDCDIG_I2S_CKR1_RLP_MASK		BIT(1)
+#define ACDCDIG_I2S_CKR1_RLP_INVERTED		BIT(1)
+#define ACDCDIG_I2S_CKR1_RLP_NORMAL		0
+#define ACDCDIG_I2S_CKR1_CKP_MASK		BIT(2)
+#define ACDCDIG_I2S_CKR1_CKP_INVERTED		BIT(2)
+#define ACDCDIG_I2S_CKR1_CKP_NORMAL		0
+#define ACDCDIG_I2S_CKR1_MSS_MASK		BIT(3)
+#define ACDCDIG_I2S_CKR1_MSS_MASTER		0
+/* I2S_XFER */
+#define ACDCDIG_I2S_XFER_TXS_MASK		BIT(0)
+#define ACDCDIG_I2S_XFER_TXS_START		BIT(0)
+#define ACDCDIG_I2S_XFER_TXS_STOP		0
+#define ACDCDIG_I2S_XFER_RXS_MASK		BIT(1)
+#define ACDCDIG_I2S_XFER_RXS_START		BIT(1)
+#define ACDCDIG_I2S_XFER_RXS_STOP		0
+/* I2S_CLR */
+#define ACDCDIG_I2S_CLR_TXC_MASK		BIT(0)
+#define ACDCDIG_I2S_CLR_TXC_CLR			BIT(0)
+#define ACDCDIG_I2S_CLR_RXC_MASK		BIT(1)
+#define ACDCDIG_I2S_CLR_RXC_CLR			BIT(1)
+
+#endif
diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c
index a5674c227..0db73e7a0 100644
--- a/sound/soc/codecs/rt5640.c
+++ b/sound/soc/codecs/rt5640.c
@@ -1335,7 +1335,9 @@ static const struct snd_soc_dapm_route rt5640_dapm_routes[] = {
 	{ "I2S2", NULL, "I2S2 Filter ASRC", is_using_asrc },
 	{ "DMIC1", NULL, "DMIC1 ASRC", is_using_asrc },
 	{ "DMIC2", NULL, "DMIC2 ASRC", is_using_asrc },
-
+	{"IN1P", NULL, "MICBIAS1"},
+	{"IN2P", NULL, "MICBIAS1"},
+	{"IN3P", NULL, "MICBIAS1"},
 	{"IN1P", NULL, "LDO2"},
 	{"IN2P", NULL, "LDO2"},
 	{"IN3P", NULL, "LDO2"},
diff --git a/sound/soc/codecs/rt5651.c b/sound/soc/codecs/rt5651.c
index e59fdc81d..2dd8d6d4f 100644
--- a/sound/soc/codecs/rt5651.c
+++ b/sound/soc/codecs/rt5651.c
@@ -24,6 +24,9 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <sound/jack.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
 
 #include "rl6231.h"
 #include "rt5651.h"
@@ -284,6 +287,40 @@ static bool rt5651_readable_register(struct device *dev, unsigned int reg)
 	}
 }
 
+static int rt5651_asrc_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = rt5651->asrc_en;
+
+	return 0;
+}
+
+static int rt5651_asrc_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
+
+	rt5651->asrc_en = ucontrol->value.integer.value[0];
+	if (rt5651->asrc_en) {
+		regmap_write(rt5651->regmap, 0x80, 0x4000);
+		regmap_write(rt5651->regmap, 0x81, 0x0302);
+		regmap_write(rt5651->regmap, 0x82, 0x0800);
+		regmap_write(rt5651->regmap, 0x73, 0x1004);
+		regmap_write(rt5651->regmap, 0x83, 0x1000);
+		regmap_write(rt5651->regmap, 0x84, 0x7000);
+		snd_soc_component_update_bits(component, 0x64, 0x0200, 0x0200);
+		snd_soc_component_update_bits(component, RT5651_D_MISC, 0xc00, 0xc00);
+	} else {
+		regmap_write(rt5651->regmap, 0x83, 0x0);
+		regmap_write(rt5651->regmap, 0x84, 0x0);
+	}
+	return 0;
+}
+
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -4650, 150, 0);
 static const DECLARE_TLV_DB_MINMAX(dac_vol_tlv, -6562, 0);
 static const DECLARE_TLV_DB_SCALE(in_vol_tlv, -3450, 150, 0);
@@ -311,6 +348,10 @@ static SOC_ENUM_SINGLE_DECL(rt5651_if2_dac_enum, RT5651_DIG_INF_DATA,
 static SOC_ENUM_SINGLE_DECL(rt5651_if2_adc_enum, RT5651_DIG_INF_DATA,
 				RT5651_IF2_ADC_SEL_SFT, rt5651_data_select);
 
+static const char * const rt5651_asrc_mode[] = {"Disable", "Enable"};
+
+static SOC_ENUM_SINGLE_DECL(rt5651_asrc_enum, 0, 0, rt5651_asrc_mode);
+
 static const struct snd_kcontrol_new rt5651_snd_controls[] = {
 	/* Headphone Output Volume */
 	SOC_DOUBLE_TLV("HP Playback Volume", RT5651_HP_VOL,
@@ -353,6 +394,9 @@ static const struct snd_kcontrol_new rt5651_snd_controls[] = {
 			RT5651_ADC_L_BST_SFT, RT5651_ADC_R_BST_SFT,
 			3, 0, adc_bst_tlv),
 
+	/* RT5651 ASRC Switch */
+	SOC_ENUM_EXT("RT5651 ASRC Switch", rt5651_asrc_enum,
+		     rt5651_asrc_get, rt5651_asrc_put),
 	/* ASRC */
 	SOC_SINGLE("IF1 ASRC Switch", RT5651_PLL_MODE_1,
 		RT5651_STO1_T_SFT, 1, 0),
@@ -1511,9 +1555,13 @@ static int rt5651_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,
 static int rt5651_set_bias_level(struct snd_soc_component *component,
 			enum snd_soc_bias_level level)
 {
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
+
 	switch (level) {
 	case SND_SOC_BIAS_PREPARE:
 		if (SND_SOC_BIAS_STANDBY == snd_soc_component_get_bias_level(component)) {
+			if (!IS_ERR(rt5651->mclk))
+				clk_prepare_enable(rt5651->mclk);
 			if (snd_soc_component_read(component, RT5651_PLL_MODE_1) & 0x9200)
 				snd_soc_component_update_bits(component, RT5651_D_MISC,
 						    0xc00, 0xc00);
@@ -1531,6 +1579,9 @@ static int rt5651_set_bias_level(struct snd_soc_component *component,
 				RT5651_PWR_FV1 | RT5651_PWR_FV2,
 				RT5651_PWR_FV1 | RT5651_PWR_FV2);
 			snd_soc_component_update_bits(component, RT5651_D_MISC, 0x1, 0x1);
+		} else if (SND_SOC_BIAS_PREPARE == snd_soc_component_get_bias_level(component)) {
+			if (!IS_ERR(rt5651->mclk))
+				clk_disable_unprepare(rt5651->mclk);
 		}
 		break;
 
@@ -2061,6 +2112,10 @@ static int rt5651_probe(struct snd_soc_component *component)
 
 	rt5651->component = component;
 
+	rt5651->mclk = devm_clk_get(component->dev, "mclk");
+	if (PTR_ERR(rt5651->mclk) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
 	snd_soc_component_update_bits(component, RT5651_PWR_ANLG1,
 		RT5651_PWR_LDO_DVO_MASK, RT5651_PWR_LDO_DVO_1_2V);
 
@@ -2071,6 +2126,25 @@ static int rt5651_probe(struct snd_soc_component *component)
 	return 0;
 }
 
+static void rt5651_enable_spk(struct rt5651_priv *rt5651, bool enable)
+{
+	if (!rt5651 || !rt5651->gpiod_spk_ctl)
+		return;
+	gpiod_set_value(rt5651->gpiod_spk_ctl, enable);
+}
+
+static int rt5651_mute(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rt5651_priv *rt5651 = snd_soc_component_get_drvdata(component);
+
+	if (mute)
+		rt5651_enable_spk(rt5651, false);
+	else
+		rt5651_enable_spk(rt5651, true);
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int rt5651_suspend(struct snd_soc_component *component)
 {
@@ -2104,6 +2178,8 @@ static const struct snd_soc_dai_ops rt5651_aif_dai_ops = {
 	.set_fmt = rt5651_set_dai_fmt,
 	.set_sysclk = rt5651_set_dai_sysclk,
 	.set_pll = rt5651_set_dai_pll,
+	.mute_stream = rt5651_mute,
+	.no_capture_mute = 1,
 };
 
 static struct snd_soc_dai_driver rt5651_dai[] = {
@@ -2270,7 +2346,14 @@ static int rt5651_i2c_probe(struct i2c_client *i2c,
 			 rt5651->irq, ret);
 		rt5651->irq = -ENXIO;
 	}
-
+	rt5651->gpiod_spk_ctl = devm_gpiod_get(&i2c->dev,
+					       "spk-con",
+					       GPIOD_OUT_LOW);
+	if (IS_ERR(rt5651->gpiod_spk_ctl)) {
+		ret = IS_ERR(rt5651->gpiod_spk_ctl);
+		rt5651->gpiod_spk_ctl = NULL;
+		dev_warn(&i2c->dev, "cannot get spk-con-gpio %d\n", ret);
+	}
 	ret = devm_snd_soc_register_component(&i2c->dev,
 				&soc_component_dev_rt5651,
 				rt5651_dai, ARRAY_SIZE(rt5651_dai));
diff --git a/sound/soc/codecs/rt5651.h b/sound/soc/codecs/rt5651.h
index 20c33a3ec..05739b178 100644
--- a/sound/soc/codecs/rt5651.h
+++ b/sound/soc/codecs/rt5651.h
@@ -2096,7 +2096,10 @@ struct rt5651_priv {
 	int pll_out;
 
 	int dmic_en;
+	int asrc_en;
 	bool hp_mute;
+	struct clk *mclk;
+	struct gpio_desc *gpiod_spk_ctl;
 };
 
 #endif /* __RT5651_H__ */
diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c
index c86231dfc..0827b7e65 100644
--- a/sound/soc/codecs/wm8974.c
+++ b/sound/soc/codecs/wm8974.c
@@ -7,6 +7,7 @@
  * Author: Liam Girdwood <Liam.Girdwood@wolfsonmicro.com>
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -27,6 +28,7 @@
 struct wm8974_priv {
 	unsigned int mclk;
 	unsigned int fs;
+	struct clk *mclk_in;
 };
 
 static const struct reg_default wm8974_reg_defaults[] = {
@@ -613,6 +615,36 @@ static int wm8974_set_bias_level(struct snd_soc_component *component,
 	return 0;
 }
 
+static int wm8974_startup(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct wm8974_priv *priv = snd_soc_component_get_drvdata(component);
+	u16 power1 = snd_soc_component_read(component, WM8974_POWER1);
+
+	clk_prepare_enable(priv->mclk_in);
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		power1 |= 0x10;
+		snd_soc_component_write(component, WM8974_POWER1, power1);
+	}
+
+	return 0;
+}
+
+static void wm8974_shutdown(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct wm8974_priv *priv = snd_soc_component_get_drvdata(component);
+	u16 power1 = snd_soc_component_read(component, WM8974_POWER1);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		power1 &= ~0x10;
+		snd_soc_component_write(component, WM8974_POWER1, power1);
+	}
+	clk_disable_unprepare(priv->mclk_in);
+}
+
 #define WM8974_RATES (SNDRV_PCM_RATE_8000_48000)
 
 #define WM8974_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
@@ -625,6 +657,8 @@ static const struct snd_soc_dai_ops wm8974_ops = {
 	.set_clkdiv = wm8974_set_dai_clkdiv,
 	.set_pll = wm8974_set_dai_pll,
 	.set_sysclk = wm8974_set_dai_sysclk,
+	.startup = wm8974_startup,
+	.shutdown = wm8974_shutdown,
 	.no_capture_mute = 1,
 };
 
@@ -702,6 +736,10 @@ static int wm8974_i2c_probe(struct i2c_client *i2c,
 	if (IS_ERR(regmap))
 		return PTR_ERR(regmap);
 
+	priv->mclk_in = devm_clk_get(&i2c->dev, "mclk");
+	if (IS_ERR(priv->mclk_in))
+		return PTR_ERR(priv->mclk_in);
+
 	ret = devm_snd_soc_register_component(&i2c->dev,
 			&soc_component_dev_wm8974, &wm8974_dai, 1);
 
diff --git a/sound/soc/rockchip/Kconfig b/sound/soc/rockchip/Kconfig
index d610b553e..fa31a0151 100644
--- a/sound/soc/rockchip/Kconfig
+++ b/sound/soc/rockchip/Kconfig
@@ -7,6 +7,22 @@ config SND_SOC_ROCKCHIP
 	  the Rockchip SoCs' Audio interfaces. You will also need to
 	  select the audio interfaces to support below.
 
+config SND_SOC_ROCKCHIP_PREALLOC_BUFFER_SIZE
+	int "Default prealloc buffer size (kbytes)"
+	depends on SND_SOC_ROCKCHIP
+	default "512"
+	help
+	  The default value is 512 kilobytes. Only change this if you know
+	  what you are doing.
+
+config SND_SOC_ROCKCHIP_AUDIO_PWM
+	tristate "Rockchip Audio PWM Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for Audio PWM driver for
+	  Rockchip Audio PWM Controller.
+
 config SND_SOC_ROCKCHIP_I2S
 	tristate "Rockchip I2S Device Driver"
 	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
@@ -16,6 +32,15 @@ config SND_SOC_ROCKCHIP_I2S
 	  Rockchip I2S device. The device supports upto maximum of
 	  8 channels each for play and record.
 
+config SND_SOC_ROCKCHIP_I2S_TDM
+	tristate "Rockchip I2S/TDM Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for I2S/TDM driver for
+	  Rockchip I2S/TDM device. The device supports up to maximum of
+	  8 channels each for play and record.
+
 config SND_SOC_ROCKCHIP_PDM
 	tristate "Rockchip PDM Controller Driver"
 	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
@@ -34,6 +59,21 @@ config SND_SOC_ROCKCHIP_SPDIF
 	  Say Y or M if you want to add support for SPDIF driver for
 	  Rockchip SPDIF transceiver device.
 
+config SND_SOC_ROCKCHIP_SPDIFRX
+	tristate "Rockchip SPDIFRX Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for SPDIFRX driver for
+	  Rockchip SPDIF receiver device.
+
+config SND_SOC_ROCKCHIP_VAD
+	tristate "Rockchip Voice Activity Detection Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	help
+	  Say Y or M if you want to add support for VAD driver for
+	  Rockchip VAD device.
+
 config SND_SOC_ROCKCHIP_MAX98090
 	tristate "ASoC support for Rockchip boards using a MAX98090 codec"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
@@ -45,6 +85,13 @@ config SND_SOC_ROCKCHIP_MAX98090
 	  Say Y or M here if you want to add support for SoC audio on Rockchip
 	  boards using the MAX98090 codec and HDMI codec, such as Veyron.
 
+config SND_SOC_ROCKCHIP_MULTICODECS
+	tristate "ASoC support for Rockchip multicodecs"
+	depends on SND_SOC_ROCKCHIP && CLKDEV_LOOKUP
+	help
+	  Say Y or M here if you want to add support for SoC audio on Rockchip
+	  boards using multicodecs, such as RK3308 boards.
+
 config SND_SOC_ROCKCHIP_RT5645
 	tristate "ASoC support for Rockchip boards using a RT5645/RT5650 codec"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
@@ -54,6 +101,14 @@ config SND_SOC_ROCKCHIP_RT5645
 	  Say Y or M here if you want to add support for SoC audio on Rockchip
 	  boards using the RT5645/RT5650 codec, such as Veyron.
 
+config SND_SOC_ROCKCHIP_HDMI
+	tristate "ASoC support for Rockchip HDMI audio"
+	depends on SND_SOC_ROCKCHIP && CLKDEV_LOOKUP
+	select SND_SOC_HDMI_CODEC
+	help
+	  Say Y or M here if you want to add support for SoC audio on Rockchip
+	  boards using built-in HDMI or external HDMI.
+
 config SND_SOC_RK3288_HDMI_ANALOG
 	tristate "ASoC support multiple codecs for Rockchip RK3288 boards"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
diff --git a/sound/soc/rockchip/Makefile b/sound/soc/rockchip/Makefile
index 65e814d46..c3a8bdb31 100644
--- a/sound/soc/rockchip/Makefile
+++ b/sound/soc/rockchip/Makefile
@@ -1,20 +1,39 @@
 # SPDX-License-Identifier: GPL-2.0
 # ROCKCHIP Platform Support
+snd-soc-rockchip-audio-pwm-objs := rockchip_audio_pwm.o
 snd-soc-rockchip-i2s-objs := rockchip_i2s.o
+snd-soc-rockchip-i2s-tdm-objs := rockchip_i2s_tdm.o
 snd-soc-rockchip-pcm-objs := rockchip_pcm.o
 snd-soc-rockchip-pdm-objs := rockchip_pdm.o
 snd-soc-rockchip-spdif-objs := rockchip_spdif.o
+snd-soc-rockchip-spdifrx-objs := rockchip_spdifrx.o
+snd-soc-rockchip-vad-objs := rockchip_vad.o
+ifdef CONFIG_THUMB2_KERNEL
+snd-soc-rockchip-vad-$(CONFIG_THUMB2_KERNEL) += vad_preprocess_thumb.o
+else
+snd-soc-rockchip-vad-$(CONFIG_ARM64) += vad_preprocess_arm64.o
+snd-soc-rockchip-vad-$(CONFIG_ARM) += vad_preprocess_arm.o
+endif
 
-obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S) += snd-soc-rockchip-i2s.o snd-soc-rockchip-pcm.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP) += snd-soc-rockchip-pcm.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_AUDIO_PWM) += snd-soc-rockchip-audio-pwm.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S) += snd-soc-rockchip-i2s.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S_TDM) += snd-soc-rockchip-i2s-tdm.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_PDM) += snd-soc-rockchip-pdm.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_SPDIF) += snd-soc-rockchip-spdif.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_SPDIFRX) += snd-soc-rockchip-spdifrx.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_VAD) += snd-soc-rockchip-vad.o
 
+snd-soc-rockchip-hdmi-objs := rockchip_hdmi.o
 snd-soc-rockchip-max98090-objs := rockchip_max98090.o
+snd-soc-rockchip-multicodecs-objs := rockchip_multicodecs.o
 snd-soc-rockchip-rt5645-objs := rockchip_rt5645.o
 snd-soc-rk3288-hdmi-analog-objs := rk3288_hdmi_analog.o
 snd-soc-rk3399-gru-sound-objs := rk3399_gru_sound.o
 
+obj-$(CONFIG_SND_SOC_ROCKCHIP_HDMI) += snd-soc-rockchip-hdmi.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_MAX98090) += snd-soc-rockchip-max98090.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_MULTICODECS) += snd-soc-rockchip-multicodecs.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_RT5645) += snd-soc-rockchip-rt5645.o
 obj-$(CONFIG_SND_SOC_RK3288_HDMI_ANALOG) += snd-soc-rk3288-hdmi-analog.o
 obj-$(CONFIG_SND_SOC_RK3399_GRU_SOUND) += snd-soc-rk3399-gru-sound.o
diff --git a/sound/soc/rockchip/rockchip_audio_pwm.c b/sound/soc/rockchip/rockchip_audio_pwm.c
new file mode 100644
index 000000000..44ca66f1e
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_audio_pwm.c
@@ -0,0 +1,372 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Rockchip Audio PWM Driver
+ *
+ * Copyright (C) 2020 Fuzhou Rockchip Electronics Co.,Ltd
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+
+#include "rockchip_audio_pwm.h"
+
+#define AUDIO_PWM_DMA_BURST_SIZE	(16) /* size * width: 16*4 = 64 bytes */
+
+struct rk_audio_pwm_dev {
+	struct device *dev;
+	struct clk *clk;
+	struct clk *hclk;
+	struct regmap *regmap;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct gpio_desc *spk_ctl_gpio;
+	int interpolat_points;
+	int sample_width_bits;
+};
+
+static inline struct rk_audio_pwm_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+static void rockchip_audio_spk_ctl(struct rk_audio_pwm_dev *apwm, int on)
+{
+	if (apwm->spk_ctl_gpio)
+		gpiod_direction_output(apwm->spk_ctl_gpio, on);
+}
+
+static void rockchip_audio_pwm_xfer(struct rk_audio_pwm_dev *apwm, int on)
+{
+	if (on) {
+		regmap_write(apwm->regmap, AUDPWM_FIFO_CFG, AUDPWM_DMA_EN);
+		regmap_write(apwm->regmap, AUDPWM_XFER, AUDPWM_XFER_START);
+		rockchip_audio_spk_ctl(apwm, on);
+	} else {
+		rockchip_audio_spk_ctl(apwm, on);
+		regmap_write(apwm->regmap, AUDPWM_FIFO_CFG, AUDPWM_DMA_DIS);
+		regmap_write(apwm->regmap, AUDPWM_XFER, AUDPWM_XFER_STOP);
+	}
+}
+
+static int rockchip_audio_pwm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+	struct rk_audio_pwm_dev *apwm = to_info(dai);
+	unsigned long rate;
+	int ret;
+
+	rate = params_rate(params) << apwm->sample_width_bits;
+	if (apwm->interpolat_points) {
+		rate *= (apwm->interpolat_points + 1);
+		regmap_write(apwm->regmap, AUDPWM_PWM_CFG,
+			     AUDPWM_LINEAR_INTERP_EN |
+			     AUDPWM_INTERP_RATE(apwm->interpolat_points));
+	}
+	if (!rate)
+		return -EINVAL;
+	ret = clk_set_rate(apwm->clk, rate);
+	if (ret)
+		return -EINVAL;
+
+	regmap_write(apwm->regmap, AUDPWM_SRC_CFG,
+		     AUDPWM_SRC_WIDTH(params_width(params)));
+	regmap_write(apwm->regmap, AUDPWM_PWM_CFG,
+		     AUDPWM_SAMPLE_WIDTH(apwm->sample_width_bits));
+	regmap_write(apwm->regmap, AUDPWM_FIFO_CFG,
+		     AUDPWM_DMA_WATERMARK(16));
+
+	return 0;
+}
+
+static int rockchip_audio_pwm_trigger(struct snd_pcm_substream *substream,
+				      int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_audio_pwm_dev *apwm = to_info(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rockchip_audio_pwm_xfer(apwm, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rockchip_audio_pwm_xfer(apwm, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_audio_pwm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_audio_pwm_dev *apwm = to_info(dai);
+
+	dai->playback_dma_data = &apwm->playback_dma_data;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_audio_pwm_dai_ops = {
+	.trigger = rockchip_audio_pwm_trigger,
+	.hw_params = rockchip_audio_pwm_hw_params,
+};
+
+#define ROCKCHIP_AUDIO_PWM_RATES SNDRV_PCM_RATE_8000_48000
+#define ROCKCHIP_AUDIO_PWM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+				    SNDRV_PCM_FMTBIT_S24_LE | \
+				    SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver rockchip_audio_pwm_dai = {
+	.probe = rockchip_audio_pwm_dai_probe,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = ROCKCHIP_AUDIO_PWM_RATES,
+		.formats = ROCKCHIP_AUDIO_PWM_FORMATS,
+	},
+	.ops = &rockchip_audio_pwm_dai_ops,
+};
+
+static const struct snd_soc_component_driver rockchip_audio_pwm_component = {
+	.name = "rockchip-audio-pwm",
+};
+
+static int __maybe_unused rockchip_audio_pwm_runtime_suspend(struct device *dev)
+{
+	struct rk_audio_pwm_dev *apwm = dev_get_drvdata(dev);
+
+	regcache_cache_only(apwm->regmap, true);
+	clk_disable_unprepare(apwm->clk);
+	clk_disable_unprepare(apwm->hclk);
+
+	return 0;
+}
+
+static int __maybe_unused rockchip_audio_pwm_runtime_resume(struct device *dev)
+{
+	struct rk_audio_pwm_dev *apwm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(apwm->clk);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(apwm->hclk);
+	if (ret)
+		return ret;
+
+	regcache_cache_only(apwm->regmap, false);
+	regcache_mark_dirty(apwm->regmap);
+	ret = regcache_sync(apwm->regmap);
+	if (ret) {
+		clk_disable_unprepare(apwm->clk);
+		clk_disable_unprepare(apwm->hclk);
+	}
+
+	return 0;
+}
+
+static bool rockchip_audio_pwm_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AUDPWM_XFER:
+	case AUDPWM_SRC_CFG:
+	case AUDPWM_PWM_CFG:
+	case AUDPWM_FIFO_CFG:
+	case AUDPWM_FIFO_INT_EN:
+	case AUDPWM_FIFO_INT_ST:
+	case AUDPWM_FIFO_ENTRY:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_audio_pwm_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AUDPWM_VERSION:
+	case AUDPWM_XFER:
+	case AUDPWM_SRC_CFG:
+	case AUDPWM_PWM_CFG:
+	case AUDPWM_PWM_ST:
+	case AUDPWM_PWM_BUF_01:
+	case AUDPWM_PWM_BUF_23:
+	case AUDPWM_FIFO_CFG:
+	case AUDPWM_FIFO_LVL:
+	case AUDPWM_FIFO_INT_EN:
+	case AUDPWM_FIFO_INT_ST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_audio_pwm_volatile_reg(struct device *dev,
+					    unsigned int reg)
+{
+	switch (reg) {
+	case AUDPWM_XFER:
+	case AUDPWM_PWM_ST:
+	case AUDPWM_PWM_BUF_01:
+	case AUDPWM_PWM_BUF_23:
+	case AUDPWM_FIFO_LVL:
+	case AUDPWM_FIFO_INT_ST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config rockchip_audio_pwm_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = AUDPWM_FIFO_ENTRY,
+	.writeable_reg = rockchip_audio_pwm_wr_reg,
+	.readable_reg = rockchip_audio_pwm_rd_reg,
+	.volatile_reg = rockchip_audio_pwm_volatile_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static const struct of_device_id rockchip_audio_pwm_match[] = {
+	{ .compatible = "rockchip,audio-pwm-v1" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_audio_pwm_match);
+
+static int rockchip_audio_pwm_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct rk_audio_pwm_dev *apwm;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+	int val;
+
+	apwm = devm_kzalloc(&pdev->dev, sizeof(*apwm), GFP_KERNEL);
+	if (!apwm)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	apwm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					     &rockchip_audio_pwm_config);
+	if (IS_ERR(apwm->regmap))
+		return PTR_ERR(apwm->regmap);
+
+	apwm->playback_dma_data.addr = res->start + AUDPWM_FIFO_ENTRY;
+	apwm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	apwm->playback_dma_data.maxburst = AUDIO_PWM_DMA_BURST_SIZE;
+
+	apwm->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, apwm);
+
+	apwm->clk = devm_clk_get(&pdev->dev, "clk");
+	if (IS_ERR(apwm->clk))
+		return PTR_ERR(apwm->clk);
+
+	apwm->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(apwm->hclk))
+		return PTR_ERR(apwm->hclk);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = rockchip_audio_pwm_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	apwm->sample_width_bits = 8;
+	of_property_read_u32(np, "rockchip,sample-width-bits", &val);
+	if (val >= 8 && val <= 11)
+		apwm->sample_width_bits = val;
+
+	of_property_read_u32(np, "rockchip,interpolat-points",
+			     &apwm->interpolat_points);
+
+	apwm->spk_ctl_gpio = devm_gpiod_get_optional(&pdev->dev, "spk-ctl",
+						     GPIOD_OUT_LOW);
+
+	if (!apwm->spk_ctl_gpio) {
+		dev_info(&pdev->dev, "no need spk-ctl gpio\n");
+	} else if (IS_ERR(apwm->spk_ctl_gpio)) {
+		ret = PTR_ERR(apwm->spk_ctl_gpio);
+		dev_err(&pdev->dev, "fail to request gpio spk-ctl\n");
+		goto err_suspend;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_audio_pwm_component,
+					      &rockchip_audio_pwm_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register dai: %d\n", ret);
+		goto err_suspend;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
+		goto err_suspend;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rockchip_audio_pwm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_audio_pwm_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rockchip_audio_pwm_runtime_suspend(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_audio_pwm_pm_ops = {
+	SET_RUNTIME_PM_OPS(rockchip_audio_pwm_runtime_suspend,
+			   rockchip_audio_pwm_runtime_resume, NULL)
+};
+
+static struct platform_driver rockchip_audio_pwm_driver = {
+	.probe = rockchip_audio_pwm_probe,
+	.remove = rockchip_audio_pwm_remove,
+	.driver = {
+		.name = "rockchip-audio-pwm",
+		.of_match_table = of_match_ptr(rockchip_audio_pwm_match),
+		.pm = &rockchip_audio_pwm_pm_ops,
+	},
+};
+
+module_platform_driver(rockchip_audio_pwm_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip Audio PWM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/rockchip/rockchip_audio_pwm.h b/sound/soc/rockchip/rockchip_audio_pwm.h
new file mode 100644
index 000000000..ad6866043
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_audio_pwm.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip Audio PWM driver
+ *
+ * Copyright (C) 2020 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_AUDIO_PWM_H
+#define _ROCKCHIP_AUDIO_PWM_H
+
+/* AUDIO PWM REGS offset */
+#define AUDPWM_VERSION		(0x0000)
+#define AUDPWM_XFER		(0x0004)
+#define AUDPWM_SRC_CFG		(0x0008)
+#define AUDPWM_PWM_CFG		(0x0010)
+#define AUDPWM_PWM_ST		(0x0014)
+#define AUDPWM_PWM_BUF_01	(0x0018)
+#define AUDPWM_PWM_BUF_23	(0x001c)
+#define AUDPWM_FIFO_CFG		(0x0020)
+#define AUDPWM_FIFO_LVL		(0x0024)
+#define AUDPWM_FIFO_INT_EN	(0x0028)
+#define AUDPWM_FIFO_INT_ST	(0x002c)
+#define AUDPWM_FIFO_ENTRY	(0x0080)
+
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK((h), (l)) << 16))
+
+/* Transfer Control Register */
+#define AUDPWM_XFER_LSTOP	HIWORD_UPDATE(1, 1, 1)
+#define AUDPWM_XFER_START	HIWORD_UPDATE(1, 0, 0)
+#define AUDPWM_XFER_STOP	HIWORD_UPDATE(0, 0, 0)
+
+/* Source Data Configuration Register */
+#define AUDPWM_ALIGN_LEFT	HIWORD_UPDATE(1, 5, 5)
+#define AUDPWM_ALIGN_RIGHT	HIWORD_UPDATE(0, 5, 5)
+#define AUDPWM_SRC_WIDTH(x)	HIWORD_UPDATE((x) - 1, 4, 0)
+
+/* PWM Configuration Register */
+#define AUDPWM_SAMPLE_WIDTH(x)	HIWORD_UPDATE((x) - 8, 9, 8)
+#define AUDPWM_LINEAR_INTERP_EN HIWORD_UPDATE(1, 4, 4)
+#define AUDPWM_INTERP_RATE(x)	HIWORD_UPDATE((x), 3, 0)
+
+/* FIFO Configuration Register */
+#define AUDPWM_DMA_EN		HIWORD_UPDATE(1, 7, 7)
+#define AUDPWM_DMA_DIS		HIWORD_UPDATE(0, 7, 7)
+#define AUDPWM_DMA_WATERMARK(x)	HIWORD_UPDATE((x) - 1, 4, 0)
+
+#endif /* _ROCKCHIP_AUDIO_PWM_H */
diff --git a/sound/soc/rockchip/rockchip_cdndp.c b/sound/soc/rockchip/rockchip_cdndp.c
new file mode 100644
index 000000000..aafeab5b4
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_cdndp.c
@@ -0,0 +1,166 @@
+/*
+ * Rockchip machine ASoC driver for boards using CDN DP
+ *
+ * Copyright (c) 2016, ROCKCHIP CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <sound/jack.h>
+#include <sound/hdmi-codec.h>
+#include <sound/soc.h>
+
+#define DRV_NAME "rockchip-cdndp-sound"
+
+static int rockchip_sound_cdndp_hw_params(struct snd_pcm_substream *substream,
+					  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int mclk, ret;
+
+	/* in bypass mode, the mclk has to be one of the frequencies below */
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 11289600;
+		break;
+	case 176400:
+		mclk = 11289600 * 2;
+		break;
+	case 192000:
+		mclk = 12288000 * 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(cpu_dai->dev, "Can't set cpu clock %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_jack cdn_dp_card_jack;
+
+static int rockchip_sound_cdndp_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_codec *codec = runtime->codec;
+	int ret;
+
+	/* enable jack detection */
+	ret = snd_soc_card_jack_new(card, "DP Jack", SND_JACK_LINEOUT,
+				    &cdn_dp_card_jack, NULL, 0);
+	if (ret) {
+		dev_err(card->dev, "Can't create DP Jack %d\n", ret);
+		return ret;
+	}
+
+	return hdmi_codec_set_jack_detect(codec, &cdn_dp_card_jack);
+}
+
+static struct snd_soc_ops rockchip_sound_cdndp_ops = {
+	.hw_params = rockchip_sound_cdndp_hw_params,
+};
+
+static struct snd_soc_dai_link cdndp_dailink = {
+	.name = "DP",
+	.stream_name = "DP PCM",
+	.codec_dai_name = "spdif-hifi",
+	.init = rockchip_sound_cdndp_init,
+	.ops = &rockchip_sound_cdndp_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		   SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card rockchip_sound_card = {
+	.name = "rockchip-cdndp-sound",
+	.owner = THIS_MODULE,
+	.dai_link = &cdndp_dailink,
+	.num_links = 1,
+};
+
+static int rockchip_sound_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &rockchip_sound_card;
+	struct device_node *cpu_node;
+	int ret;
+
+	cpu_node = of_parse_phandle(pdev->dev.of_node, "rockchip,cpu", 0);
+	if (!cpu_node) {
+		dev_err(&pdev->dev, "Property 'rockchip,cpu' missing or invalid\n");
+		return -EINVAL;
+	}
+
+	cdndp_dailink.platform_of_node = cpu_node;
+	cdndp_dailink.cpu_of_node = cpu_node;
+
+	cdndp_dailink.codec_of_node = of_parse_phandle(pdev->dev.of_node,
+							   "rockchip,codec", 0);
+	if (!cdndp_dailink.codec_of_node) {
+		dev_err(&pdev->dev, "Property 'rockchip,codec' invalid\n");
+		return -EINVAL;
+	}
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret)
+		dev_err(&pdev->dev, "%s snd_soc_register_card fail %d\n",
+			__func__, ret);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_sound_of_match[] = {
+	{ .compatible = "rockchip,cdndp-sound", },
+	{},
+};
+
+static struct platform_driver rockchip_sound_driver = {
+	.probe = rockchip_sound_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = rockchip_sound_of_match,
+#ifdef CONFIG_PM
+		.pm = &snd_soc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(rockchip_sound_driver);
+
+MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip CDN DP Machine Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_sound_of_match);
diff --git a/sound/soc/rockchip/rockchip_da7219.c b/sound/soc/rockchip/rockchip_da7219.c
new file mode 100644
index 000000000..bf675defb
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_da7219.c
@@ -0,0 +1,235 @@
+/*
+ * Rockchip machine ASoC driver for boards using a DA7219 CODEC.
+ *
+ * Copyright (c) 2016, ROCKCHIP CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include "rockchip_i2s.h"
+#include "../codecs/da7219.h"
+#include "../codecs/da7219-aad.h"
+
+#define DRV_NAME "rockchip-snd-da7219"
+
+static struct snd_soc_jack mach_da7219_jack;
+
+static const struct snd_soc_dapm_widget rk_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphones", NULL),
+	SND_SOC_DAPM_SPK("Speakers", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route rk_audio_map[] = {
+	/* Input Lines */
+	{"MIC", NULL, "Headset Mic"},
+
+	/* Output Lines */
+	{"Headphones", NULL, "HPL"},
+	{"Headphones", NULL, "HPR"},
+};
+
+static const struct snd_kcontrol_new rk_mc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphones"),
+	SOC_DAPM_PIN_SWITCH("Speakers"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+};
+
+static int rk_aif1_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int mclk;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+		mclk = 11289600;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set cpu clock out %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set codec clock in %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, DA7219_SYSCLK_MCLK, 0, 0);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set pll sysclk mclk %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rk_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+	int ret = 0;
+
+	card->dapm.idle_bias_off = true;
+
+	snd_soc_dapm_enable_pin(dapm, "Headphones");
+	snd_soc_dapm_enable_pin(dapm, "Speakers");
+	snd_soc_dapm_enable_pin(dapm, "Headset Mic");
+	snd_soc_dapm_enable_pin(dapm, "Int Mic");
+
+	snd_soc_dapm_sync(dapm);
+
+	/* Enable Headset and 4 Buttons Jack detection */
+	ret = snd_soc_card_jack_new(card, "Headset Jack",
+				    SND_JACK_HEADSET |
+				    SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				    SND_JACK_BTN_2 | SND_JACK_BTN_3,
+				    &mach_da7219_jack, NULL, 0);
+
+	if (ret) {
+		dev_err(card->dev, "New Headset Jack failed! (%d)\n", ret);
+		return ret;
+	}
+
+	da7219_aad_jack_det(runtime->codec, &mach_da7219_jack);
+
+	return ret;
+}
+
+static struct snd_soc_ops rk_aif1_ops = {
+	.hw_params = rk_aif1_hw_params,
+};
+
+static struct snd_soc_dai_link rk_dailink = {
+	.name = "da7219",
+	.stream_name = "da7219 PCM",
+	.codec_dai_name = "da7219-hifi",
+	.init = rk_init,
+	.ops = &rk_aif1_ops,
+	/* set da7219 as slave */
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card snd_soc_card_rk = {
+	.name = "audio-da7219",
+	.dai_link = &rk_dailink,
+	.num_links = 1,
+	.dapm_widgets = rk_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(rk_dapm_widgets),
+	.dapm_routes = rk_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(rk_audio_map),
+	.controls = rk_mc_controls,
+	.num_controls = ARRAY_SIZE(rk_mc_controls),
+};
+
+static int snd_rk_mc_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct snd_soc_card *card = &snd_soc_card_rk;
+	struct device_node *np = pdev->dev.of_node;
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+
+	rk_dailink.codec_of_node = of_parse_phandle(np,
+			"rockchip,audio-codec", 0);
+	if (!rk_dailink.codec_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'rockchip,audio-codec' missing or invalid\n");
+		return -EINVAL;
+	}
+
+	rk_dailink.cpu_of_node = of_parse_phandle(np,
+			"rockchip,i2s-controller", 0);
+	if (!rk_dailink.cpu_of_node) {
+		dev_err(&pdev->dev,
+			"Property 'rockchip,i2s-controller' missing or invalid\n");
+		return -EINVAL;
+	}
+
+	rk_dailink.platform_of_node = rk_dailink.cpu_of_node;
+
+	ret = snd_soc_of_parse_card_name(card, "rockchip,model");
+	if (ret) {
+		dev_err(&pdev->dev,
+			"snd_soc_of_parse_card_name failed %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"snd_soc_register_card failed %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_da7219_of_match[] = {
+	{ .compatible = "rockchip,rockchip-audio-da7219", },
+	{},
+};
+
+static struct platform_driver snd_rk_mc_driver = {
+	.probe = snd_rk_mc_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_da7219_of_match,
+	},
+};
+
+module_platform_driver(snd_rk_mc_driver);
+
+MODULE_AUTHOR("Xing Zheng <zhengxing@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip da7219 machine ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_da7219_of_match);
diff --git a/sound/soc/rockchip/rockchip_hdmi.c b/sound/soc/rockchip/rockchip_hdmi.c
new file mode 100644
index 000000000..ed107d4d2
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_hdmi.c
@@ -0,0 +1,279 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Rockchip machine ASoC driver for Rockchip HDMI audio output
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd
+ *
+ * Authors: XiaoTan Luo <lxt@rock-chips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#define DRV_NAME "rk-hdmi-sound"
+#define MAX_CODECS	2
+#define DEFAULT_MCLK_FS	256
+
+struct rk_hdmi_data {
+	struct snd_soc_card	card;
+	struct snd_soc_dai_link	dai;
+	struct snd_soc_jack	hdmi_jack;
+	struct snd_soc_jack_pin	hdmi_jack_pin;
+	unsigned int		mclk_fs;
+	bool			jack_det;
+};
+
+static int rk_hdmi_fill_widget_info(struct device *dev,
+		struct snd_soc_dapm_widget *w, enum snd_soc_dapm_type id,
+		void *priv, const char *wname, const char *stream,
+		struct snd_kcontrol_new *wc, int numkc,
+		int (*event)(struct snd_soc_dapm_widget *,
+		struct snd_kcontrol *, int), unsigned short event_flags)
+{
+	w->id = id;
+	w->name = devm_kstrdup(dev, wname, GFP_KERNEL);
+	if (!w->name)
+		return -ENOMEM;
+
+	w->sname = stream;
+	w->reg = SND_SOC_NOPM;
+	w->shift = 0;
+	w->kcontrol_news = wc;
+	w->num_kcontrols = numkc;
+	w->priv = priv;
+	w->event = event;
+	w->event_flags = event_flags;
+
+	return 0;
+}
+
+static int rk_dailink_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_card *card = rtd->card;
+	struct rk_hdmi_data *rk_data = snd_soc_card_get_drvdata(rtd->card);
+	struct device *dev = rtd->card->dev;
+	int ret = 0;
+	struct snd_soc_dapm_widget *widgets;
+
+	if (!rk_data->jack_det)
+		return 0;
+
+	widgets = devm_kcalloc(card->dapm.dev, 1,
+			       sizeof(*widgets), GFP_KERNEL);
+	if (!widgets)
+		return -ENOMEM;
+
+	ret = rk_hdmi_fill_widget_info(card->dapm.dev, widgets,
+				       snd_soc_dapm_line, NULL,
+				       rk_data->hdmi_jack_pin.pin,
+				       NULL, NULL, 0, NULL, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dapm_new_controls(&card->dapm, widgets, 1);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dapm_new_widgets(rtd->card);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_card_jack_new(rtd->card,
+				    rk_data->hdmi_jack_pin.pin,
+				    rk_data->hdmi_jack_pin.mask,
+				    &rk_data->hdmi_jack,
+				    &rk_data->hdmi_jack_pin, 1);
+	if (ret) {
+		dev_err(dev, "Can't new HDMI Jack %d\n", ret);
+		return ret;
+	}
+	return snd_soc_component_set_jack(codec_dai->component,
+					  &rk_data->hdmi_jack, NULL);
+
+}
+
+static int rk_hdmi_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct rk_hdmi_data *rk_data = snd_soc_card_get_drvdata(rtd->card);
+	unsigned int mclk;
+	int ret;
+
+	mclk = params_rate(params) * rk_data->mclk_fs;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(codec_dai->dev,
+			"Set codec_dai sysclk failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(cpu_dai->dev,
+			"Set cpu_dai sysclk failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+
+}
+
+static const struct snd_soc_ops rk_ops = {
+	.hw_params = rk_hdmi_hw_params,
+};
+
+static int rk_hdmi_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link_component *codecs;
+	struct snd_soc_dai_link_component *platforms;
+	struct snd_soc_dai_link_component *cpus;
+	struct of_phandle_args args;
+	struct device_node *codec_np, *cpu_np;
+	struct rk_hdmi_data *rk_data;
+	int count;
+	u32 val;
+	int ret = 0, i = 0, idx = 0;
+
+	rk_data = devm_kzalloc(&pdev->dev, sizeof(*rk_data), GFP_KERNEL);
+	if (!rk_data)
+		return -ENOMEM;
+
+	cpus = devm_kzalloc(&pdev->dev, sizeof(*cpus), GFP_KERNEL);
+	if (!cpus)
+		return -ENOMEM;
+
+	platforms = devm_kzalloc(&pdev->dev, sizeof(*platforms), GFP_KERNEL);
+	if (!platforms)
+		return -ENOMEM;
+
+	rk_data->card.dev = &pdev->dev;
+	rk_data->dai.init = &rk_dailink_init;
+	rk_data->dai.ops = &rk_ops;
+	rk_data->dai.cpus = cpus;
+	rk_data->dai.platforms = platforms;
+	rk_data->dai.num_cpus = 1;
+	rk_data->dai.num_platforms = 1;
+	rk_data->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			       SND_SOC_DAIFMT_CBS_CFS;
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(&rk_data->card, "rockchip,card-name");
+	if (ret < 0)
+		return ret;
+	rk_data->dai.name = rk_data->card.name;
+	rk_data->dai.stream_name = rk_data->card.name;
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		codec_np = of_parse_phandle(np, "rockchip,codec", i);
+		if (!codec_np)
+			return -ENODEV;
+		if (of_device_is_available(codec_np))
+			idx++;
+		of_node_put(codec_np);
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	rk_data->dai.codecs = codecs;
+	rk_data->dai.num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		codec_np = of_parse_phandle(np, "rockchip,codec", i);
+		if (!codec_np)
+			return -ENODEV;
+		if (!of_device_is_available(codec_np))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret) {
+			of_node_put(codec_np);
+			return ret;
+		}
+
+		codecs[idx].of_node = codec_np;
+		of_node_put(codec_np);
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	cpu_np = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!cpu_np)
+		return -ENODEV;
+
+	rk_data->mclk_fs = DEFAULT_MCLK_FS;
+	if (!of_property_read_u32(np, "rockchip,mclk-fs", &val))
+		rk_data->mclk_fs = val;
+
+	rk_data->jack_det =
+		of_property_read_bool(np, "rockchip,jack-det");
+
+	rk_data->dai.cpus->of_node = cpu_np;
+	rk_data->dai.platforms->of_node = cpu_np;
+	of_node_put(cpu_np);
+
+	rk_data->hdmi_jack_pin.pin = rk_data->card.name;
+	rk_data->hdmi_jack_pin.mask = SND_JACK_LINEOUT;
+	rk_data->card.num_links = 1;
+	rk_data->card.owner = THIS_MODULE;
+	rk_data->card.dai_link = &rk_data->dai;
+
+	snd_soc_card_set_drvdata(&rk_data->card, rk_data);
+	ret = devm_snd_soc_register_card(&pdev->dev, &rk_data->card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+	platform_set_drvdata(pdev, &rk_data->card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_sound_of_match[] = {
+	{ .compatible = "rockchip,hdmi", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_sound_of_match);
+
+static struct platform_driver rockchip_sound_driver = {
+	.probe = rk_hdmi_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_sound_of_match,
+	},
+};
+
+module_platform_driver(rockchip_sound_driver);
+
+MODULE_AUTHOR("XiaoTan Luo <lxt@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip HDMI ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/rockchip/rockchip_hdmi_analog.c b/sound/soc/rockchip/rockchip_hdmi_analog.c
new file mode 100644
index 000000000..02a282e8f
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_hdmi_analog.c
@@ -0,0 +1,222 @@
+/*
+ * Rockchip machine ASoC driver for Rockchip built-in HDMI and external codec IC
+ * which use the same i2s interface
+ *
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Authors: Zhangjun <showy.zhang@rock-chips.com>,
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "rockchip_i2s.h"
+
+#define DRV_NAME "rk-hdmi-analog-sound"
+#define MAX_CODECS	2
+
+static int rk_hdmi_analog_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai **codec_dais = rtd->codec_dais;
+	int mclk;
+	unsigned int i;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 11289600;
+		break;
+	case 176400:
+		mclk = 11289600 * 2;
+		break;
+	case 192000:
+		mclk = 12288000 * 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,
+				     SND_SOC_CLOCK_OUT);
+
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(cpu_dai->dev, "Can't set cpu clock %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = codec_dais[i];
+
+		ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,
+					     SND_SOC_CLOCK_IN);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(codec_dai->dev,
+				"Can't set codec clock %d\n", ret);
+			return ret;
+		}
+
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops rk_ops = {
+	.hw_params = rk_hdmi_analog_hw_params,
+};
+
+static struct snd_soc_dai_link rk_dailink = {
+	.name = "HDMI-ANALOG",
+	.stream_name = "HDMI-ANALOG",
+	.ops = &rk_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card snd_soc_card_rk = {
+	.name = "rk-hdmi-analog-snd",
+	.dai_link = &rk_dailink,
+	.num_links = 1,
+	.num_aux_devs = 0,
+};
+
+static int rk_hdmi_analog_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_card_rk;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *link = card->dai_link;
+	struct snd_soc_dai_link_component *codecs;
+	struct of_phandle_args args;
+	struct device_node *node;
+	int count;
+	int ret = 0, i = 0, idx = 0;
+
+	snd_soc_of_parse_card_name(card, "rockchip,model");
+
+	card->dev = &pdev->dev;
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (of_device_is_available(node))
+			idx++;
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	link->codecs = codecs;
+	link->num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (!of_device_is_available(node))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret)
+			return ret;
+
+		codecs[idx].of_node = node;
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	link->cpu_of_node = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!link->cpu_of_node)
+		return -ENODEV;
+
+	link->platform_of_node = link->cpu_of_node;
+
+	ret = snd_soc_of_parse_audio_simple_widgets(card, "rockchip,widgets");
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Unable to parse 'rockchip,widget' property\n");
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "rockchip,routing");
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Unable to parse 'rockchip,routing' property\n");
+	}
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_sound_of_match[] = {
+	{ .compatible = "rockchip,rk3368-hdmi-analog", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_sound_of_match);
+
+static struct platform_driver rockchip_sound_driver = {
+	.probe = rk_hdmi_analog_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_sound_of_match,
+	},
+};
+
+module_platform_driver(rockchip_sound_driver);
+
+MODULE_AUTHOR("Zhangjun <showy.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip Built-in HDMI and Codec IC machine ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/rockchip/rockchip_hdmi_dp.c b/sound/soc/rockchip/rockchip_hdmi_dp.c
new file mode 100644
index 000000000..4db9fb7b7
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_hdmi_dp.c
@@ -0,0 +1,193 @@
+/*
+ * Rockchip machine ASoC driver for Rockchip built-in HDMI and DP audio output
+ *
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Authors: Sugar Zhang <sugar.zhang@rock-chips.com>,
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "rockchip_i2s.h"
+
+#define DRV_NAME "rk-hdmi-dp-sound"
+#define MAX_CODECS	2
+
+static int rk_hdmi_dp_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int mclk;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 11289600;
+		break;
+	case 176400:
+		mclk = 11289600 * 2;
+		break;
+	case 192000:
+		mclk = 12288000 * 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk,
+				     SND_SOC_CLOCK_OUT);
+
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(cpu_dai->dev, "Can't set cpu clock %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops rk_ops = {
+	.hw_params = rk_hdmi_dp_hw_params,
+};
+
+static struct snd_soc_dai_link rk_dailink = {
+	.name = "HDMI-DP",
+	.stream_name = "HDMI-DP",
+	.ops = &rk_ops,
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card snd_soc_card_rk = {
+	.name = "rk-hdmi-dp-sound",
+	.dai_link = &rk_dailink,
+	.num_links = 1,
+	.num_aux_devs = 0,
+};
+
+static int rk_hdmi_dp_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_card_rk;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *link = card->dai_link;
+	struct snd_soc_dai_link_component *codecs;
+	struct of_phandle_args args;
+	struct device_node *node;
+	int count;
+	int ret = 0, i = 0, idx = 0;
+
+	card->dev = &pdev->dev;
+
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (of_device_is_available(node))
+			idx++;
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	link->codecs = codecs;
+	link->num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (!of_device_is_available(node))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret)
+			return ret;
+
+		codecs[idx].of_node = node;
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	link->cpu_of_node = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!link->cpu_of_node)
+		return -ENODEV;
+
+	link->platform_of_node = link->cpu_of_node;
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_sound_of_match[] = {
+	{ .compatible = "rockchip,rk3399-hdmi-dp", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_sound_of_match);
+
+static struct platform_driver rockchip_sound_driver = {
+	.probe = rk_hdmi_dp_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_sound_of_match,
+	},
+};
+
+module_platform_driver(rockchip_sound_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip Built-in HDMI and DP machine ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/rockchip/rockchip_i2s.c b/sound/soc/rockchip/rockchip_i2s.c
index fa84ec695..b31431327 100644
--- a/sound/soc/rockchip/rockchip_i2s.c
+++ b/sound/soc/rockchip/rockchip_i2s.c
@@ -15,11 +15,11 @@
 #include <linux/clk.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/spinlock.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
 
 #include "rockchip_i2s.h"
-#include "rockchip_pcm.h"
 
 #define DRV_NAME "rockchip-i2s"
 
@@ -40,6 +40,9 @@ struct rk_i2s_dev {
 	struct regmap *regmap;
 	struct regmap *grf;
 
+	bool has_capture;
+	bool has_playback;
+
 /*
  * Used to indicate the tx/rx status.
  * I2S controller hopes to start the tx and rx together,
@@ -49,6 +52,8 @@ struct rk_i2s_dev {
 	bool rx_start;
 	bool is_master_mode;
 	const struct rk_i2s_pins *pins;
+	unsigned int bclk_ratio;
+	spinlock_t lock; /* tx/rx lock */
 };
 
 static int i2s_runtime_suspend(struct device *dev)
@@ -92,6 +97,7 @@ static void rockchip_snd_txctrl(struct rk_i2s_dev *i2s, int on)
 	unsigned int val = 0;
 	int retry = 10;
 
+	spin_lock(&i2s->lock);
 	if (on) {
 		regmap_update_bits(i2s->regmap, I2S_DMACR,
 				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);
@@ -132,6 +138,7 @@ static void rockchip_snd_txctrl(struct rk_i2s_dev *i2s, int on)
 			}
 		}
 	}
+	spin_unlock(&i2s->lock);
 }
 
 static void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)
@@ -139,6 +146,7 @@ static void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)
 	unsigned int val = 0;
 	int retry = 10;
 
+	spin_lock(&i2s->lock);
 	if (on) {
 		regmap_update_bits(i2s->regmap, I2S_DMACR,
 				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);
@@ -179,6 +187,7 @@ static void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)
 			}
 		}
 	}
+	spin_unlock(&i2s->lock);
 }
 
 static int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
@@ -207,13 +216,27 @@ static int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
 
 	regmap_update_bits(i2s->regmap, I2S_CKR, mask, val);
 
-	mask = I2S_CKR_CKP_MASK;
+	mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_NF:
-		val = I2S_CKR_CKP_NEG;
+		val = I2S_CKR_CKP_NORMAL |
+		      I2S_CKR_TLP_NORMAL |
+		      I2S_CKR_RLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		val = I2S_CKR_CKP_NORMAL |
+		      I2S_CKR_TLP_INVERTED |
+		      I2S_CKR_RLP_INVERTED;
 		break;
 	case SND_SOC_DAIFMT_IB_NF:
-		val = I2S_CKR_CKP_POS;
+		val = I2S_CKR_CKP_INVERTED |
+		      I2S_CKR_TLP_NORMAL |
+		      I2S_CKR_RLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		val = I2S_CKR_CKP_INVERTED |
+		      I2S_CKR_TLP_INVERTED |
+		      I2S_CKR_RLP_INVERTED;
 		break;
 	default:
 		ret = -EINVAL;
@@ -287,11 +310,11 @@ static int rockchip_i2s_hw_params(struct snd_pcm_substream *substream,
 
 	if (i2s->is_master_mode) {
 		mclk_rate = clk_get_rate(i2s->mclk);
-		bclk_rate = 2 * 32 * params_rate(params);
-		if (bclk_rate == 0 || mclk_rate % bclk_rate)
+		bclk_rate = i2s->bclk_ratio * params_rate(params);
+		if (!bclk_rate)
 			return -EINVAL;
 
-		div_bclk = mclk_rate / bclk_rate;
+		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
 		div_lrck = bclk_rate / params_rate(params);
 		regmap_update_bits(i2s->regmap, I2S_CKR,
 				   I2S_CKR_MDIV_MASK,
@@ -422,6 +445,16 @@ static int rockchip_i2s_trigger(struct snd_pcm_substream *substream,
 	return ret;
 }
 
+static int rockchip_i2s_set_bclk_ratio(struct snd_soc_dai *dai,
+				       unsigned int ratio)
+{
+	struct rk_i2s_dev *i2s = to_info(dai);
+
+	i2s->bclk_ratio = ratio;
+
+	return 0;
+}
+
 static int rockchip_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
 				   unsigned int freq, int dir)
 {
@@ -442,14 +475,16 @@ static int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)
 {
 	struct rk_i2s_dev *i2s = snd_soc_dai_get_drvdata(dai);
 
-	dai->capture_dma_data = &i2s->capture_dma_data;
-	dai->playback_dma_data = &i2s->playback_dma_data;
+	snd_soc_dai_init_dma_data(dai,
+		i2s->has_playback ? &i2s->playback_dma_data : NULL,
+		i2s->has_capture  ? &i2s->capture_dma_data  : NULL);
 
 	return 0;
 }
 
 static const struct snd_soc_dai_ops rockchip_i2s_dai_ops = {
 	.hw_params = rockchip_i2s_hw_params,
+	.set_bclk_ratio	= rockchip_i2s_set_bclk_ratio,
 	.set_sysclk = rockchip_i2s_set_sysclk,
 	.set_fmt = rockchip_i2s_set_fmt,
 	.trigger = rockchip_i2s_trigger,
@@ -457,28 +492,6 @@ static const struct snd_soc_dai_ops rockchip_i2s_dai_ops = {
 
 static struct snd_soc_dai_driver rockchip_i2s_dai = {
 	.probe = rockchip_i2s_dai_probe,
-	.playback = {
-		.stream_name = "Playback",
-		.channels_min = 2,
-		.channels_max = 8,
-		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = (SNDRV_PCM_FMTBIT_S8 |
-			    SNDRV_PCM_FMTBIT_S16_LE |
-			    SNDRV_PCM_FMTBIT_S20_3LE |
-			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
-	},
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 2,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_8000_192000,
-		.formats = (SNDRV_PCM_FMTBIT_S8 |
-			    SNDRV_PCM_FMTBIT_S16_LE |
-			    SNDRV_PCM_FMTBIT_S20_3LE |
-			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
-	},
 	.ops = &rockchip_i2s_dai_ops,
 	.symmetric_rates = 1,
 };
@@ -575,29 +588,108 @@ static const struct rk_i2s_pins rk3399_i2s_pins = {
 	.shift = 11,
 };
 
-static const struct of_device_id rockchip_i2s_match[] = {
+static const struct of_device_id rockchip_i2s_match[] __maybe_unused = {
+	{ .compatible = "rockchip,px30-i2s", },
+	{ .compatible = "rockchip,rk1808-i2s", },
+	{ .compatible = "rockchip,rk3036-i2s", },
 	{ .compatible = "rockchip,rk3066-i2s", },
+	{ .compatible = "rockchip,rk3128-i2s", },
 	{ .compatible = "rockchip,rk3188-i2s", },
+	{ .compatible = "rockchip,rk3228-i2s", },
 	{ .compatible = "rockchip,rk3288-i2s", },
+	{ .compatible = "rockchip,rk3308-i2s", },
+	{ .compatible = "rockchip,rk3328-i2s", },
+	{ .compatible = "rockchip,rk3366-i2s", },
+	{ .compatible = "rockchip,rk3368-i2s", },
 	{ .compatible = "rockchip,rk3399-i2s", .data = &rk3399_i2s_pins },
+	{ .compatible = "rockchip,rv1126-i2s", },
 	{},
 };
 
+static int rockchip_i2s_init_dai(struct rk_i2s_dev *i2s, struct resource *res,
+				 struct snd_soc_dai_driver **dp)
+{
+	struct device_node *node = i2s->dev->of_node;
+	struct snd_soc_dai_driver *dai;
+	struct property *dma_names;
+	const char *dma_name;
+	unsigned int val;
+
+	of_property_for_each_string(node, "dma-names", dma_names, dma_name) {
+		if (!strcmp(dma_name, "tx"))
+			i2s->has_playback = true;
+		if (!strcmp(dma_name, "rx"))
+			i2s->has_capture = true;
+	}
+
+	dai = devm_kmemdup(i2s->dev, &rockchip_i2s_dai,
+			   sizeof(*dai), GFP_KERNEL);
+	if (!dai)
+		return -ENOMEM;
+
+	if (i2s->has_playback) {
+		dai->playback.stream_name = "Playback";
+		dai->playback.channels_min = 2;
+		dai->playback.channels_max = 8;
+		dai->playback.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->playback.formats = SNDRV_PCM_FMTBIT_S8 |
+					SNDRV_PCM_FMTBIT_S16_LE |
+					SNDRV_PCM_FMTBIT_S20_3LE |
+					SNDRV_PCM_FMTBIT_S24_LE |
+					SNDRV_PCM_FMTBIT_S32_LE;
+
+		i2s->playback_dma_data.addr = res->start + I2S_TXDR;
+		i2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		i2s->playback_dma_data.maxburst = 8;
+
+		if (!of_property_read_u32(node, "rockchip,playback-channels", &val)) {
+			if (val >= 2 && val <= 8)
+				dai->playback.channels_max = val;
+		}
+	}
+
+	if (i2s->has_capture) {
+		dai->capture.stream_name = "Capture";
+		dai->capture.channels_min = 2;
+		dai->capture.channels_max = 8;
+		dai->capture.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->capture.formats = SNDRV_PCM_FMTBIT_S8 |
+				       SNDRV_PCM_FMTBIT_S16_LE |
+				       SNDRV_PCM_FMTBIT_S20_3LE |
+				       SNDRV_PCM_FMTBIT_S24_LE |
+				       SNDRV_PCM_FMTBIT_S32_LE;
+
+		i2s->capture_dma_data.addr = res->start + I2S_RXDR;
+		i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		i2s->capture_dma_data.maxburst = 8;
+
+		if (!of_property_read_u32(node, "rockchip,capture-channels", &val)) {
+			if (val >= 2 && val <= 8)
+				dai->capture.channels_max = val;
+		}
+	}
+
+	if (dp)
+		*dp = dai;
+
+	return 0;
+}
+
 static int rockchip_i2s_probe(struct platform_device *pdev)
 {
 	struct device_node *node = pdev->dev.of_node;
 	const struct of_device_id *of_id;
 	struct rk_i2s_dev *i2s;
-	struct snd_soc_dai_driver *soc_dai;
+	struct snd_soc_dai_driver *dai;
 	struct resource *res;
 	void __iomem *regs;
 	int ret;
-	int val;
 
 	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
 	if (!i2s)
 		return -ENOMEM;
 
+	spin_lock_init(&i2s->lock);
 	i2s->dev = &pdev->dev;
 
 	i2s->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
@@ -609,26 +701,7 @@ static int rockchip_i2s_probe(struct platform_device *pdev)
 		i2s->pins = of_id->data;
 	}
 
-	/* try to prepare related clocks */
-	i2s->hclk = devm_clk_get(&pdev->dev, "i2s_hclk");
-	if (IS_ERR(i2s->hclk)) {
-		dev_err(&pdev->dev, "Can't retrieve i2s bus clock\n");
-		return PTR_ERR(i2s->hclk);
-	}
-	ret = clk_prepare_enable(i2s->hclk);
-	if (ret) {
-		dev_err(i2s->dev, "hclock enable failed %d\n", ret);
-		return ret;
-	}
-
-	i2s->mclk = devm_clk_get(&pdev->dev, "i2s_clk");
-	if (IS_ERR(i2s->mclk)) {
-		dev_err(&pdev->dev, "Can't retrieve i2s master clock\n");
-		return PTR_ERR(i2s->mclk);
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
+	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs))
 		return PTR_ERR(regs);
 
@@ -640,16 +713,28 @@ static int rockchip_i2s_probe(struct platform_device *pdev)
 		return PTR_ERR(i2s->regmap);
 	}
 
-	i2s->playback_dma_data.addr = res->start + I2S_TXDR;
-	i2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s->playback_dma_data.maxburst = 4;
-
-	i2s->capture_dma_data.addr = res->start + I2S_RXDR;
-	i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s->capture_dma_data.maxburst = 4;
+	i2s->bclk_ratio = 64;
 
 	dev_set_drvdata(&pdev->dev, i2s);
 
+	i2s->mclk = devm_clk_get(&pdev->dev, "i2s_clk");
+	if (IS_ERR(i2s->mclk)) {
+		dev_err(&pdev->dev, "Can't retrieve i2s master clock\n");
+		return PTR_ERR(i2s->mclk);
+	}
+
+	/* try to prepare related clocks */
+	i2s->hclk = devm_clk_get(&pdev->dev, "i2s_hclk");
+	if (IS_ERR(i2s->hclk)) {
+		dev_err(&pdev->dev, "Can't retrieve i2s bus clock\n");
+		return PTR_ERR(i2s->hclk);
+	}
+	ret = clk_prepare_enable(i2s->hclk);
+	if (ret) {
+		dev_err(i2s->dev, "hclock enable failed %d\n", ret);
+		return ret;
+	}
+
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = i2s_runtime_resume(&pdev->dev);
@@ -657,33 +742,20 @@ static int rockchip_i2s_probe(struct platform_device *pdev)
 			goto err_pm_disable;
 	}
 
-	soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_dai,
-			       sizeof(*soc_dai), GFP_KERNEL);
-	if (!soc_dai) {
-		ret = -ENOMEM;
+	ret = rockchip_i2s_init_dai(i2s, res, &dai);
+	if (ret)
 		goto err_pm_disable;
-	}
-
-	if (!of_property_read_u32(node, "rockchip,playback-channels", &val)) {
-		if (val >= 2 && val <= 8)
-			soc_dai->playback.channels_max = val;
-	}
-
-	if (!of_property_read_u32(node, "rockchip,capture-channels", &val)) {
-		if (val >= 2 && val <= 8)
-			soc_dai->capture.channels_max = val;
-	}
 
 	ret = devm_snd_soc_register_component(&pdev->dev,
 					      &rockchip_i2s_component,
-					      soc_dai, 1);
+					      dai, 1);
 
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI\n");
 		goto err_suspend;
 	}
 
-	ret = rockchip_pcm_platform_register(&pdev->dev);
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM\n");
 		goto err_suspend;
@@ -697,6 +769,8 @@ static int rockchip_i2s_probe(struct platform_device *pdev)
 err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
 
+	clk_disable_unprepare(i2s->hclk);
+
 	return ret;
 }
 
diff --git a/sound/soc/rockchip/rockchip_i2s.h b/sound/soc/rockchip/rockchip_i2s.h
index fcaae24e4..251851bf4 100644
--- a/sound/soc/rockchip/rockchip_i2s.h
+++ b/sound/soc/rockchip/rockchip_i2s.h
@@ -88,15 +88,17 @@
 #define I2S_CKR_MSS_SLAVE	(1 << I2S_CKR_MSS_SHIFT)
 #define I2S_CKR_MSS_MASK	(1 << I2S_CKR_MSS_SHIFT)
 #define I2S_CKR_CKP_SHIFT	26
-#define I2S_CKR_CKP_NEG		(0 << I2S_CKR_CKP_SHIFT)
-#define I2S_CKR_CKP_POS		(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_NORMAL	(0 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_INVERTED	(1 << I2S_CKR_CKP_SHIFT)
 #define I2S_CKR_CKP_MASK	(1 << I2S_CKR_CKP_SHIFT)
 #define I2S_CKR_RLP_SHIFT	25
 #define I2S_CKR_RLP_NORMAL	(0 << I2S_CKR_RLP_SHIFT)
-#define I2S_CKR_RLP_OPPSITE	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_INVERTED	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_MASK	(1 << I2S_CKR_RLP_SHIFT)
 #define I2S_CKR_TLP_SHIFT	24
 #define I2S_CKR_TLP_NORMAL	(0 << I2S_CKR_TLP_SHIFT)
-#define I2S_CKR_TLP_OPPSITE	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_INVERTED	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_MASK	(1 << I2S_CKR_TLP_SHIFT)
 #define I2S_CKR_MDIV_SHIFT	16
 #define I2S_CKR_MDIV(x)		((x - 1) << I2S_CKR_MDIV_SHIFT)
 #define I2S_CKR_MDIV_MASK	(0xff << I2S_CKR_MDIV_SHIFT)
diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.c b/sound/soc/rockchip/rockchip_i2s_tdm.c
new file mode 100644
index 000000000..81865dcdb
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.c
@@ -0,0 +1,1952 @@
+/* sound/soc/rockchip/rockchip_i2s_tdm.c
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk/rockchip.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "rockchip_i2s_tdm.h"
+
+#define DRV_NAME "rockchip-i2s-tdm"
+
+#define DEFAULT_MCLK_FS				256
+#define CH_GRP_MAX				4  /* The max channel 8 / 2 */
+#define MULTIPLEX_CH_MAX			10
+#define CLK_PPM_MIN				(-1000)
+#define CLK_PPM_MAX				(1000)
+
+struct txrx_config {
+	u32 addr;
+	u32 reg;
+	u32 txonly;
+	u32 rxonly;
+};
+
+struct rk_i2s_soc_data {
+	u32 softrst_offset;
+	u32 grf_reg_offset;
+	u32 grf_shift;
+	int config_count;
+	const struct txrx_config *configs;
+	int (*init)(struct device *dev, u32 addr);
+};
+
+struct rk_i2s_tdm_dev {
+	struct device *dev;
+	struct clk *hclk;
+	struct clk *mclk_tx;
+	struct clk *mclk_rx;
+	/* The mclk_tx_src is parent of mclk_tx */
+	struct clk *mclk_tx_src;
+	/* The mclk_rx_src is parent of mclk_rx */
+	struct clk *mclk_rx_src;
+	/*
+	 * The mclk_root0 and mclk_root1 are root parent and supplies for
+	 * the different FS.
+	 *
+	 * e.g:
+	 * mclk_root0 is VPLL0, used for FS=48000Hz
+	 * mclk_root0 is VPLL1, used for FS=44100Hz
+	 */
+	struct clk *mclk_root0;
+	struct clk *mclk_root1;
+	struct regmap *regmap;
+	struct regmap *grf;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct reset_control *tx_reset;
+	struct reset_control *rx_reset;
+	const struct rk_i2s_soc_data *soc_data;
+	void __iomem *cru_base;
+	bool is_master_mode;
+	bool io_multiplex;
+	bool mclk_calibrate;
+	bool tdm_mode;
+	bool tdm_fsync_half_frame;
+	unsigned int mclk_rx_freq;
+	unsigned int mclk_tx_freq;
+	unsigned int mclk_root0_freq;
+	unsigned int mclk_root1_freq;
+	unsigned int mclk_root0_initial_freq;
+	unsigned int mclk_root1_initial_freq;
+	unsigned int bclk_fs;
+	unsigned int clk_trcm;
+	unsigned int i2s_sdis[CH_GRP_MAX];
+	unsigned int i2s_sdos[CH_GRP_MAX];
+	int clk_ppm;
+	int tx_reset_id;
+	int rx_reset_id;
+	atomic_t refcount;
+	spinlock_t lock; /* xfer lock */
+};
+
+static int to_ch_num(unsigned int val)
+{
+	int chs;
+
+	switch (val) {
+	case I2S_CHN_4:
+		chs = 4;
+		break;
+	case I2S_CHN_6:
+		chs = 6;
+		break;
+	case I2S_CHN_8:
+		chs = 8;
+		break;
+	default:
+		chs = 2;
+		break;
+	}
+
+	return chs;
+}
+
+static int i2s_tdm_runtime_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_cache_only(i2s_tdm->regmap, true);
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_disable_unprepare(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_disable_unprepare(i2s_tdm->mclk_rx);
+
+	return 0;
+}
+
+static int i2s_tdm_runtime_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+
+	regcache_cache_only(i2s_tdm->regmap, false);
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	ret = regcache_sync(i2s_tdm->regmap);
+	if (ret) {
+		if (!IS_ERR(i2s_tdm->mclk_tx))
+			clk_disable_unprepare(i2s_tdm->mclk_tx);
+		if (!IS_ERR(i2s_tdm->mclk_rx))
+			clk_disable_unprepare(i2s_tdm->mclk_rx);
+	}
+
+	return ret;
+}
+
+static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+#if defined(CONFIG_ARM) && !defined(writeq)
+static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
+{
+	asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
+}
+#define writeq(v,c) ({ __iowmb(); __raw_writeq((__force u64) cpu_to_le64(v), c); })
+#endif
+
+static void rockchip_snd_xfer_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm,
+					   int tx_bank, int tx_offset,
+					   int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel(BIT(tx_offset) | BIT(rx_offset) |
+		       (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((uintptr_t)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+	/* delay for reset assert done */
+	udelay(10);
+}
+
+static void rockchip_snd_xfer_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm,
+					     int tx_bank, int tx_offset,
+					     int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((uintptr_t)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel((BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel((BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+	/* delay for reset deassert done */
+	udelay(10);
+}
+
+/*
+ * make sure both tx and rx are reset at the same time for sync lrck
+ * when clk_trcm > 0
+ */
+static void rockchip_snd_xfer_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int tx_id, rx_id;
+	int tx_bank, rx_bank, tx_offset, rx_offset;
+
+	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data)
+		return;
+
+	tx_id = i2s_tdm->tx_reset_id;
+	rx_id = i2s_tdm->rx_reset_id;
+	if (tx_id < 0 || rx_id < 0)
+		return;
+
+	tx_bank = tx_id / 16;
+	tx_offset = tx_id % 16;
+	rx_bank = rx_id / 16;
+	rx_offset = rx_id % 16;
+	dev_dbg(i2s_tdm->dev,
+		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+		tx_bank, rx_bank, tx_offset, rx_offset);
+
+	rockchip_snd_xfer_reset_assert(i2s_tdm, tx_bank, tx_offset,
+				       rx_bank, rx_offset);
+	rockchip_snd_xfer_reset_deassert(i2s_tdm, tx_bank, tx_offset,
+					 rx_bank, rx_offset);
+}
+
+/* only used when clk_trcm > 0 */
+static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai, int on)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	unsigned int val = 0;
+	unsigned long flags;
+	int retry = 10;
+
+	spin_lock_irqsave(&i2s_tdm->lock, flags);
+	if (on) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_ENABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_ENABLE);
+
+		if (atomic_inc_return(&i2s_tdm->refcount) == 1) {
+			rockchip_snd_xfer_sync_reset(i2s_tdm);
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_DISABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_DISABLE);
+
+		if (atomic_dec_and_test(&i2s_tdm->refcount)) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_STOP |
+					   I2S_XFER_RXS_STOP);
+
+			udelay(150);
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+					   I2S_CLR_TXC | I2S_CLR_RXC,
+					   I2S_CLR_TXC | I2S_CLR_RXC);
+
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+			/* Should wait for clear operation to finish */
+			while (val) {
+				regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+				retry--;
+				if (!retry) {
+					dev_info(i2s_tdm->dev, "reset txrx\n");
+					rockchip_snd_xfer_sync_reset(i2s_tdm);
+					break;
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+}
+
+static void rockchip_snd_reset(struct reset_control *rc)
+{
+	if (IS_ERR(rc))
+		return;
+
+	reset_control_assert(rc);
+	/* delay for reset assert done */
+	udelay(10);
+	reset_control_deassert(rc);
+	/* delay for reset deassert done */
+	udelay(10);
+}
+
+static void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_TXC,
+				   I2S_CLR_TXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "reset tx\n");
+				rockchip_snd_reset(i2s_tdm->tx_reset);
+				break;
+			}
+		}
+	}
+}
+
+static void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_RXC,
+				   I2S_CLR_RXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "reset rx\n");
+				rockchip_snd_reset(i2s_tdm->rx_reset);
+				break;
+			}
+		}
+	}
+}
+
+static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
+				    unsigned int fmt)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+	unsigned int mask = 0, val = 0, tdm_val = 0;
+	int ret = 0;
+	bool is_tdm = i2s_tdm->tdm_mode;
+
+	pm_runtime_get_sync(cpu_dai->dev);
+	mask = I2S_CKR_MSS_MASK;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		val = I2S_CKR_MSS_MASTER;
+		i2s_tdm->is_master_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		val = I2S_CKR_MSS_SLAVE;
+		i2s_tdm->is_master_mode = false;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		val = I2S_CKR_CKP_NORMAL |
+		      I2S_CKR_TLP_NORMAL |
+		      I2S_CKR_RLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		val = I2S_CKR_CKP_NORMAL |
+		      I2S_CKR_TLP_INVERTED |
+		      I2S_CKR_RLP_INVERTED;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		val = I2S_CKR_CKP_INVERTED |
+		      I2S_CKR_TLP_NORMAL |
+		      I2S_CKR_RLP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		val = I2S_CKR_CKP_INVERTED |
+		      I2S_CKR_TLP_INVERTED |
+		      I2S_CKR_RLP_INVERTED;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_TXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_TXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_TXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_TXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_RXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_RXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_RXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_RXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+	if (is_tdm) {
+		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_RIGHT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(1);
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_pm_put;
+		}
+
+		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+		if (i2s_tdm->tdm_fsync_half_frame)
+			tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
+		else
+			tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+		mask = I2S_TXCR_TFS_MASK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+		       TDM_SHIFT_CTRL_MSK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+				   mask, tdm_val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+				   mask, tdm_val);
+
+		if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+			/* refine frame width for TDM_I2S_ONE_FRAME */
+			mask = TDM_FRAME_WIDTH_MSK;
+			tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
+			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+					   mask, tdm_val);
+			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+					   mask, tdm_val);
+		}
+	}
+
+err_pm_put:
+	pm_runtime_put(cpu_dai->dev);
+
+	return ret;
+}
+
+static void rockchip_i2s_tdm_xfer_pause(struct snd_pcm_substream *substream,
+					struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+	unsigned int val = 0;
+	int retry = 10;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_DISABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_DISABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_STOP |
+			   I2S_XFER_RXS_STOP);
+
+	udelay(150);
+	regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+			   I2S_CLR_TXC | I2S_CLR_RXC,
+			   I2S_CLR_TXC | I2S_CLR_RXC);
+
+	regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+	/* Should wait for clear operation to finish */
+	while (val) {
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+		retry--;
+		if (!retry) {
+			dev_info(i2s_tdm->dev, "reset txrx\n");
+			rockchip_snd_xfer_sync_reset(i2s_tdm);
+			break;
+		}
+	}
+}
+
+static void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,
+					 struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_ENABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_ENABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START);
+}
+
+static int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,
+					 struct clk *clk, unsigned long rate,
+					 int ppm)
+{
+	unsigned long rate_target;
+	int delta, ret;
+
+	if (ppm == i2s_tdm->clk_ppm)
+		return 0;
+
+	ret = rockchip_pll_clk_compensation(clk, ppm);
+	if (ret != -ENOSYS)
+		goto out;
+
+	delta = (ppm < 0) ? -1 : 1;
+	delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
+
+	rate_target = rate + delta;
+
+	if (!rate_target)
+		return -EINVAL;
+
+	ret = clk_set_rate(clk, rate_target);
+	if (ret)
+		return ret;
+out:
+	if (!ret)
+		i2s_tdm->clk_ppm = ppm;
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+					   struct snd_pcm_substream *substream,
+					   unsigned int lrck_freq)
+{
+	struct clk *mclk_root;
+	struct clk *mclk_parent;
+	unsigned int mclk_root_freq;
+	unsigned int mclk_root_initial_freq;
+	unsigned int mclk_parent_freq;
+	unsigned int div, delta;
+	uint64_t ppm;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		mclk_parent = i2s_tdm->mclk_tx_src;
+	else
+		mclk_parent = i2s_tdm->mclk_rx_src;
+
+	switch (lrck_freq) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		mclk_root = i2s_tdm->mclk_root0;
+		mclk_root_freq = i2s_tdm->mclk_root0_freq;
+		mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		mclk_root = i2s_tdm->mclk_root1;
+		mclk_root_freq = i2s_tdm->mclk_root1_freq;
+		mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
+			lrck_freq);
+		return -EINVAL;
+	}
+
+	ret = clk_set_parent(mclk_parent, mclk_root);
+	if (ret)
+		goto out;
+
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
+					    mclk_root_freq, 0);
+	if (ret)
+		goto out;
+
+	delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
+	ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
+
+	if (ppm) {
+		div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
+		if (!div)
+			return -EINVAL;
+
+		mclk_root_freq = mclk_parent_freq * round_up(div, 2);
+
+		ret = clk_set_rate(mclk_root, mclk_root_freq);
+		if (ret)
+			goto out;
+
+		i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
+		i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
+	}
+
+	ret = clk_set_rate(mclk_parent, mclk_parent_freq);
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+				     struct snd_pcm_substream *substream,
+				     struct clk **mclk)
+{
+	unsigned int mclk_freq;
+	int ret;
+
+	if (i2s_tdm->clk_trcm) {
+		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+			dev_err(i2s_tdm->dev,
+				"clk_trcm, tx: %d and rx: %d should be same\n",
+				i2s_tdm->mclk_tx_freq,
+				i2s_tdm->mclk_rx_freq);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+		if (ret)
+			goto err;
+
+		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+		if (ret)
+			goto err;
+
+		/* mclk_rx is also ok. */
+		*mclk = i2s_tdm->mclk_tx;
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			*mclk = i2s_tdm->mclk_tx;
+			mclk_freq = i2s_tdm->mclk_tx_freq;
+		} else {
+			*mclk = i2s_tdm->mclk_rx;
+			mclk_freq = i2s_tdm->mclk_rx_freq;
+		}
+
+		ret = clk_set_rate(*mclk, mclk_freq);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
+				     struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	int usable_chs = MULTIPLEX_CH_MAX;
+	unsigned int val = 0;
+
+	if (!i2s_tdm->io_multiplex)
+		return 0;
+
+	if (IS_ERR(i2s_tdm->grf))
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		struct snd_pcm_str *playback_str =
+			&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+
+		if (playback_str->substream_opened) {
+			regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+			val &= I2S_TXCR_CSR_MASK;
+			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+		}
+
+		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+		val &= I2S_RXCR_CSR_MASK;
+
+		if (to_ch_num(val) > usable_chs) {
+			dev_err(i2s_tdm->dev,
+				"Capture chs(%d) > usable chs(%d)\n",
+				to_ch_num(val), usable_chs);
+			return -EINVAL;
+		}
+
+		switch (val) {
+		case I2S_CHN_4:
+			val = I2S_IO_6CH_OUT_4CH_IN;
+			break;
+		case I2S_CHN_6:
+			val = I2S_IO_4CH_OUT_6CH_IN;
+			break;
+		case I2S_CHN_8:
+			val = I2S_IO_2CH_OUT_8CH_IN;
+			break;
+		default:
+			val = I2S_IO_8CH_OUT_2CH_IN;
+			break;
+		}
+	} else {
+		struct snd_pcm_str *capture_str =
+			&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+		if (capture_str->substream_opened) {
+			regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+			val &= I2S_RXCR_CSR_MASK;
+			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+		}
+
+		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+		val &= I2S_TXCR_CSR_MASK;
+
+		if (to_ch_num(val) > usable_chs) {
+			dev_err(i2s_tdm->dev,
+				"Playback chs(%d) > usable chs(%d)\n",
+				to_ch_num(val), usable_chs);
+			return -EINVAL;
+		}
+
+		switch (val) {
+		case I2S_CHN_4:
+			val = I2S_IO_4CH_OUT_6CH_IN;
+			break;
+		case I2S_CHN_6:
+			val = I2S_IO_6CH_OUT_4CH_IN;
+			break;
+		case I2S_CHN_8:
+			val = I2S_IO_8CH_OUT_2CH_IN;
+			break;
+		default:
+			val = I2S_IO_2CH_OUT_8CH_IN;
+			break;
+		}
+	}
+
+	val <<= i2s_tdm->soc_data->grf_shift;
+	val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
+	regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
+
+	return 0;
+}
+
+static int rockchip_i2s_trcm_mode(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai,
+				  unsigned int div_bclk,
+				  unsigned int div_lrck,
+				  unsigned int fmt)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	unsigned long flags;
+
+	if (!i2s_tdm->clk_trcm)
+		return 0;
+
+	spin_lock_irqsave(&i2s_tdm->lock, flags);
+	if (atomic_read(&i2s_tdm->refcount))
+		rockchip_i2s_tdm_xfer_pause(substream, i2s_tdm);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+			   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+			   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+			   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+			   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+				   fmt);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+				   fmt);
+
+	if (atomic_read(&i2s_tdm->refcount))
+		rockchip_i2s_tdm_xfer_resume(substream, i2s_tdm);
+	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_params_channels(struct snd_pcm_substream *substream,
+					    struct snd_pcm_hw_params *params,
+					    struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	unsigned int reg_fmt, fmt;
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg_fmt = I2S_TXCR;
+	else
+		reg_fmt = I2S_RXCR;
+
+	regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
+	fmt &= I2S_TXCR_TFS_MASK;
+
+	if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+		switch (params_channels(params)) {
+		case 16:
+			ret = I2S_CHN_8;
+			break;
+		case 12:
+			ret = I2S_CHN_6;
+			break;
+		case 8:
+			ret = I2S_CHN_4;
+			break;
+		case 4:
+			ret = I2S_CHN_2;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	} else {
+		switch (params_channels(params)) {
+		case 8:
+			ret = I2S_CHN_8;
+			break;
+		case 6:
+			ret = I2S_CHN_6;
+			break;
+		case 4:
+			ret = I2S_CHN_4;
+			break;
+		case 2:
+			ret = I2S_CHN_2;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	struct clk *mclk;
+	int ret = 0;
+	unsigned int val = 0;
+	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
+
+	if (i2s_tdm->is_master_mode) {
+		if (i2s_tdm->mclk_calibrate)
+			rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+							params_rate(params));
+
+		ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+		if (ret)
+			goto err;
+
+		mclk_rate = clk_get_rate(mclk);
+		bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+		if (!bclk_rate) {
+			ret = -EINVAL;
+			goto err;
+		}
+		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+		div_lrck = bclk_rate / params_rate(params);
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		val |= I2S_TXCR_VDW(8);
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val |= I2S_TXCR_VDW(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val |= I2S_TXCR_VDW(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val |= I2S_TXCR_VDW(24);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+		val |= I2S_TXCR_VDW(32);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
+	if (ret < 0)
+		goto err;
+
+	val |= ret;
+	if (i2s_tdm->clk_trcm) {
+		rockchip_i2s_trcm_mode(substream, dai, div_bclk, div_lrck, val);
+	} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+				   I2S_CLKDIV_TXM_MASK,
+				   I2S_CLKDIV_TXM(div_bclk));
+		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+				   I2S_CKR_TSD_MASK,
+				   I2S_CKR_TSD(div_lrck));
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+				   val);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+				   I2S_CLKDIV_RXM_MASK,
+				   I2S_CLKDIV_RXM(div_bclk));
+		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+				   I2S_CKR_RSD_MASK,
+				   I2S_CKR_RSD(div_lrck));
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+				   val);
+	}
+
+	ret = rockchip_i2s_io_multiplex(substream, dai);
+
+err:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
+				    int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 1);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 1);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 0);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 0);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
+				       unsigned int freq, int dir)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+
+	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+	if (i2s_tdm->clk_trcm) {
+		i2s_tdm->mclk_tx_freq = freq;
+		i2s_tdm->mclk_rx_freq = freq;
+	} else {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			i2s_tdm->mclk_tx_freq = freq;
+		else
+			i2s_tdm->mclk_rx_freq = freq;
+	}
+
+	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
+		stream ? "rx" : "tx", freq);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,
+						  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = CLK_PPM_MIN;
+	uinfo->value.integer.max = CLK_PPM_MAX;
+	uinfo->value.integer.step = 1;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+	ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	int ret = 0, ppm = 0;
+
+	if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
+	    (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
+		return -EINVAL;
+
+	ppm = ucontrol->value.integer.value[0];
+
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
+					    i2s_tdm->mclk_root0_freq, ppm);
+	if (ret)
+		return ret;
+
+	if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
+		return 0;
+
+	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
+					    i2s_tdm->mclk_root1_freq, ppm);
+
+	return ret;
+}
+
+static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Clk Compensation In PPM",
+	.info = rockchip_i2s_tdm_clk_compensation_info,
+	.get = rockchip_i2s_tdm_clk_compensation_get,
+	.put = rockchip_i2s_tdm_clk_compensation_put,
+};
+
+static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+	dai->playback_dma_data = &i2s_tdm->playback_dma_data;
+
+	if (i2s_tdm->mclk_calibrate)
+		snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+
+	return 0;
+}
+
+static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
+				 unsigned int tx_mask, unsigned int rx_mask,
+				 int slots, int slot_width)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	i2s_tdm->tdm_mode = true;
+	i2s_tdm->bclk_fs = slots * slot_width;
+	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+	val = TDM_SLOT_BIT_WIDTH(slot_width) |
+	      TDM_FRAME_WIDTH(slots * slot_width);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+			   mask, val);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+			   mask, val);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
+	.hw_params = rockchip_i2s_tdm_hw_params,
+	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
+	.set_fmt = rockchip_i2s_tdm_set_fmt,
+	.set_tdm_slot = rockchip_dai_tdm_slot,
+	.trigger = rockchip_i2s_tdm_trigger,
+};
+
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
+	.name = DRV_NAME,
+};
+
+static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_RXDR:
+	case I2S_TXFIFOLR:
+	case I2S_INTSR:
+	case I2S_RXFIFOLR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXFIFOLR:
+	case I2S_INTSR:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_RXDR:
+	case I2S_RXFIFOLR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_RXDR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
+	{0x00, 0x7200000f},
+	{0x04, 0x01c8000f},
+	{0x08, 0x00001f1f},
+	{0x10, 0x001f0000},
+	{0x14, 0x01f00000},
+	{0x30, 0x00003eff},
+	{0x34, 0x00003eff},
+	{0x38, 0x00000707},
+};
+
+static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = I2S_CLKDIV,
+	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+	.writeable_reg = rockchip_i2s_tdm_wr_reg,
+	.readable_reg = rockchip_i2s_tdm_rd_reg,
+	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
+	.precious_reg = rockchip_i2s_tdm_precious_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int common_soc_init(struct device *dev, u32 addr)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
+	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
+	int i;
+
+	if (IS_ERR(i2s_tdm->grf))
+		return 0;
+
+	switch (trcm) {
+	case I2S_CKR_TRCM_TXONLY:
+		/* fall through */
+	case I2S_CKR_TRCM_RXONLY:
+		break;
+	default:
+		return 0;
+	}
+
+	for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
+		if (addr != configs[i].addr)
+			continue;
+		reg = configs[i].reg;
+		if (trcm == I2S_CKR_TRCM_TXONLY)
+			val = configs[i].txonly;
+		else
+			val = configs[i].rxonly;
+
+		if (reg)
+			regmap_write(i2s_tdm->grf, reg, val);
+	}
+
+	return 0;
+}
+
+static const struct txrx_config px30_txrx_config[] = {
+	{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
+};
+
+static const struct txrx_config rk1808_txrx_config[] = {
+	{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
+};
+
+static const struct txrx_config rk3308_txrx_config[] = {
+	{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
+	{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
+};
+
+static const struct txrx_config rk3568_txrx_config[] = {
+	{ 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
+	{ 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
+	{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
+};
+
+static const struct txrx_config rv1126_txrx_config[] = {
+	{ 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
+};
+
+static const struct rk_i2s_soc_data px30_i2s_soc_data = {
+	.softrst_offset = 0x0300,
+	.configs = px30_txrx_config,
+	.config_count = ARRAY_SIZE(px30_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct rk_i2s_soc_data rk1808_i2s_soc_data = {
+	.softrst_offset = 0x0300,
+	.configs = rk1808_txrx_config,
+	.config_count = ARRAY_SIZE(rk1808_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct rk_i2s_soc_data rk3308_i2s_soc_data = {
+	.softrst_offset = 0x0400,
+	.grf_reg_offset = 0x0308,
+	.grf_shift = 5,
+	.configs = rk3308_txrx_config,
+	.config_count = ARRAY_SIZE(rk3308_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct rk_i2s_soc_data rk3568_i2s_soc_data = {
+	.softrst_offset = 0x0400,
+	.configs = rk3568_txrx_config,
+	.config_count = ARRAY_SIZE(rk3568_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct rk_i2s_soc_data rv1126_i2s_soc_data = {
+	.softrst_offset = 0x0300,
+	.configs = rv1126_txrx_config,
+	.config_count = ARRAY_SIZE(rv1126_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct of_device_id rockchip_i2s_tdm_match[] = {
+	{ .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
+	{ .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
+	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+	{ .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
+	{ .compatible = "rockchip,rk3588-i2s-tdm", },
+	{ .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
+	{},
+};
+
+static int of_i2s_resetid_get(struct device_node *node,
+			      const char *id)
+{
+	struct of_phandle_args args;
+	int index = 0;
+	int ret;
+
+	if (id)
+		index = of_property_match_string(node,
+						 "reset-names", id);
+	ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+					 index, &args);
+	if (ret)
+		return ret;
+
+	return args.args[0];
+}
+
+static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
+					struct snd_soc_dai_driver **soc_dai)
+{
+	struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+		.probe = rockchip_i2s_tdm_dai_probe,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE |
+				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE |
+				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
+		},
+		.ops = &rockchip_i2s_tdm_dai_ops,
+	};
+
+	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+				sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+	if (!(*soc_dai))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
+				       int num,
+				       bool is_rx_path)
+{
+	unsigned int *i2s_data;
+	int i, j, ret = 0;
+
+	if (is_rx_path)
+		i2s_data = i2s_tdm->i2s_sdis;
+	else
+		i2s_data = i2s_tdm->i2s_sdos;
+
+	for (i = 0; i < num; i++) {
+		if (i2s_data[i] > CH_GRP_MAX - 1) {
+			dev_err(i2s_tdm->dev,
+				"%s path i2s_data[%d]: %d is overflow, max is: %d\n",
+				is_rx_path ? "RX" : "TX",
+				i, i2s_data[i], CH_GRP_MAX);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (j = 0; j < num; j++) {
+			if (i == j)
+				continue;
+
+			if (i2s_data[i] == i2s_data[j]) {
+				dev_err(i2s_tdm->dev,
+					"%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
+					is_rx_path ? "RX" : "TX",
+					i, i2s_data[i],
+					j, i2s_data[j]);
+				ret = -EINVAL;
+				goto err;
+			}
+		}
+	}
+
+err:
+	return ret;
+}
+
+static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					    int num)
+{
+	int idx;
+
+	for (idx = 0; idx < num; idx++) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_PATH_MASK(idx),
+				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
+	}
+}
+
+static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					    int num)
+{
+	int idx;
+
+	for (idx = 0; idx < num; idx++) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_PATH_MASK(idx),
+				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
+	}
+}
+
+static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					 int num, bool is_rx_path)
+{
+	if (is_rx_path)
+		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
+	else
+		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
+}
+
+static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					 struct device_node *np,
+					 bool is_rx_path)
+{
+	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
+	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
+	char *i2s_path_prop;
+	unsigned int *i2s_data;
+	int num, ret = 0;
+
+	if (is_rx_path) {
+		i2s_path_prop = i2s_rx_path_prop;
+		i2s_data = i2s_tdm->i2s_sdis;
+	} else {
+		i2s_path_prop = i2s_tx_path_prop;
+		i2s_data = i2s_tdm->i2s_sdos;
+	}
+
+	num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
+	if (num < 0) {
+		if (num != -ENOENT) {
+			dev_err(i2s_tdm->dev,
+				"Failed to read '%s' num: %d\n",
+				i2s_path_prop, num);
+			ret = num;
+		}
+		goto out;
+	} else if (num != CH_GRP_MAX) {
+		dev_err(i2s_tdm->dev,
+			"The num: %d should be: %d\n", num, CH_GRP_MAX);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = of_property_read_u32_array(np, i2s_path_prop,
+					 i2s_data, num);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev,
+			"Failed to read '%s': %d\n",
+			i2s_path_prop, ret);
+		goto out;
+	}
+
+	ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev,
+			"Failed to check i2s data bus: %d\n", ret);
+		goto out;
+	}
+
+	rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
+
+out:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					    struct device_node *np)
+{
+	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
+}
+
+static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					    struct device_node *np)
+{
+	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
+}
+
+static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *cru_node;
+	const struct of_device_id *of_id;
+	struct rk_i2s_tdm_dev *i2s_tdm;
+	struct snd_soc_dai_driver *soc_dai;
+	struct resource *res;
+	void __iomem *regs;
+	bool sync;
+	int ret;
+	int val;
+
+	ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+	if (ret)
+		return ret;
+
+	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+	if (!i2s_tdm)
+		return -ENOMEM;
+
+	i2s_tdm->dev = &pdev->dev;
+
+	of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	spin_lock_init(&i2s_tdm->lock);
+	i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
+
+	i2s_tdm->bclk_fs = 64;
+	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+		if ((val >= 32) && (val % 2 == 0))
+			i2s_tdm->bclk_fs = val;
+	}
+
+	i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+		if (val >= 0 && val <= 2) {
+			i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+			if (i2s_tdm->clk_trcm)
+				soc_dai->symmetric_rates = 1;
+		}
+	}
+
+	i2s_tdm->tdm_fsync_half_frame =
+		of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
+
+	if (of_property_read_bool(node, "rockchip,playback-only"))
+		soc_dai->capture.channels_min = 0;
+	else if (of_property_read_bool(node, "rockchip,capture-only"))
+		soc_dai->playback.channels_min = 0;
+
+	i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+
+	sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
+	       of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
+	       of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
+
+	if (i2s_tdm->clk_trcm && sync) {
+		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+		i2s_tdm->cru_base = of_iomap(cru_node, 0);
+		if (!i2s_tdm->cru_base)
+			return -ENOENT;
+
+		i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+		i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+	}
+
+	i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+	if (IS_ERR(i2s_tdm->tx_reset)) {
+		ret = PTR_ERR(i2s_tdm->tx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+	if (IS_ERR(i2s_tdm->rx_reset)) {
+		ret = PTR_ERR(i2s_tdm->rx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(i2s_tdm->hclk))
+		return PTR_ERR(i2s_tdm->hclk);
+
+	ret = clk_prepare_enable(i2s_tdm->hclk);
+	if (ret)
+		return ret;
+
+	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+	if (IS_ERR(i2s_tdm->mclk_tx))
+		return PTR_ERR(i2s_tdm->mclk_tx);
+
+	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+	if (IS_ERR(i2s_tdm->mclk_rx))
+		return PTR_ERR(i2s_tdm->mclk_rx);
+
+	i2s_tdm->io_multiplex =
+		of_property_read_bool(node, "rockchip,io-multiplex");
+
+	i2s_tdm->mclk_calibrate =
+		of_property_read_bool(node, "rockchip,mclk-calibrate");
+	if (i2s_tdm->mclk_calibrate) {
+		i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+		if (IS_ERR(i2s_tdm->mclk_tx_src))
+			return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+		i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+		if (IS_ERR(i2s_tdm->mclk_rx_src))
+			return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+		i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+		if (IS_ERR(i2s_tdm->mclk_root0))
+			return PTR_ERR(i2s_tdm->mclk_root0);
+
+		i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+		if (IS_ERR(i2s_tdm->mclk_root1))
+			return PTR_ERR(i2s_tdm->mclk_root1);
+
+		i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
+		i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
+		i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
+		i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &rockchip_i2s_tdm_regmap_config);
+	if (IS_ERR(i2s_tdm->regmap))
+		return PTR_ERR(i2s_tdm->regmap);
+
+	i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+	i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->playback_dma_data.maxburst = 8;
+
+	i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+	i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->capture_dma_data.maxburst = 8;
+
+	ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
+		return ret;
+	}
+
+	atomic_set(&i2s_tdm->refcount, 0);
+	dev_set_drvdata(&pdev->dev, i2s_tdm);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = i2s_tdm_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+			   I2S_DMACR_TDL(16));
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+			   I2S_DMACR_RDL(16));
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+			   I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+	if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
+		i2s_tdm->soc_data->init(&pdev->dev, res->start);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_i2s_tdm_component,
+					      soc_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI\n");
+		goto err_suspend;
+	}
+
+	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+		return ret;
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		return ret;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+	if (!IS_ERR(i2s_tdm->hclk))
+		clk_disable_unprepare(i2s_tdm->hclk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_i2s_tdm_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(i2s_tdm->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+				rockchip_i2s_tdm_resume)
+};
+
+static struct platform_driver rockchip_i2s_tdm_driver = {
+	.probe = rockchip_i2s_tdm_probe,
+	.remove = rockchip_i2s_tdm_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+		.pm = &rockchip_i2s_tdm_pm_ops,
+	},
+};
+module_platform_driver(rockchip_i2s_tdm_driver);
+
+MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.h b/sound/soc/rockchip/rockchip_i2s_tdm.h
new file mode 100644
index 000000000..fa41f8142
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.h
@@ -0,0 +1,393 @@
+/*
+ * sound/soc/rockchip/rockchip_i2s_tdm.h
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S_TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ROCKCHIP_I2S_TDM_H
+#define _ROCKCHIP_I2S_TDM_H
+
+/*
+ * TXCR
+ * transmit operation control register
+ */
+#define I2S_TXCR_PATH_SHIFT(x)	(23 + (x) * 2)
+#define I2S_TXCR_PATH_MASK(x)	(0x3 << I2S_TXCR_PATH_SHIFT(x))
+#define I2S_TXCR_PATH(x, v)	((v) << I2S_TXCR_PATH_SHIFT(x))
+#define I2S_TXCR_RCNT_SHIFT	17
+#define I2S_TXCR_RCNT_MASK	(0x3f << I2S_TXCR_RCNT_SHIFT)
+#define I2S_TXCR_CSR_SHIFT	15
+#define I2S_TXCR_CSR(x)		((x) << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_CSR_MASK	(3 << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_HWT		BIT(14)
+#define I2S_TXCR_SJM_SHIFT	12
+#define I2S_TXCR_SJM_R		(0 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_SJM_L		(1 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_FBM_SHIFT	11
+#define I2S_TXCR_FBM_MSB	(0 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_FBM_LSB	(1 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_IBM_SHIFT	9
+#define I2S_TXCR_IBM_NORMAL	(0 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_LSJM	(1 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_RSJM	(2 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_MASK	(3 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_PBM_SHIFT	7
+#define I2S_TXCR_PBM_MODE(x)	((x) << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_PBM_MASK	(3 << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_TFS_SHIFT	5
+#define I2S_TXCR_TFS_I2S	(0 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_PCM	(1 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_PCM	(2 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_I2S	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_MASK	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_VDW_SHIFT	0
+#define I2S_TXCR_VDW(x)		(((x) - 1) << I2S_TXCR_VDW_SHIFT)
+#define I2S_TXCR_VDW_MASK	(0x1f << I2S_TXCR_VDW_SHIFT)
+
+/*
+ * RXCR
+ * receive operation control register
+ */
+#define I2S_RXCR_PATH_SHIFT(x)	(17 + (x) * 2)
+#define I2S_RXCR_PATH_MASK(x)	(0x3 << I2S_RXCR_PATH_SHIFT(x))
+#define I2S_RXCR_PATH(x, v)	((v) << I2S_RXCR_PATH_SHIFT(x))
+#define I2S_RXCR_CSR_SHIFT	15
+#define I2S_RXCR_CSR(x)		((x) << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_CSR_MASK	(3 << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_HWT		BIT(14)
+#define I2S_RXCR_SJM_SHIFT	12
+#define I2S_RXCR_SJM_R		(0 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_SJM_L		(1 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_FBM_SHIFT	11
+#define I2S_RXCR_FBM_MSB	(0 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_FBM_LSB	(1 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_IBM_SHIFT	9
+#define I2S_RXCR_IBM_NORMAL	(0 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_LSJM	(1 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_RSJM	(2 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_MASK	(3 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_PBM_SHIFT	7
+#define I2S_RXCR_PBM_MODE(x)	((x) << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_PBM_MASK	(3 << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_TFS_SHIFT	5
+#define I2S_RXCR_TFS_I2S	(0 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_PCM	(1 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_PCM	(2 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_I2S	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_MASK	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_VDW_SHIFT	0
+#define I2S_RXCR_VDW(x)		(((x) - 1) << I2S_RXCR_VDW_SHIFT)
+#define I2S_RXCR_VDW_MASK	(0x1f << I2S_RXCR_VDW_SHIFT)
+
+/*
+ * CKR
+ * clock generation register
+ */
+#define I2S_CKR_TRCM_SHIFT	28
+#define I2S_CKR_TRCM(x)	((x) << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXRX	(0 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXONLY	(1 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_RXONLY	(2 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_MASK	(3 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_MSS_SHIFT	27
+#define I2S_CKR_MSS_MASTER	(0 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_SLAVE	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_MASK	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_CKP_SHIFT	26
+#define I2S_CKR_CKP_NORMAL	(0 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_INVERTED	(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_MASK	(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_RLP_SHIFT	25
+#define I2S_CKR_RLP_NORMAL	(0 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_INVERTED	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_MASK	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_TLP_SHIFT	24
+#define I2S_CKR_TLP_NORMAL	(0 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_INVERTED	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_MASK	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_MDIV_SHIFT	16
+#define I2S_CKR_MDIV(x)		(((x) - 1) << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_MDIV_MASK	(0xff << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_RSD_SHIFT	8
+#define I2S_CKR_RSD(x)		(((x) - 1) << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_RSD_MASK	(0xff << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_TSD_SHIFT	0
+#define I2S_CKR_TSD(x)		(((x) - 1) << I2S_CKR_TSD_SHIFT)
+#define I2S_CKR_TSD_MASK	(0xff << I2S_CKR_TSD_SHIFT)
+
+/*
+ * FIFOLR
+ * FIFO level register
+ */
+#define I2S_FIFOLR_RFL_SHIFT	24
+#define I2S_FIFOLR_RFL_MASK	(0x3f << I2S_FIFOLR_RFL_SHIFT)
+#define I2S_FIFOLR_TFL3_SHIFT	18
+#define I2S_FIFOLR_TFL3_MASK	(0x3f << I2S_FIFOLR_TFL3_SHIFT)
+#define I2S_FIFOLR_TFL2_SHIFT	12
+#define I2S_FIFOLR_TFL2_MASK	(0x3f << I2S_FIFOLR_TFL2_SHIFT)
+#define I2S_FIFOLR_TFL1_SHIFT	6
+#define I2S_FIFOLR_TFL1_MASK	(0x3f << I2S_FIFOLR_TFL1_SHIFT)
+#define I2S_FIFOLR_TFL0_SHIFT	0
+#define I2S_FIFOLR_TFL0_MASK	(0x3f << I2S_FIFOLR_TFL0_SHIFT)
+
+/*
+ * DMACR
+ * DMA control register
+ */
+#define I2S_DMACR_RDE_SHIFT	24
+#define I2S_DMACR_RDE_DISABLE	(0 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDE_ENABLE	(1 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDL_SHIFT	16
+#define I2S_DMACR_RDL(x)	(((x) - 1) << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_RDL_MASK	(0x1f << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_TDE_SHIFT	8
+#define I2S_DMACR_TDE_DISABLE	(0 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDE_ENABLE	(1 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDL_SHIFT	0
+#define I2S_DMACR_TDL(x)	((x) << I2S_DMACR_TDL_SHIFT)
+#define I2S_DMACR_TDL_MASK	(0x1f << I2S_DMACR_TDL_SHIFT)
+
+/*
+ * INTCR
+ * interrupt control register
+ */
+#define I2S_INTCR_RFT_SHIFT	20
+#define I2S_INTCR_RFT(x)	(((x) - 1) << I2S_INTCR_RFT_SHIFT)
+#define I2S_INTCR_RXOIC		BIT(18)
+#define I2S_INTCR_RXOIE_SHIFT	17
+#define I2S_INTCR_RXOIE_DISABLE	(0 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXOIE_ENABLE	(1 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXFIE_SHIFT	16
+#define I2S_INTCR_RXFIE_DISABLE	(0 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_RXFIE_ENABLE	(1 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_TFT_SHIFT	4
+#define I2S_INTCR_TFT(x)	(((x) - 1) << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TFT_MASK	(0x1f << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TXUIC		BIT(2)
+#define I2S_INTCR_TXUIE_SHIFT	1
+#define I2S_INTCR_TXUIE_DISABLE	(0 << I2S_INTCR_TXUIE_SHIFT)
+#define I2S_INTCR_TXUIE_ENABLE	(1 << I2S_INTCR_TXUIE_SHIFT)
+
+/*
+ * INTSR
+ * interrupt status register
+ */
+#define I2S_INTSR_TXEIE_SHIFT	0
+#define I2S_INTSR_TXEIE_DISABLE	(0 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_TXEIE_ENABLE	(1 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_RXOI_SHIFT	17
+#define I2S_INTSR_RXOI_INA	(0 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXOI_ACT	(1 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXFI_SHIFT	16
+#define I2S_INTSR_RXFI_INA	(0 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_RXFI_ACT	(1 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_TXUI_SHIFT	1
+#define I2S_INTSR_TXUI_INA	(0 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXUI_ACT	(1 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXEI_SHIFT	0
+#define I2S_INTSR_TXEI_INA	(0 << I2S_INTSR_TXEI_SHIFT)
+#define I2S_INTSR_TXEI_ACT	(1 << I2S_INTSR_TXEI_SHIFT)
+
+/*
+ * XFER
+ * Transfer start register
+ */
+#define I2S_XFER_RXS_SHIFT	1
+#define I2S_XFER_RXS_STOP	(0 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_RXS_START	(1 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_TXS_SHIFT	0
+#define I2S_XFER_TXS_STOP	(0 << I2S_XFER_TXS_SHIFT)
+#define I2S_XFER_TXS_START	(1 << I2S_XFER_TXS_SHIFT)
+
+/*
+ * CLR
+ * clear SCLK domain logic register
+ */
+#define I2S_CLR_RXC	BIT(1)
+#define I2S_CLR_TXC	BIT(0)
+
+/*
+ * TXDR
+ * Transimt FIFO data register, write only.
+ */
+#define I2S_TXDR_MASK	(0xff)
+
+/*
+ * RXDR
+ * Receive FIFO data register, write only.
+ */
+#define I2S_RXDR_MASK	(0xff)
+
+/*
+ * TDM_CTRL
+ * TDM ctrl register
+ */
+#define TDM_FSYNC_WIDTH_SEL1_MSK	GENMASK(20, 18)
+#define TDM_FSYNC_WIDTH_SEL1(x)		(((x) - 1) << 18)
+#define TDM_FSYNC_WIDTH_SEL0_MSK	BIT(17)
+#define TDM_FSYNC_WIDTH_HALF_FRAME	0
+#define TDM_FSYNC_WIDTH_ONE_FRAME	BIT(17)
+#define TDM_SHIFT_CTRL_MSK		GENMASK(16, 14)
+#define TDM_SHIFT_CTRL(x)		((x) << 14)
+#define TDM_SLOT_BIT_WIDTH_MSK		GENMASK(13, 9)
+#define TDM_SLOT_BIT_WIDTH(x)		(((x) - 1) << 9)
+#define TDM_FRAME_WIDTH_MSK		GENMASK(8, 0)
+#define TDM_FRAME_WIDTH(x)		(((x) - 1) << 0)
+
+/*
+ * CLKDIV
+ * Mclk div register
+ */
+#define I2S_CLKDIV_TXM_SHIFT	0
+#define I2S_CLKDIV_TXM(x)		(((x) - 1) << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_TXM_MASK	(0xff << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_RXM_SHIFT	8
+#define I2S_CLKDIV_RXM(x)		(((x) - 1) << I2S_CLKDIV_RXM_SHIFT)
+#define I2S_CLKDIV_RXM_MASK	(0xff << I2S_CLKDIV_RXM_SHIFT)
+
+/* Clock divider id */
+enum {
+	ROCKCHIP_DIV_MCLK = 0,
+	ROCKCHIP_DIV_BCLK,
+};
+
+/* channel select */
+#define I2S_CSR_SHIFT	15
+#define I2S_CHN_2	(0 << I2S_CSR_SHIFT)
+#define I2S_CHN_4	(1 << I2S_CSR_SHIFT)
+#define I2S_CHN_6	(2 << I2S_CSR_SHIFT)
+#define I2S_CHN_8	(3 << I2S_CSR_SHIFT)
+
+/* io direction cfg register */
+#define I2S_IO_DIRECTION_MASK	(7)
+#define I2S_IO_8CH_OUT_2CH_IN	(7)
+#define I2S_IO_6CH_OUT_4CH_IN	(3)
+#define I2S_IO_4CH_OUT_6CH_IN	(1)
+#define I2S_IO_2CH_OUT_8CH_IN	(0)
+
+/* I2S REGS */
+#define I2S_TXCR	(0x0000)
+#define I2S_RXCR	(0x0004)
+#define I2S_CKR		(0x0008)
+#define I2S_TXFIFOLR	(0x000c)
+#define I2S_DMACR	(0x0010)
+#define I2S_INTCR	(0x0014)
+#define I2S_INTSR	(0x0018)
+#define I2S_XFER	(0x001c)
+#define I2S_CLR		(0x0020)
+#define I2S_TXDR	(0x0024)
+#define I2S_RXDR	(0x0028)
+#define I2S_RXFIFOLR	(0x002c)
+#define I2S_TDM_TXCR	(0x0030)
+#define I2S_TDM_RXCR	(0x0034)
+#define I2S_CLKDIV	(0x0038)
+
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK((h), (l)) << 16))
+
+/* PX30 GRF CONFIGS*/
+#define PX30_I2S0_CLK_IN_SRC_FROM_TX		HIWORD_UPDATE(1, 13, 12)
+#define PX30_I2S0_CLK_IN_SRC_FROM_RX		HIWORD_UPDATE(2, 13, 12)
+#define PX30_I2S0_MCLK_OUT_SRC_FROM_TX		HIWORD_UPDATE(1, 5, 5)
+#define PX30_I2S0_MCLK_OUT_SRC_FROM_RX		HIWORD_UPDATE(0, 5, 5)
+
+#define PX30_I2S0_CLK_TXONLY \
+	(PX30_I2S0_MCLK_OUT_SRC_FROM_TX | PX30_I2S0_CLK_IN_SRC_FROM_TX)
+
+#define PX30_I2S0_CLK_RXONLY \
+	(PX30_I2S0_MCLK_OUT_SRC_FROM_RX | PX30_I2S0_CLK_IN_SRC_FROM_RX)
+
+/* RK1808 GRF CONFIGS*/
+#define RK1808_I2S0_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(1, 2, 2)
+#define RK1808_I2S0_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(0, 2, 2)
+#define RK1808_I2S0_CLK_IN_SRC_FROM_TX		HIWORD_UPDATE(1, 1, 0)
+#define RK1808_I2S0_CLK_IN_SRC_FROM_RX		HIWORD_UPDATE(2, 1, 0)
+
+#define RK1808_I2S0_CLK_TXONLY \
+	(RK1808_I2S0_MCLK_OUT_SRC_FROM_TX | RK1808_I2S0_CLK_IN_SRC_FROM_TX)
+
+#define RK1808_I2S0_CLK_RXONLY \
+	(RK1808_I2S0_MCLK_OUT_SRC_FROM_RX | RK1808_I2S0_CLK_IN_SRC_FROM_RX)
+
+/* RK3308 GRF CONFIGS*/
+#define RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(1, 10, 10)
+#define RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(0, 10, 10)
+#define RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_TX	HIWORD_UPDATE(1, 9, 9)
+#define RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_RX	HIWORD_UPDATE(0, 9, 9)
+#define RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_RX	HIWORD_UPDATE(1, 8, 8)
+#define RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_TX	HIWORD_UPDATE(0, 8, 8)
+#define RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(1, 2, 2)
+#define RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(0, 2, 2)
+#define RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_TX	HIWORD_UPDATE(1, 1, 1)
+#define RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_RX	HIWORD_UPDATE(0, 1, 1)
+#define RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_RX	HIWORD_UPDATE(1, 0, 0)
+#define RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_TX	HIWORD_UPDATE(0, 0, 0)
+
+#define RK3308_I2S0_CLK_TXONLY \
+	(RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_TX | \
+	RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_TX | \
+	RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_TX)
+
+#define RK3308_I2S0_CLK_RXONLY \
+	(RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_RX | \
+	RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_RX | \
+	RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_RX)
+
+#define RK3308_I2S1_CLK_TXONLY \
+	(RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_TX | \
+	RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_TX | \
+	RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_TX)
+
+#define RK3308_I2S1_CLK_RXONLY \
+	(RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_RX | \
+	RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_RX | \
+	RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_RX)
+
+/* RK3568 GRF CONFIGS*/
+#define RK3568_I2S1_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(1, 5, 5)
+#define RK3568_I2S1_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(0, 5, 5)
+
+#define RK3568_I2S1_CLK_TXONLY \
+	RK3568_I2S1_MCLK_OUT_SRC_FROM_TX
+
+#define RK3568_I2S1_CLK_RXONLY \
+	RK3568_I2S1_MCLK_OUT_SRC_FROM_RX
+
+#define RK3568_I2S3_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(1, 15, 15)
+#define RK3568_I2S3_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(0, 15, 15)
+#define RK3568_I2S3_SCLK_SRC_FROM_TX		HIWORD_UPDATE(1, 7, 7)
+#define RK3568_I2S3_SCLK_SRC_FROM_RX		HIWORD_UPDATE(0, 7, 7)
+#define RK3568_I2S3_LRCK_SRC_FROM_TX		HIWORD_UPDATE(1, 6, 6)
+#define RK3568_I2S3_LRCK_SRC_FROM_RX		HIWORD_UPDATE(0, 6, 6)
+
+#define RK3568_I2S3_MCLK_TXONLY \
+	RK3568_I2S3_MCLK_OUT_SRC_FROM_TX
+
+#define RK3568_I2S3_CLK_TXONLY \
+	(RK3568_I2S3_SCLK_SRC_FROM_TX | \
+	RK3568_I2S3_LRCK_SRC_FROM_TX)
+
+#define RK3568_I2S3_MCLK_RXONLY \
+	RK3568_I2S3_MCLK_OUT_SRC_FROM_RX
+
+#define RK3568_I2S3_CLK_RXONLY \
+	(RK3568_I2S3_SCLK_SRC_FROM_RX | \
+	RK3568_I2S3_LRCK_SRC_FROM_RX)
+
+/* RV1126 GRF CONFIGS*/
+#define RV1126_I2S0_MCLK_OUT_SRC_FROM_TX	HIWORD_UPDATE(0, 9, 9)
+#define RV1126_I2S0_MCLK_OUT_SRC_FROM_RX	HIWORD_UPDATE(1, 9, 9)
+
+#define RV1126_I2S0_CLK_TXONLY \
+	RV1126_I2S0_MCLK_OUT_SRC_FROM_TX
+
+#define RV1126_I2S0_CLK_RXONLY \
+	RV1126_I2S0_MCLK_OUT_SRC_FROM_RX
+
+#endif /* _ROCKCHIP_I2S_TDM_H */
diff --git a/sound/soc/rockchip/rockchip_multi_dais.c b/sound/soc/rockchip/rockchip_multi_dais.c
new file mode 100644
index 000000000..7a789c8c7
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_multi_dais.c
@@ -0,0 +1,541 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip Multi-DAIS  driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rockchip_multi_dais.h"
+
+#define BITCLOCK_INV_STR	"bitclock-inversion"
+#define FRAME_INV_STR		"frame-inversion"
+#define BITCLOCK_MASTER_STR	"bitclock-master"
+#define FRAME_MASTER_STR	"frame-master"
+#define DAIS_DRV_NAME		"rockchip-mdais"
+#define RK3308_GRF_SOC_CON2	0x308
+
+static inline struct rk_mdais_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+static void hw_refine_channels(struct snd_pcm_hw_params *params,
+			       unsigned int channel)
+{
+	struct snd_interval *c =
+		hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	c->min = channel;
+	c->max = channel;
+}
+
+static int rockchip_mdais_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_pcm_hw_params *cparams;
+	struct snd_soc_dai *child;
+	unsigned int *channel_maps;
+	int ret = 0, i = 0;
+
+	cparams = kmemdup(params, sizeof(*params), GFP_KERNEL);
+	if (IS_ERR(cparams))
+		return PTR_ERR(cparams);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		channel_maps = mdais->playback_channel_maps;
+	else
+		channel_maps = mdais->capture_channel_maps;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (channel_maps[i])
+			hw_refine_channels(cparams, channel_maps[i]);
+		if (child->driver->ops && child->driver->ops->hw_params) {
+			ret = child->driver->ops->hw_params(substream, cparams, child);
+			if (ret < 0) {
+				dev_err(dai->dev, "ASoC: can't set %s hw params: %d\n",
+					dai->name, ret);
+				return ret;
+			}
+		}
+	}
+
+	kfree(cparams);
+	return 0;
+}
+
+static int rockchip_mdais_trigger(struct snd_pcm_substream *substream,
+				  int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_soc_dai *child;
+	int ret = 0, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (child->driver->ops && child->driver->ops->trigger) {
+			ret = child->driver->ops->trigger(substream,
+							  cmd, child);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+				     unsigned int freq, int dir)
+{
+	struct rk_mdais_dev *mdais = to_info(cpu_dai);
+	struct snd_soc_dai *child;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		ret = snd_soc_dai_set_sysclk(child, clk_id, freq, dir);
+		if (ret && ret != -ENOTSUPP)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_set_fmt(struct snd_soc_dai *cpu_dai,
+				  unsigned int fmt)
+{
+	struct rk_mdais_dev *mdais = to_info(cpu_dai);
+	struct snd_soc_dai *child;
+	unsigned int dai_fmt;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		dai_fmt = fmt;
+		if (mdais->dais[i].fmt_msk) {
+			dai_fmt &= ~(mdais->dais[i].fmt_msk);
+			dai_fmt |= mdais->dais[i].fmt;
+		}
+		ret = snd_soc_dai_set_fmt(child, dai_fmt);
+		if (ret && ret != -ENOTSUPP)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_tdm_slot(struct snd_soc_dai *dai,
+				   unsigned int tx_mask, unsigned int rx_mask,
+				   int slots, int slot_width)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_soc_dai *child;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		ret = snd_soc_dai_set_tdm_slot(child, tx_mask, rx_mask,
+					       slots, slot_width);
+		if (ret && ret != -ENOTSUPP)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_soc_dai *child;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (!child->probed && child->driver->probe) {
+			ret = child->driver->probe(child);
+			if (ret < 0) {
+				dev_err(child->dev,
+					"ASoC: failed to probe DAI %s: %d\n",
+					child->name, ret);
+				return ret;
+			}
+			dai->probed = 1;
+		}
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_mdais_dai_ops = {
+	.hw_params = rockchip_mdais_hw_params,
+	.set_sysclk = rockchip_mdais_set_sysclk,
+	.set_fmt = rockchip_mdais_set_fmt,
+	.set_tdm_slot = rockchip_mdais_tdm_slot,
+	.trigger = rockchip_mdais_trigger,
+};
+
+static const struct snd_soc_component_driver rockchip_mdais_component = {
+	.name = DAIS_DRV_NAME,
+};
+
+static const struct of_device_id rockchip_mdais_match[] = {
+	{ .compatible = "rockchip,multi-dais", },
+	{ .compatible = "rockchip,rk3308-multi-dais", },
+	{},
+};
+
+static struct snd_soc_dai *rockchip_mdais_find_dai(struct device_node *np)
+{
+	struct snd_soc_dai_link_component dai_component = { 0 };
+
+	dai_component.of_node = np;
+
+	return snd_soc_find_dai(&dai_component);
+}
+
+static int mdais_runtime_suspend(struct device *dev)
+{
+	struct rk_mdais_dev *mdais = dev_get_drvdata(dev);
+	struct snd_soc_dai *child;
+	int i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		pm_runtime_put(child->dev);
+	}
+
+	return 0;
+}
+
+static int mdais_runtime_resume(struct device *dev)
+{
+	struct rk_mdais_dev *mdais = dev_get_drvdata(dev);
+	struct snd_soc_dai *child;
+	int i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		pm_runtime_get_sync(child->dev);
+	}
+
+	return 0;
+}
+
+static int mdais_read_prop_array(struct device_node *node,
+				 const char *propname,
+				 unsigned int *array, int num)
+{
+	int ret = 0;
+
+	memset(array, 0, sizeof(*array) * num);
+	if (of_property_read_bool(node, propname)) {
+		ret = of_property_read_u32_array(node, propname, array, num);
+		if (ret)
+			ret = -EINVAL;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void mdais_parse_daifmt(struct device_node *node, struct rk_dai *dais,
+			       int num_dai)
+{
+	unsigned int cinv[MAX_DAIS], finv[MAX_DAIS];
+	unsigned int cmst[MAX_DAIS], fmst[MAX_DAIS];
+	unsigned int format = 0, format_mask = 0;
+	int i = 0, ret = 0;
+
+	ret = mdais_read_prop_array(node, BITCLOCK_INV_STR, cinv, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_INV_MASK;
+	ret = mdais_read_prop_array(node, FRAME_INV_STR, finv, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_INV_MASK;
+	ret = mdais_read_prop_array(node, BITCLOCK_MASTER_STR, cmst, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_MASTER_MASK;
+	ret = mdais_read_prop_array(node, FRAME_MASTER_STR, fmst, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_MASTER_MASK;
+
+	for (i = 0; i < num_dai; i++) {
+		format = 0;
+
+		switch ((cinv[i] << 4) + finv[i]) {
+		case 0x11:
+			format |= SND_SOC_DAIFMT_IB_IF;
+			break;
+		case 0x10:
+			format |= SND_SOC_DAIFMT_IB_NF;
+			break;
+		case 0x01:
+			format |= SND_SOC_DAIFMT_NB_IF;
+			break;
+		default:
+			/* SND_SOC_DAIFMT_NB_NF is default */
+			break;
+		}
+
+		switch ((!cmst[i] << 4) + !fmst[i]) {
+		case 0x11:
+			format |= SND_SOC_DAIFMT_CBM_CFM;
+			break;
+		case 0x10:
+			format |= SND_SOC_DAIFMT_CBM_CFS;
+			break;
+		case 0x01:
+			format |= SND_SOC_DAIFMT_CBS_CFM;
+			break;
+		default:
+			format |= SND_SOC_DAIFMT_CBS_CFS;
+			break;
+		}
+
+		dais[i].fmt = format & format_mask;
+		dais[i].fmt_msk = format_mask;
+	}
+}
+
+static int rockchip_mdais_dai_prepare(struct platform_device *pdev,
+				      struct snd_soc_dai_driver **soc_dai)
+{
+	struct snd_soc_dai_driver rockchip_mdais_dai = {
+		.probe = rockchip_mdais_dai_probe,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 32,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 32,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rockchip_mdais_dai_ops,
+	};
+
+	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_mdais_dai,
+				sizeof(rockchip_mdais_dai), GFP_KERNEL);
+	if (!(*soc_dai))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void mdais_fixup_dai(struct snd_soc_dai_driver *soc_dai,
+			    struct rk_mdais_dev *mdais)
+{
+	int i, tch, rch;
+	unsigned int *tx_maps, *rx_maps;
+
+	tch = 0;
+	rch = 0;
+	tx_maps = mdais->playback_channel_maps;
+	rx_maps = mdais->capture_channel_maps;
+	for (i = 0; i < mdais->num_dais; i++) {
+		tch += tx_maps[i];
+		rch += rx_maps[i];
+	}
+
+	soc_dai->playback.channels_min = tch;
+	soc_dai->playback.channels_max = tch;
+	soc_dai->capture.channels_min = rch;
+	soc_dai->capture.channels_max = rch;
+}
+
+static int rockchip_mdais_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device  *sub_pdev;
+	struct rk_mdais_dev *mdais;
+	struct device_node *node;
+	struct snd_soc_dai_driver *soc_dai;
+	struct rk_dai *dais;
+	unsigned int *map;
+	int count, mp_count;
+	int ret = 0, i = 0;
+
+	ret = rockchip_mdais_dai_prepare(pdev, &soc_dai);
+	if (ret < 0)
+		return ret;
+
+	mdais = devm_kzalloc(&pdev->dev, sizeof(*mdais), GFP_KERNEL);
+	if (!mdais)
+		return -ENOMEM;
+
+	count = of_count_phandle_with_args(np, "dais", NULL);
+	if (count < 0 || count > MAX_DAIS)
+		return -EINVAL;
+
+	mp_count = of_property_count_u32_elems(np, "capture,channel-mapping");
+	if (mp_count != count)
+		return -EINVAL;
+	mp_count = of_property_count_u32_elems(np, "playback,channel-mapping");
+	if (mp_count != count)
+		return -EINVAL;
+
+	mdais->num_dais = count;
+	dais = devm_kcalloc(&pdev->dev, count,
+			    sizeof(*dais), GFP_KERNEL);
+	if (!dais)
+		return -ENOMEM;
+
+	map = devm_kcalloc(&pdev->dev, count,
+			   sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+	ret = of_property_read_u32_array(np, "capture,channel-mapping",
+					 map, count);
+	if (ret)
+		return -EINVAL;
+	mdais->capture_channel_maps = map;
+	map = devm_kcalloc(&pdev->dev, count,
+			   sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+	ret = of_property_read_u32_array(np, "playback,channel-mapping",
+					 map, count);
+	if (ret)
+		return -EINVAL;
+	mdais->playback_channel_maps = map;
+
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "dais", i);
+		sub_pdev = of_find_device_by_node(node);
+		if (!sub_pdev) {
+			dev_err(&pdev->dev, "fail to find subnode dev\n");
+			return -ENODEV;
+		}
+		dais[i].of_node = node;
+		dais[i].dev = &sub_pdev->dev;
+		dais[i].dai = rockchip_mdais_find_dai(node);
+		if (!dais[i].dai)
+			return -EPROBE_DEFER;
+	}
+
+	mdais_parse_daifmt(np, dais, count);
+	mdais_fixup_dai(soc_dai, mdais);
+
+	if (of_device_is_compatible(np, "rockchip,rk3308-multi-dais")) {
+		struct regmap *grf;
+		const char *name;
+		unsigned int i2s0_fmt = 0, i2s1_fmt = 0;
+
+		for (i = 0; i < count; i++) {
+			name = dev_name(dais[i].dev);
+			if (strstr(name, "ff300000"))
+				i2s0_fmt = dais[i].fmt;
+			else if (strstr(name, "ff310000"))
+				i2s1_fmt = dais[i].fmt;
+		}
+		i2s0_fmt &= SND_SOC_DAIFMT_MASTER_MASK;
+		i2s1_fmt &= SND_SOC_DAIFMT_MASTER_MASK;
+
+		if ((i2s0_fmt == SND_SOC_DAIFMT_CBS_CFS &&
+		     i2s1_fmt == SND_SOC_DAIFMT_CBM_CFM) ||
+		    (i2s0_fmt == SND_SOC_DAIFMT_CBM_CFM &&
+		     i2s1_fmt == SND_SOC_DAIFMT_CBS_CFS)) {
+			grf = syscon_regmap_lookup_by_phandle(np,
+							      "rockchip,grf");
+			if (IS_ERR(grf))
+				return PTR_ERR(grf);
+
+			dev_info(&pdev->dev, "enable i2s 16ch ctrl en\n");
+			regmap_write(grf, RK3308_GRF_SOC_CON2,
+				     BIT(14) << 16 | BIT(14));
+		}
+	}
+
+	mdais->dais = dais;
+	mdais->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, mdais);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = mdais_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_mdais_component,
+					      soc_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "could not register dai: %d\n", ret);
+		goto err_suspend;
+	}
+
+	ret = snd_dmaengine_mpcm_register(mdais);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		return ret;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mdais_runtime_resume(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_mdais_remove(struct platform_device *pdev)
+{
+	snd_dmaengine_mpcm_unregister(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mdais_runtime_suspend(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_mdais_pm_ops = {
+	SET_RUNTIME_PM_OPS(mdais_runtime_suspend, mdais_runtime_resume,
+			   NULL)
+};
+
+static struct platform_driver rockchip_mdais_driver = {
+	.probe = rockchip_mdais_probe,
+	.remove = rockchip_mdais_remove,
+	.driver = {
+		.name = DAIS_DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_mdais_match),
+		.pm = &rockchip_mdais_pm_ops,
+	},
+};
+module_platform_driver(rockchip_mdais_driver);
+
+MODULE_DESCRIPTION("ROCKCHIP MULTI-DAIS ASoC Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DAIS_DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_mdais_match);
diff --git a/sound/soc/rockchip/rockchip_multi_dais.h b/sound/soc/rockchip/rockchip_multi_dais.h
new file mode 100644
index 000000000..5d9a076af
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_multi_dais.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip MULTI DAIS driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_MULTI_DAIS_H
+#define _ROCKCHIP_MULTI_DAIS_H
+
+#define MAX_DAIS 4
+
+struct rk_dai {
+	struct device *dev;
+	struct device_node *of_node;
+	struct snd_soc_dai *dai;
+	unsigned int fmt;
+	unsigned int fmt_msk;
+};
+
+struct rk_mdais_dev {
+	struct device *dev;
+	struct rk_dai *dais;
+	unsigned int *playback_channel_maps;
+	unsigned int *capture_channel_maps;
+	int num_dais;
+};
+
+int snd_dmaengine_mpcm_register(struct rk_mdais_dev *mdais);
+void snd_dmaengine_mpcm_unregister(struct device *dev);
+
+#endif
diff --git a/sound/soc/rockchip/rockchip_multi_dais_pcm.c b/sound/soc/rockchip/rockchip_multi_dais_pcm.c
new file mode 100644
index 000000000..38f2220ee
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_multi_dais_pcm.c
@@ -0,0 +1,704 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip Multi-DAIS-PCM driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rockchip_multi_dais.h"
+
+#define MAX_FIFO_SIZE	32 /* max fifo size in frames */
+
+struct dmaengine_mpcm {
+	struct rk_mdais_dev *mdais;
+	struct dma_chan *tx_chans[MAX_DAIS];
+	struct dma_chan *rx_chans[MAX_DAIS];
+	struct snd_soc_platform platform;
+};
+
+struct dmaengine_mpcm_runtime_data {
+	struct dma_chan *chans[MAX_DAIS];
+	dma_cookie_t cookies[MAX_DAIS];
+	unsigned int *channel_maps;
+	int num_chans;
+	unsigned int pos;
+	unsigned int master_chan;
+	bool start_flag;
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	unsigned int vpos;
+	unsigned int vresidue_bytes;
+#endif
+};
+
+static inline struct dmaengine_mpcm_runtime_data *substream_to_prtd(
+	const struct snd_pcm_substream *substream)
+{
+	return substream->runtime->private_data;
+}
+
+static struct dmaengine_mpcm *soc_platform_to_pcm(struct snd_soc_platform *p)
+{
+	return container_of(p, struct dmaengine_mpcm, platform);
+}
+
+static struct dma_chan *to_chan(struct dmaengine_mpcm *pcm,
+				struct snd_pcm_substream *substream)
+{
+	struct dma_chan *chan = NULL;
+	int i;
+
+	for (i = 0; i < pcm->mdais->num_dais; i++) {
+		chan = substream->stream ? pcm->rx_chans[i] : pcm->tx_chans[i];
+		if (chan)
+			break;
+	}
+
+	return chan;
+}
+
+static struct device *dmaengine_dma_dev(struct dmaengine_mpcm *pcm,
+					struct snd_pcm_substream *substream)
+{
+	struct dma_chan *chan;
+
+	chan = to_chan(pcm, substream);
+	if (!chan)
+		return NULL;
+
+	return chan->device->dev;
+}
+
+static void snd_dmaengine_mpcm_set_config_from_dai_data(
+	const struct snd_pcm_substream *substream,
+	const struct snd_dmaengine_dai_dma_data *dma_data,
+	struct dma_slave_config *slave_config)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config->dst_addr = dma_data->addr;
+		if (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)
+			slave_config->dst_addr_width = dma_data->addr_width;
+	} else {
+		slave_config->src_addr = dma_data->addr;
+		if (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)
+			slave_config->src_addr_width = dma_data->addr_width;
+	}
+
+	slave_config->slave_id = dma_data->slave_id;
+}
+
+static void dmaengine_mpcm_dma_complete(void *arg)
+{
+	struct snd_pcm_substream *substream = arg;
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+
+	if (snd_pcm_vad_attached(substream) &&
+	    substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		void *buf = substream->runtime->dma_area + prtd->pos;
+
+		snd_pcm_vad_preprocess(substream, buf,
+				       substream->runtime->period_size);
+	}
+
+	prtd->pos += snd_pcm_lib_period_bytes(substream);
+	if (prtd->pos >= snd_pcm_lib_buffer_bytes(substream))
+		prtd->pos = 0;
+
+#endif
+	snd_pcm_period_elapsed(substream);
+}
+
+static int dmaengine_mpcm_prepare_and_submit(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_async_tx_descriptor *desc;
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	unsigned int *maps = prtd->channel_maps;
+	int offset, buffer_bytes, period_bytes;
+	int i;
+	bool callback = false;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	prtd->pos = 0;
+	offset = 0;
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (!prtd->chans[i])
+			continue;
+		desc = dmaengine_prep_dma_cyclic(prtd->chans[i],
+						 runtime->dma_addr + offset,
+						 buffer_bytes, period_bytes,
+						 direction, flags);
+
+		if (!desc)
+			return -ENOMEM;
+		if (!callback) {
+			desc->callback = dmaengine_mpcm_dma_complete;
+			desc->callback_param = substream;
+			callback = true;
+			prtd->master_chan = i;
+		}
+		prtd->cookies[i] = dmaengine_submit(desc);
+		offset += samples_to_bytes(runtime, maps[i]);
+	}
+
+	return 0;
+}
+
+static void mpcm_dma_async_issue_pending(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dma_async_issue_pending(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_resume(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_resume(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_pause(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_pause(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_terminate_all(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_terminate_all(prtd->chans[i]);
+	}
+}
+
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+static void dmaengine_mpcm_single_dma_complete(void *arg)
+{
+	struct snd_pcm_substream *substream = arg;
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	unsigned int pos, size;
+	void *buf;
+
+	if (snd_pcm_vad_attached(substream) &&
+	    substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		buf = substream->runtime->dma_area + prtd->vpos;
+		pos = prtd->vpos + snd_pcm_lib_period_bytes(substream);
+
+		if (pos <= snd_pcm_lib_buffer_bytes(substream))
+			size = substream->runtime->period_size;
+		else
+			size = bytes_to_frames(substream->runtime,
+					       prtd->vresidue_bytes);
+		snd_pcm_vad_preprocess(substream, buf, size);
+	}
+
+	prtd->vpos += snd_pcm_lib_period_bytes(substream);
+	if (prtd->vpos >= snd_pcm_lib_buffer_bytes(substream))
+		prtd->vpos = 0;
+	snd_pcm_period_elapsed(substream);
+}
+
+static int __mpcm_prepare_single_and_submit(struct snd_pcm_substream *substream,
+					    dma_addr_t buf_start, int size)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_async_tx_descriptor *desc;
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	unsigned int *maps = prtd->channel_maps;
+	int offset, i;
+	bool callback = false;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	offset = 0;
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (!prtd->chans[i])
+			continue;
+		desc = dmaengine_prep_slave_single(prtd->chans[i],
+						   buf_start + offset,
+						   size,
+						   direction, flags);
+
+		if (!desc)
+			return -ENOMEM;
+		if (!callback) {
+			desc->callback = dmaengine_mpcm_single_dma_complete;
+			desc->callback_param = substream;
+			callback = true;
+		}
+		dmaengine_submit(desc);
+		offset += samples_to_bytes(runtime, maps[i]);
+	}
+
+	return 0;
+}
+
+static int dmaengine_mpcm_prepare_single_and_submit(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	snd_pcm_uframes_t avail;
+	dma_addr_t buf_start, buf_end;
+	int offset, i, count, ret;
+	int buffer_bytes, period_bytes, residue_bytes;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	avail = snd_pcm_vad_avail(substream);
+	offset = frames_to_bytes(substream->runtime, avail);
+	prtd->vpos = offset;
+	buf_start = substream->runtime->dma_addr + offset;
+	buf_end = substream->runtime->dma_addr + snd_pcm_lib_buffer_bytes(substream);
+	count = (buf_end - buf_start) / period_bytes;
+	residue_bytes = (buf_end - buf_start) % period_bytes;
+	prtd->vresidue_bytes = residue_bytes;
+	pr_debug("%s: offset: %d, buffer_bytes: %d\n", __func__, offset, buffer_bytes);
+	pr_debug("%s: count: %d, residue_bytes: %d\n", __func__, count, residue_bytes);
+	for (i = 0; i < count; i++) {
+		ret = __mpcm_prepare_single_and_submit(substream, buf_start,
+						       period_bytes);
+		if (ret)
+			return ret;
+		buf_start += period_bytes;
+	}
+
+	if (residue_bytes) {
+		ret = __mpcm_prepare_single_and_submit(substream, buf_start,
+						       residue_bytes);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int snd_dmaengine_mpcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		    snd_pcm_vad_attached(substream) &&
+		    snd_pcm_vad_avail(substream)) {
+			dmaengine_mpcm_prepare_single_and_submit(substream);
+			mpcm_dma_async_issue_pending(prtd);
+		}
+#endif
+		ret = dmaengine_mpcm_prepare_and_submit(substream);
+		if (ret)
+			return ret;
+		mpcm_dma_async_issue_pending(prtd);
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		mpcm_dmaengine_resume(prtd);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (runtime->info & SNDRV_PCM_INFO_PAUSE)
+			mpcm_dmaengine_pause(prtd);
+		else
+			mpcm_dmaengine_terminate_all(prtd);
+		prtd->start_flag = false;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		mpcm_dmaengine_pause(prtd);
+		prtd->start_flag = false;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		mpcm_dmaengine_terminate_all(prtd);
+		prtd->start_flag = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dmaengine_mpcm_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *chan;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	struct dma_slave_config slave_config;
+	snd_pcm_format_t format;
+	unsigned int *maps;
+	int frame_bytes;
+	int ret, num, i, sz;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		maps = pcm->mdais->playback_channel_maps;
+	else
+		maps = pcm->mdais->capture_channel_maps;
+	format = params_format(params);
+	frame_bytes = snd_pcm_format_size(format, params_channels(params));
+	num = pcm->mdais->num_dais;
+
+	for (i = 0; i < num; i++) {
+		memset(&slave_config, 0, sizeof(slave_config));
+		ret = snd_hwparams_to_dma_slave_config(substream, params,
+						       &slave_config);
+		if (ret)
+			return ret;
+
+		dma_data = snd_soc_dai_get_dma_data(pcm->mdais->dais[i].dai,
+						    substream);
+		if (!dma_data)
+			continue;
+
+		snd_dmaengine_mpcm_set_config_from_dai_data(substream,
+							    dma_data,
+							    &slave_config);
+
+		/* refine params for interlace access */
+		sz = snd_pcm_format_size(format, maps[i]);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			chan = pcm->tx_chans[i];
+			if (sz) {
+				slave_config.src_interlace_size = frame_bytes - sz;
+				if (slave_config.src_interlace_size)
+					slave_config.dst_maxburst = sz / slave_config.dst_addr_width;
+			}
+		} else {
+			chan = pcm->rx_chans[i];
+			if (sz) {
+				slave_config.dst_interlace_size = frame_bytes - sz;
+				if (slave_config.dst_interlace_size)
+					slave_config.src_maxburst = sz / slave_config.src_addr_width;
+			}
+		}
+		if (!chan)
+			continue;
+
+		ret = dmaengine_slave_config(chan, &slave_config);
+		if (ret)
+			return ret;
+	}
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+}
+
+static int dmaengine_mpcm_set_runtime_hwparams(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct device *dma_dev = dmaengine_dma_dev(pcm, substream);
+	struct dma_chan *chan;
+	struct dma_slave_caps dma_caps;
+	struct snd_pcm_hardware hw;
+	u32 addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+			  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+			  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);
+	int i, ret;
+
+	chan = to_chan(pcm, substream);
+	if (!chan)
+		return -EINVAL;
+
+	memset(&hw, 0, sizeof(hw));
+	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_INTERLEAVED;
+	hw.periods_min = 2;
+	hw.periods_max = UINT_MAX;
+	hw.period_bytes_min = 256;
+	hw.period_bytes_max = dma_get_max_seg_size(dma_dev);
+	hw.buffer_bytes_max = SIZE_MAX;
+
+	ret = dma_get_slave_caps(chan, &dma_caps);
+	if (ret == 0) {
+		if (dma_caps.cmd_pause)
+			hw.info |= SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME;
+		if (dma_caps.residue_granularity <= DMA_RESIDUE_GRANULARITY_SEGMENT)
+			hw.info |= SNDRV_PCM_INFO_BATCH;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			addr_widths = dma_caps.dst_addr_widths;
+		else
+			addr_widths = dma_caps.src_addr_widths;
+	}
+
+	/*
+	 * Prepare formats mask for valid/allowed sample types. If the dma does
+	 * not have support for the given physical word size, it needs to be
+	 * masked out so user space can not use the format which produces
+	 * corrupted audio.
+	 * In case the dma driver does not implement the slave_caps the default
+	 * assumption is that it supports 1, 2 and 4 bytes widths.
+	 */
+	for (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {
+		int bits = snd_pcm_format_physical_width(i);
+
+		/* Enable only samples with DMA supported physical widths */
+		switch (bits) {
+		case 8:
+		case 16:
+		case 24:
+		case 32:
+		case 64:
+			if (addr_widths & (1 << (bits / 8)))
+				hw.formats |= (1LL << i);
+			break;
+		default:
+			/* Unsupported types */
+			break;
+		}
+	}
+
+	return snd_soc_set_runtime_hwparams(substream, &hw);
+}
+
+static int dmaengine_mpcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dmaengine_mpcm_runtime_data *prtd;
+	int ret, i;
+
+	ret = dmaengine_mpcm_set_runtime_hwparams(substream);
+	if (ret)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (!prtd)
+		return -ENOMEM;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prtd->channel_maps = pcm->mdais->playback_channel_maps;
+		for (i = 0; i < pcm->mdais->num_dais; i++)
+			prtd->chans[i] = pcm->tx_chans[i];
+	} else {
+		prtd->channel_maps = pcm->mdais->capture_channel_maps;
+		for (i = 0; i < pcm->mdais->num_dais; i++)
+			prtd->chans[i] = pcm->rx_chans[i];
+	}
+
+	prtd->num_chans = pcm->mdais->num_dais;
+	prtd->start_flag = false;
+	substream->runtime->private_data = prtd;
+
+	return 0;
+}
+
+static int dmaengine_mpcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct snd_pcm_substream *substream;
+	size_t prealloc_buffer_size;
+	size_t max_buffer_size;
+	unsigned int i;
+	int ret;
+
+	prealloc_buffer_size = 512 * 1024;
+	max_buffer_size = SIZE_MAX;
+
+	for (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {
+		substream = rtd->pcm->streams[i].substream;
+		if (!substream)
+			continue;
+
+		ret = snd_pcm_lib_preallocate_pages(substream,
+						    SNDRV_DMA_TYPE_DEV_IRAM,
+						    dmaengine_dma_dev(pcm, substream),
+						    prealloc_buffer_size,
+						    max_buffer_size);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t dmaengine_mpcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_tx_state state;
+	snd_pcm_uframes_t frames;
+	unsigned int buf_size;
+	unsigned int pos = 0;
+	unsigned int master = prtd->master_chan;
+
+	buf_size = snd_pcm_lib_buffer_bytes(substream);
+	dmaengine_tx_status(prtd->chans[master], prtd->cookies[master], &state);
+	if (state.residue > 0 && state.residue <= buf_size)
+		pos = buf_size - state.residue;
+
+	frames = bytes_to_frames(substream->runtime, pos);
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	if (prtd->vpos)
+		frames = bytes_to_frames(substream->runtime, prtd->vpos);
+#endif
+	if (!prtd->start_flag && frames >= MAX_FIFO_SIZE)
+		prtd->start_flag = true;
+
+	if (prtd->start_flag) {
+		if (frames >= MAX_FIFO_SIZE)
+			frames -= MAX_FIFO_SIZE;
+		else
+			frames = runtime->buffer_size + frames - MAX_FIFO_SIZE;
+	} else {
+		frames = 0;
+	}
+
+	return frames;
+}
+
+static int dmaengine_mpcm_close(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static const struct snd_pcm_ops dmaengine_mpcm_ops = {
+	.open		= dmaengine_mpcm_open,
+	.close		= dmaengine_mpcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= dmaengine_mpcm_hw_params,
+	.hw_free	= snd_pcm_lib_free_pages,
+	.trigger	= snd_dmaengine_mpcm_trigger,
+	.pointer	= dmaengine_mpcm_pointer,
+};
+
+static const struct snd_soc_platform_driver dmaengine_mpcm_platform = {
+	.component_driver = {
+		.probe_order = SND_SOC_COMP_ORDER_LATE,
+	},
+	.ops		= &dmaengine_mpcm_ops,
+	.pcm_new	= dmaengine_mpcm_new,
+};
+
+static void dmaengine_mpcm_release_chan(struct dmaengine_mpcm *pcm)
+{
+	int i;
+
+	for (i = 0; i < pcm->mdais->num_dais; i++) {
+		if (pcm->tx_chans[i])
+			dma_release_channel(pcm->tx_chans[i]);
+		if (pcm->rx_chans[i])
+			dma_release_channel(pcm->rx_chans[i]);
+	}
+}
+
+int snd_dmaengine_mpcm_register(struct rk_mdais_dev *mdais)
+{
+	struct device *dev;
+	struct device *child;
+	struct dmaengine_mpcm *pcm;
+	struct dma_chan *chan;
+	unsigned int *tx_maps, *rx_maps;
+	int ret, i, num;
+
+	dev = mdais->dev;
+	num = mdais->num_dais;
+	tx_maps = mdais->playback_channel_maps;
+	rx_maps = mdais->capture_channel_maps;
+	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
+	if (!pcm)
+		return -ENOMEM;
+
+	pcm->mdais = mdais;
+	for (i = 0; i < num; i++) {
+		child = mdais->dais[i].dev;
+		if (tx_maps[i]) {
+			chan = dma_request_slave_channel_reason(child, "tx");
+			if (IS_ERR(chan))
+				chan = NULL;
+			pcm->tx_chans[i] = chan;
+		}
+
+		if (rx_maps[i]) {
+			chan = dma_request_slave_channel_reason(child, "rx");
+			if (IS_ERR(chan))
+				chan = NULL;
+			pcm->rx_chans[i] = chan;
+		}
+	}
+
+	ret = snd_soc_add_platform(dev, &pcm->platform,
+				   &dmaengine_mpcm_platform);
+	if (ret)
+		goto err_free_dma;
+
+	return 0;
+
+err_free_dma:
+	dmaengine_mpcm_release_chan(pcm);
+	kfree(pcm);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_dmaengine_mpcm_register);
+
+void snd_dmaengine_mpcm_unregister(struct device *dev)
+{
+	struct snd_soc_platform *platform;
+	struct dmaengine_mpcm *pcm;
+
+	platform = snd_soc_lookup_platform(dev);
+	if (!platform)
+		return;
+
+	pcm = soc_platform_to_pcm(platform);
+
+	snd_soc_remove_platform(platform);
+	dmaengine_mpcm_release_chan(pcm);
+	kfree(pcm);
+}
+EXPORT_SYMBOL_GPL(snd_dmaengine_mpcm_unregister);
+
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/rockchip/rockchip_multicodecs.c b/sound/soc/rockchip/rockchip_multicodecs.c
new file mode 100644
index 000000000..9486a2e5d
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_multicodecs.c
@@ -0,0 +1,809 @@
+/*
+ * Rockchip machine ASoC driver for Rockchip Multi-codecs audio
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Authors: Sugar Zhang <sugar.zhang@rock-chips.com>,
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/extcon-provider.h>
+#include <linux/gpio.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/iio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#define DRV_NAME "rk-multicodecs"
+#define MAX_CODECS	2
+#define WAIT_CARDS	(SNDRV_CARDS - 1)
+#define DEFAULT_MCLK_FS	256
+
+struct adc_keys_button {
+	u32 voltage;
+	u32 keycode;
+};
+
+struct input_dev_poller {
+	void (*poll)(struct input_dev *dev);
+
+	unsigned int poll_interval_ms;
+	struct input_dev *input;
+	struct delayed_work work;
+};
+
+struct multicodecs_data {
+	struct snd_soc_card snd_card;
+	struct snd_soc_dai_link dai_link;
+	struct snd_soc_jack *jack_headset;
+	struct gpio_desc *hp_ctl_gpio;
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *hp_det_gpio;
+	struct iio_channel *adc;
+	struct extcon_dev *extcon;
+	struct delayed_work handler;
+	unsigned int mclk_fs;
+	bool codec_hp_det;
+	u32 num_keys;
+	u32 last_key;
+	u32 keyup_voltage;
+	const struct adc_keys_button *map;
+	struct input_dev *input;
+	struct input_dev_poller *poller;
+};
+
+static struct snd_soc_jack_pin jack_pins[] = {
+	{
+		.pin = "Headphone",
+		.mask = SND_JACK_HEADPHONE,
+	}, {
+		.pin = "Headset Mic",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+
+static struct snd_soc_jack_zone headset_zones[] = {
+	{
+		.min_mv = 0,
+		.max_mv = 222,
+		.jack_type = SND_JACK_HEADPHONE,
+	}, {
+		.min_mv = 223,
+		.max_mv = 1500,
+		.jack_type = SND_JACK_HEADSET,
+	}, {
+		.min_mv = 1501,
+		.max_mv = UINT_MAX,
+		.jack_type = SND_JACK_HEADPHONE,
+	}
+};
+
+static const unsigned int headset_extcon_cable[] = {
+	EXTCON_JACK_MICROPHONE,
+	EXTCON_JACK_HEADPHONE,
+	EXTCON_NONE,
+};
+
+static void mc_set_poll_interval(struct input_dev_poller *poller, unsigned int interval)
+{
+	if (poller)
+		poller->poll_interval_ms = interval;
+}
+
+static void mc_keys_poller_queue_work(struct input_dev_poller *poller)
+{
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(poller->poll_interval_ms);
+	if (delay >= HZ)
+		delay = round_jiffies_relative(delay);
+
+	queue_delayed_work(system_freezable_wq, &poller->work, delay);
+}
+
+static void mc_keys_poller_work(struct work_struct *work)
+{
+	struct input_dev_poller *poller =
+		container_of(work, struct input_dev_poller, work.work);
+
+	poller->poll(poller->input);
+	mc_keys_poller_queue_work(poller);
+}
+
+static void mc_keys_poller_start(struct input_dev_poller *poller)
+{
+	if (poller->poll_interval_ms > 0) {
+		poller->poll(poller->input);
+		mc_keys_poller_queue_work(poller);
+	}
+}
+
+static void mc_keys_poller_stop(struct input_dev_poller *poller)
+{
+	cancel_delayed_work_sync(&poller->work);
+}
+
+static int mc_keys_setup_polling(struct multicodecs_data *mc_data,
+				 void (*poll_fn)(struct input_dev *dev))
+{
+	struct input_dev_poller *poller;
+
+	poller = devm_kzalloc(mc_data->snd_card.dev, sizeof(*poller), GFP_KERNEL);
+	if (!poller)
+		return -ENOMEM;
+
+	INIT_DELAYED_WORK(&poller->work, mc_keys_poller_work);
+	poller->input = mc_data->input;
+	poller->poll = poll_fn;
+	mc_data->poller = poller;
+
+	return 0;
+}
+
+static void mc_keys_poll(struct input_dev *input)
+{
+	struct multicodecs_data *mc_data = input_get_drvdata(input);
+	int i, value, ret;
+	u32 diff, closest = 0xffffffff;
+	int keycode = 0;
+
+	ret = iio_read_channel_processed(mc_data->adc, &value);
+	if (unlikely(ret < 0)) {
+		/* Forcibly release key if any was pressed */
+		value = mc_data->keyup_voltage;
+	} else {
+		for (i = 0; i < mc_data->num_keys; i++) {
+			diff = abs(mc_data->map[i].voltage - value);
+			if (diff < closest) {
+				closest = diff;
+				keycode = mc_data->map[i].keycode;
+			}
+		}
+	}
+
+	if (abs(mc_data->keyup_voltage - value) < closest)
+		keycode = 0;
+
+	if (mc_data->last_key && mc_data->last_key != keycode)
+		input_report_key(input, mc_data->last_key, 0);
+
+	if (keycode)
+		input_report_key(input, keycode, 1);
+
+	input_sync(input);
+	mc_data->last_key = keycode;
+}
+
+static int mc_keys_load_keymap(struct device *dev,
+			       struct multicodecs_data *mc_data)
+{
+	struct adc_keys_button *map;
+	struct fwnode_handle *child;
+	int i = 0;
+
+	mc_data->num_keys = device_get_child_node_count(dev);
+	if (mc_data->num_keys == 0) {
+		dev_err(dev, "keymap is missing\n");
+		return -EINVAL;
+	}
+
+	map = devm_kmalloc_array(dev, mc_data->num_keys, sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+
+	device_for_each_child_node(dev, child) {
+		if (fwnode_property_read_u32(child, "press-threshold-microvolt",
+					     &map[i].voltage)) {
+			dev_err(dev, "Key with invalid or missing voltage\n");
+			fwnode_handle_put(child);
+			return -EINVAL;
+		}
+		map[i].voltage /= 1000;
+
+		if (fwnode_property_read_u32(child, "linux,code",
+					     &map[i].keycode)) {
+			dev_err(dev, "Key with invalid or missing linux,code\n");
+			fwnode_handle_put(child);
+			return -EINVAL;
+		}
+
+		i++;
+	}
+	mc_data->map = map;
+	return 0;
+}
+
+static void adc_jack_handler(struct work_struct *work)
+{
+	struct multicodecs_data *mc_data = container_of(to_delayed_work(work),
+						  struct multicodecs_data,
+						  handler);
+	struct snd_soc_jack *jack_headset = mc_data->jack_headset;
+	int adc, ret = 0;
+
+	if (!gpiod_get_value(mc_data->hp_det_gpio)) {
+		snd_soc_jack_report(jack_headset, 0, SND_JACK_HEADSET);
+		extcon_set_state_sync(mc_data->extcon,
+				EXTCON_JACK_HEADPHONE, false);
+		extcon_set_state_sync(mc_data->extcon,
+				EXTCON_JACK_MICROPHONE, false);
+		if (mc_data->poller)
+			mc_keys_poller_stop(mc_data->poller);
+
+		return;
+	}
+	if (!mc_data->adc) {
+		/* no ADC, so is headphone */
+		snd_soc_jack_report(jack_headset, SND_JACK_HEADPHONE, SND_JACK_HEADSET);
+		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_HEADPHONE, true);
+		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_MICROPHONE, false);
+		return;
+	}
+	ret = iio_read_channel_processed(mc_data->adc, &adc);
+	if (ret < 0) {
+		/* failed to read ADC, so assume headphone */
+		snd_soc_jack_report(jack_headset, SND_JACK_HEADPHONE, SND_JACK_HEADSET);
+		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_HEADPHONE, true);
+		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_MICROPHONE, false);
+
+	} else {
+		snd_soc_jack_report(jack_headset,
+				    snd_soc_jack_get_type(jack_headset, adc),
+				    SND_JACK_HEADSET);
+		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_HEADPHONE, true);
+
+		if (snd_soc_jack_get_type(jack_headset, adc) == SND_JACK_HEADSET) {
+			extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_MICROPHONE, true);
+			if (mc_data->poller)
+				mc_keys_poller_start(mc_data->poller);
+		}
+	}
+};
+
+static irqreturn_t headset_det_irq_thread(int irq, void *data)
+{
+	struct multicodecs_data *mc_data = (struct multicodecs_data *)data;
+
+	queue_delayed_work(system_power_efficient_wq, &mc_data->handler, msecs_to_jiffies(200));
+
+	return IRQ_HANDLED;
+};
+
+static int mc_hp_event(struct snd_soc_dapm_widget *w,
+		       struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_card *card = w->dapm->card;
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(card);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, 1);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, 0);
+		break;
+	default:
+		return 0;
+
+	}
+
+	return 0;
+}
+
+static int mc_spk_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_card *card = w->dapm->card;
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(card);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		gpiod_set_value_cansleep(mc_data->spk_ctl_gpio, 1);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		gpiod_set_value_cansleep(mc_data->spk_ctl_gpio, 0);
+		break;
+	default:
+		return 0;
+
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget mc_dapm_widgets[] = {
+
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_SUPPLY("Speaker Power",
+			    SND_SOC_NOPM, 0, 0,
+			    mc_spk_event,
+			    SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_SUPPLY("Headphone Power",
+			    SND_SOC_NOPM, 0, 0,
+			    mc_hp_event,
+			    SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_kcontrol_new mc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Speaker"),
+	SOC_DAPM_PIN_SWITCH("Main Mic"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+};
+
+static int rk_multicodecs_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+	unsigned int mclk;
+	int ret;
+
+	mclk = params_rate(params) * mc_data->mclk_fs;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set codec_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set cpu_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static int rk_dailink_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_jack *jack_headset;
+	int ret, irq;
+
+	jack_headset = devm_kzalloc(card->dev, sizeof(*jack_headset), GFP_KERNEL);
+	if (!jack_headset)
+		return -ENOMEM;
+
+	ret = snd_soc_card_jack_new(card, "Headset",
+				    SND_JACK_HEADSET,
+				    jack_headset,
+				    jack_pins, ARRAY_SIZE(jack_pins));
+	if (ret)
+		return ret;
+	ret = snd_soc_jack_add_zones(jack_headset, ARRAY_SIZE(headset_zones),
+				     headset_zones);
+	if (ret)
+		return ret;
+
+	mc_data->jack_headset = jack_headset;
+
+	if (mc_data->codec_hp_det) {
+		struct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;
+
+		snd_soc_component_set_jack(component, jack_headset, NULL);
+	} else {
+		irq = gpiod_to_irq(mc_data->hp_det_gpio);
+		if (irq >= 0) {
+			ret = devm_request_threaded_irq(card->dev, irq, NULL,
+							headset_det_irq_thread,
+							IRQF_TRIGGER_RISING |
+							IRQF_TRIGGER_FALLING |
+							IRQF_ONESHOT,
+							"headset_detect",
+							mc_data);
+			if (ret) {
+				dev_err(card->dev, "Failed to request headset detect irq");
+				return ret;
+			}
+
+			queue_delayed_work(system_power_efficient_wq,
+					   &mc_data->handler, msecs_to_jiffies(50));
+		} else {
+			dev_warn(card->dev, "Failed to map headset detect gpio to irq");
+		}
+	}
+
+	return 0;
+}
+
+static int rk_multicodecs_parse_daifmt(struct device_node *node,
+				       struct device_node *codec,
+				       struct multicodecs_data *mc_data,
+				       const char *prefix)
+{
+	struct snd_soc_dai_link *dai_link = &mc_data->dai_link;
+	struct device_node *bitclkmaster = NULL;
+	struct device_node *framemaster = NULL;
+	unsigned int daifmt;
+
+	daifmt = snd_soc_of_parse_daifmt(node, prefix,
+					 &bitclkmaster, &framemaster);
+
+	daifmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+
+	if (strlen(prefix) && !bitclkmaster && !framemaster) {
+		/*
+		 * No dai-link level and master setting was not found from
+		 * sound node level, revert back to legacy DT parsing and
+		 * take the settings from codec node.
+		 */
+		pr_debug("%s: Revert to legacy daifmt parsing\n", __func__);
+
+		daifmt = snd_soc_of_parse_daifmt(codec, NULL, NULL, NULL) |
+			(daifmt & ~SND_SOC_DAIFMT_CLOCK_MASK);
+	} else {
+		if (codec == bitclkmaster)
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBM_CFM : SND_SOC_DAIFMT_CBM_CFS;
+		else
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBS_CFM : SND_SOC_DAIFMT_CBS_CFS;
+	}
+
+	/*
+	 * If there is NULL format means that the format isn't specified, we
+	 * need to set i2s format by default.
+	 */
+	if (!(daifmt & SND_SOC_DAIFMT_FORMAT_MASK))
+		daifmt |= SND_SOC_DAIFMT_I2S;
+
+	dai_link->dai_fmt = daifmt;
+
+	of_node_put(bitclkmaster);
+	of_node_put(framemaster);
+
+	return 0;
+}
+
+static int wait_locked_card(struct device_node *np, struct device *dev)
+{
+	char *propname = "rockchip,wait-card-locked";
+	u32 cards[WAIT_CARDS];
+	int num;
+	int ret;
+#ifndef MODULE
+	int i;
+#endif
+
+	ret = of_property_count_u32_elems(np, propname);
+	if (ret < 0) {
+		if (ret == -EINVAL) {
+			/*
+			 * -EINVAL means the property does not exist, this is
+			 * fine.
+			 */
+			return 0;
+		}
+
+		dev_err(dev, "Property '%s' elems could not be read: %d\n",
+			propname, ret);
+		return ret;
+	}
+
+	num = ret;
+	if (num > WAIT_CARDS)
+		num = WAIT_CARDS;
+
+	ret = of_property_read_u32_array(np, propname, cards, num);
+	if (ret < 0) {
+		if (ret == -EINVAL) {
+			/*
+			 * -EINVAL means the property does not exist, this is
+			 * fine.
+			 */
+			return 0;
+		}
+
+		dev_err(dev, "Property '%s' could not be read: %d\n",
+			propname, ret);
+		return ret;
+	}
+
+	ret = 0;
+#ifndef MODULE
+	for (i = 0; i < num; i++) {
+		if (!snd_card_locked(cards[i])) {
+			dev_warn(dev, "card: %d has not been locked, re-probe again\n",
+				 cards[i]);
+			ret = -EPROBE_DEFER;
+			break;
+		}
+	}
+#endif
+
+	return ret;
+}
+
+static struct snd_soc_ops rk_ops = {
+	.hw_params = rk_multicodecs_hw_params,
+};
+
+static int rk_multicodecs_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_dai_link_component *cpus;
+	struct snd_soc_dai_link_component *platforms;
+	struct snd_soc_dai_link_component *codecs;
+	struct multicodecs_data *mc_data;
+	struct of_phandle_args args;
+	struct device_node *node;
+	struct input_dev *input;
+	u32 val;
+	int count, value;
+	int ret = 0, i = 0, idx = 0;
+	const char *prefix = "rockchip,";
+
+	ret = wait_locked_card(np, &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "check_lock_card failed: %d\n", ret);
+		return ret;
+	}
+
+	mc_data = devm_kzalloc(&pdev->dev, sizeof(*mc_data), GFP_KERNEL);
+	if (!mc_data)
+		return -ENOMEM;
+
+	cpus = devm_kzalloc(&pdev->dev, sizeof(*cpus), GFP_KERNEL);
+	if (!cpus)
+		return -ENOMEM;
+
+	platforms = devm_kzalloc(&pdev->dev, sizeof(*platforms), GFP_KERNEL);
+	if (!platforms)
+		return -ENOMEM;
+
+	card = &mc_data->snd_card;
+	card->dev = &pdev->dev;
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "rockchip,card-name");
+	if (ret < 0)
+		return ret;
+
+	link = &mc_data->dai_link;
+	link->name = "dailink-multicodecs";
+	link->stream_name = link->name;
+	link->init = rk_dailink_init;
+	link->ops = &rk_ops;
+	link->cpus = cpus;
+	link->platforms	= platforms;
+	link->num_cpus	= 1;
+	link->num_platforms = 1;
+	link->ignore_pmdown_time = 1;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->dapm_widgets = mc_dapm_widgets;
+	card->num_dapm_widgets = ARRAY_SIZE(mc_dapm_widgets);
+	card->controls = mc_controls;
+	card->num_controls = ARRAY_SIZE(mc_controls);
+	card->num_aux_devs = 0;
+
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (of_device_is_available(node))
+			idx++;
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	link->codecs = codecs;
+	link->num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (!of_device_is_available(node))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret)
+			return ret;
+
+		codecs[idx].of_node = node;
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	/* Only reference the codecs[0].of_node which maybe as master. */
+	rk_multicodecs_parse_daifmt(np, codecs[0].of_node, mc_data, prefix);
+
+	link->cpus->of_node = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!link->cpus->of_node)
+		return -ENODEV;
+
+	link->platforms->of_node = link->cpus->of_node;
+
+	mc_data->mclk_fs = DEFAULT_MCLK_FS;
+	if (!of_property_read_u32(np, "rockchip,mclk-fs", &val))
+		mc_data->mclk_fs = val;
+
+	mc_data->codec_hp_det =
+		of_property_read_bool(np, "rockchip,codec-hp-det");
+
+	mc_data->adc = devm_iio_channel_get(&pdev->dev, "adc-detect");
+
+	if (IS_ERR(mc_data->adc)) {
+		if (PTR_ERR(mc_data->adc) != -EPROBE_DEFER) {
+			mc_data->adc = NULL;
+			dev_warn(&pdev->dev, "Failed to get ADC channel");
+		}
+	} else {
+		if (mc_data->adc->channel->type != IIO_VOLTAGE)
+			return -EINVAL;
+
+		if (device_property_read_u32(&pdev->dev, "keyup-threshold-microvolt",
+					&mc_data->keyup_voltage)) {
+			dev_warn(&pdev->dev, "Invalid or missing keyup voltage\n");
+			return -EINVAL;
+		}
+		mc_data->keyup_voltage /= 1000;
+
+		ret = mc_keys_load_keymap(&pdev->dev, mc_data);
+		if (ret)
+			return ret;
+
+		input = devm_input_allocate_device(&pdev->dev);
+		if (IS_ERR(input)) {
+			dev_err(&pdev->dev, "failed to allocate input device\n");
+			return PTR_ERR(input);
+		}
+
+		input_set_drvdata(input, mc_data);
+
+		input->name = "headset-keys";
+		input->phys = "headset-keys/input0";
+		input->id.bustype = BUS_HOST;
+		input->id.vendor = 0x0001;
+		input->id.product = 0x0001;
+		input->id.version = 0x0100;
+
+		__set_bit(EV_KEY, input->evbit);
+		for (i = 0; i < mc_data->num_keys; i++)
+			__set_bit(mc_data->map[i].keycode, input->keybit);
+
+		if (device_property_read_bool(&pdev->dev, "autorepeat"))
+			__set_bit(EV_REP, input->evbit);
+
+		mc_data->input = input;
+		ret = mc_keys_setup_polling(mc_data, mc_keys_poll);
+		if (ret) {
+			dev_err(&pdev->dev, "Unable to set up polling: %d\n", ret);
+			return ret;
+		}
+
+		if (!device_property_read_u32(&pdev->dev, "poll-interval", &value))
+			mc_set_poll_interval(mc_data->poller, value);
+
+		ret = input_register_device(mc_data->input);
+		if (ret) {
+			dev_err(&pdev->dev, "Unable to register input device: %d\n", ret);
+			return ret;
+		}
+	}
+
+	INIT_DEFERRABLE_WORK(&mc_data->handler, adc_jack_handler);
+
+	mc_data->spk_ctl_gpio = devm_gpiod_get_optional(&pdev->dev,
+							"spk-con",
+							GPIOD_OUT_LOW);
+	if (IS_ERR(mc_data->spk_ctl_gpio))
+		return PTR_ERR(mc_data->spk_ctl_gpio);
+
+	mc_data->hp_ctl_gpio = devm_gpiod_get_optional(&pdev->dev,
+						       "hp-con",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(mc_data->hp_ctl_gpio))
+		return PTR_ERR(mc_data->hp_ctl_gpio);
+
+	mc_data->hp_det_gpio = devm_gpiod_get_optional(&pdev->dev, "hp-det", GPIOD_IN);
+	if (IS_ERR(mc_data->hp_det_gpio))
+		return PTR_ERR(mc_data->hp_det_gpio);
+
+	mc_data->extcon = devm_extcon_dev_allocate(&pdev->dev, headset_extcon_cable);
+	if (IS_ERR(mc_data->extcon)) {
+		dev_err(&pdev->dev, "allocate extcon failed\n");
+		return PTR_ERR(mc_data->extcon);
+	}
+
+	ret = devm_extcon_dev_register(&pdev->dev, mc_data->extcon);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register extcon: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_of_parse_audio_routing(card, "rockchip,audio-routing");
+	if (ret < 0)
+		dev_warn(&pdev->dev, "Audio routing invalid/unspecified\n");
+
+	snd_soc_card_set_drvdata(card, mc_data);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_multicodecs_of_match[] = {
+	{ .compatible = "rockchip,multicodecs-card", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_multicodecs_of_match);
+
+static struct platform_driver rockchip_multicodecs_driver = {
+	.probe = rk_multicodecs_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_multicodecs_of_match,
+	},
+};
+
+module_platform_driver(rockchip_multicodecs_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip General Multicodecs ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 5adb293d0..67f426f2e 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -19,11 +19,15 @@
 #include "rockchip_pdm.h"
 
 #define PDM_DMA_BURST_SIZE	(8) /* size * width: 8*4 = 32 bytes */
-#define PDM_SIGNOFF_CLK_RATE	(100000000)
+#define PDM_SIGNOFF_CLK_100M	(100000000)
+#define PDM_SIGNOFF_CLK_300M	(300000000)
+#define PDM_PATH_MAX		(4)
 
 enum rk_pdm_version {
 	RK_PDM_RK3229,
 	RK_PDM_RK3308,
+	RK_PDM_RK3588,
+	RK_PDM_RV1126,
 };
 
 struct rk_pdm_dev {
@@ -74,7 +78,8 @@ static struct rk_pdm_ds_ratio ds_ratio[] = {
 };
 
 static unsigned int get_pdm_clk(struct rk_pdm_dev *pdm, unsigned int sr,
-				unsigned int *clk_src, unsigned int *clk_out)
+				unsigned int *clk_src, unsigned int *clk_out,
+				unsigned int signoff)
 {
 	unsigned int i, count, clk, div, rate;
 
@@ -99,7 +104,7 @@ static unsigned int get_pdm_clk(struct rk_pdm_dev *pdm, unsigned int sr,
 	}
 
 	if (!clk) {
-		clk = clk_round_rate(pdm->clk, PDM_SIGNOFF_CLK_RATE);
+		clk = clk_round_rate(pdm->clk, signoff);
 		*clk_src = clk;
 	}
 	return clk;
@@ -121,6 +126,55 @@ static unsigned int get_pdm_ds_ratio(unsigned int sr)
 	return ratio;
 }
 
+static unsigned int get_pdm_cic_ratio(unsigned int clk)
+{
+	switch (clk) {
+	case 4096000:
+	case 5644800:
+	case 6144000:
+		return 0;
+	case 2048000:
+	case 2822400:
+	case 3072000:
+		return 1;
+	case 1024000:
+	case 1411200:
+	case 1536000:
+		return 2;
+	default:
+		return 1;
+	}
+}
+
+static unsigned int samplerate_to_bit(unsigned int samplerate)
+{
+	switch (samplerate) {
+	case 8000:
+	case 11025:
+	case 12000:
+		return 0;
+	case 16000:
+	case 22050:
+	case 24000:
+		return 1;
+	case 32000:
+		return 2;
+	case 44100:
+	case 48000:
+		return 3;
+	case 64000:
+	case 88200:
+	case 96000:
+		return 4;
+	case 128000:
+	case 176400:
+	case 192000:
+		return 5;
+	default:
+		return 1;
+	}
+}
+
 static inline struct rk_pdm_dev *to_info(struct snd_soc_dai *dai)
 {
 	return snd_soc_dai_get_drvdata(dai);
@@ -149,7 +203,7 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	struct rk_pdm_dev *pdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int clk_rate, clk_div, samplerate;
-	unsigned int clk_src, clk_out = 0;
+	unsigned int clk_src = 0, clk_out = 0, signoff = PDM_SIGNOFF_CLK_100M;
 	unsigned long m, n;
 	bool change;
 	int ret;
@@ -158,7 +212,10 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 		return 0;
 
 	samplerate = params_rate(params);
-	clk_rate = get_pdm_clk(pdm, samplerate, &clk_src, &clk_out);
+
+	if (pdm->version == RK_PDM_RK3588)
+		signoff = PDM_SIGNOFF_CLK_300M;
+	clk_rate = get_pdm_clk(pdm, samplerate, &clk_src, &clk_out, signoff);
 	if (!clk_rate)
 		return -EINVAL;
 
@@ -166,7 +223,9 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	if (ret)
 		return -EINVAL;
 
-	if (pdm->version == RK_PDM_RK3308) {
+	if (pdm->version == RK_PDM_RK3308 ||
+	    pdm->version == RK_PDM_RK3588 ||
+	    pdm->version == RK_PDM_RV1126) {
 		rational_best_approximation(clk_out, clk_src,
 					    GENMASK(16 - 1, 0),
 					    GENMASK(16 - 1, 0),
@@ -194,8 +253,18 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 				   PDM_CLK_FD_RATIO_MSK,
 				   val);
 	}
-	val = get_pdm_ds_ratio(samplerate);
-	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_DS_RATIO_MSK, val);
+
+	if (pdm->version == RK_PDM_RK3588 || pdm->version == RK_PDM_RV1126) {
+		val = get_pdm_cic_ratio(clk_out);
+		regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CIC_RATIO_MSK, val);
+		val = samplerate_to_bit(samplerate);
+		regmap_update_bits(pdm->regmap, PDM_CTRL0,
+				   PDM_SAMPLERATE_MSK, PDM_SAMPLERATE(val));
+	} else {
+		val = get_pdm_ds_ratio(samplerate);
+		regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_DS_RATIO_MSK, val);
+	}
+
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
 			   PDM_HPF_CF_MSK, PDM_HPF_60HZ);
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
@@ -441,9 +510,10 @@ static bool rockchip_pdm_precious_reg(struct device *dev, unsigned int reg)
 }
 
 static const struct reg_default rockchip_pdm_reg_defaults[] = {
-	{0x04, 0x78000017},
-	{0x08, 0x0bb8ea60},
-	{0x18, 0x0000001f},
+	{ PDM_CTRL0, 0x78000017 },
+	{ PDM_CTRL1, 0x0bb8ea60 },
+	{ PDM_CLK_CTRL, 0x0000e401 },
+	{ PDM_DMA_CTRL, 0x0000001f },
 };
 
 static const struct regmap_config rockchip_pdm_regmap_config = {
@@ -460,7 +530,7 @@ static const struct regmap_config rockchip_pdm_regmap_config = {
 	.cache_type = REGCACHE_FLAT,
 };
 
-static const struct of_device_id rockchip_pdm_match[] = {
+static const struct of_device_id rockchip_pdm_match[] __maybe_unused = {
 	{ .compatible = "rockchip,pdm",
 	  .data = (void *)RK_PDM_RK3229 },
 	{ .compatible = "rockchip,px30-pdm",
@@ -469,12 +539,46 @@ static const struct of_device_id rockchip_pdm_match[] = {
 	  .data = (void *)RK_PDM_RK3308 },
 	{ .compatible = "rockchip,rk3308-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
+	{ .compatible = "rockchip,rk3568-pdm",
+	  .data = (void *)RK_PDM_RV1126 },
+	{ .compatible = "rockchip,rk3588-pdm",
+	  .data = (void *)RK_PDM_RK3588 },
+	{ .compatible = "rockchip,rv1126-pdm",
+	  .data = (void *)RK_PDM_RV1126 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rockchip_pdm_match);
 
+static int rockchip_pdm_path_parse(struct rk_pdm_dev *pdm, struct device_node *node)
+{
+	unsigned int path[PDM_PATH_MAX];
+	int cnt = 0, ret = 0, i = 0, val = 0, msk = 0;
+
+	cnt = of_count_phandle_with_args(node, "rockchip,path-map",
+					 NULL);
+	if (cnt != PDM_PATH_MAX)
+		return cnt;
+
+	ret = of_property_read_u32_array(node, "rockchip,path-map",
+					 path, cnt);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < cnt; i++) {
+		if (path[i] >= PDM_PATH_MAX)
+			return -EINVAL;
+		msk |= PDM_PATH_MASK(i);
+		val |= PDM_PATH(i, path[i]);
+	}
+
+	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, msk, val);
+
+	return 0;
+}
+
 static int rockchip_pdm_probe(struct platform_device *pdev)
 {
+	struct device_node *node = pdev->dev.of_node;
 	const struct of_device_id *match;
 	struct rk_pdm_dev *pdm;
 	struct resource *res;
@@ -495,8 +599,7 @@ static int rockchip_pdm_probe(struct platform_device *pdev)
 			return PTR_ERR(pdm->reset);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
+	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs))
 		return PTR_ERR(regs);
 
@@ -541,6 +644,11 @@ static int rockchip_pdm_probe(struct platform_device *pdev)
 	}
 
 	rockchip_pdm_rxctrl(pdm, 0);
+
+	ret = rockchip_pdm_path_parse(pdm, node);
+	if (ret != 0 && ret != -ENOENT)
+		goto err_suspend;
+
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
diff --git a/sound/soc/rockchip/rockchip_pdm.h b/sound/soc/rockchip/rockchip_pdm.h
index 8e5bbafef..cab977272 100644
--- a/sound/soc/rockchip/rockchip_pdm.h
+++ b/sound/soc/rockchip/rockchip_pdm.h
@@ -41,6 +41,8 @@
 #define PDM_PATH1_EN		BIT(28)
 #define PDM_PATH0_EN		BIT(27)
 #define PDM_HWT_EN		BIT(26)
+#define PDM_SAMPLERATE_MSK	GENMASK(7, 5)
+#define PDM_SAMPLERATE(x)	((x) << 5)
 #define PDM_VDW_MSK		(0x1f << 0)
 #define PDM_VDW(X)		((X - 1) << 0)
 
@@ -51,6 +53,9 @@
 #define PDM_FD_DENOMINATOR_MSK	GENMASK(15, 0)
 
 /* PDM CLK CTRL */
+#define PDM_PATH_SHIFT(x)	(8 + (x) * 2)
+#define PDM_PATH_MASK(x)	(0x3 << PDM_PATH_SHIFT(x))
+#define PDM_PATH(x, v)		((v) << PDM_PATH_SHIFT(x))
 #define PDM_CLK_FD_RATIO_MSK	BIT(6)
 #define PDM_CLK_FD_RATIO_40	(0X0 << 6)
 #define PDM_CLK_FD_RATIO_35	BIT(6)
@@ -66,6 +71,7 @@
 #define PDM_CLK_1280FS		(0x2 << 0)
 #define PDM_CLK_2560FS		(0x3 << 0)
 #define PDM_CLK_5120FS		(0x4 << 0)
+#define PDM_CIC_RATIO_MSK	(0x3 << 0)
 
 /* PDM HPF CTRL */
 #define PDM_HPF_LE		BIT(3)
diff --git a/sound/soc/rockchip/rockchip_rt5651.c b/sound/soc/rockchip/rockchip_rt5651.c
new file mode 100644
index 000000000..4dc91c2a1
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_rt5651.c
@@ -0,0 +1,245 @@
+/*
+ * rockchip_rt5651.c  --  RK3399 machine driver with RT5651 codecs
+ *
+ * Copyright (c) 2016, ROCKCHIP CORPORATION.  All rights reserved.
+ * Author: Xiaotan Luo <lxt@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "rockchip_i2s.h"
+#include "../codecs/rt5651.h"
+
+#define DRV_NAME "rockchip-rt5651"
+
+static const struct snd_soc_dapm_widget rockchip_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphones", NULL),
+	SND_SOC_DAPM_SPK("Lineout", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_MIC("HDMIIN", NULL),
+};
+
+static const struct snd_soc_dapm_route rockchip_dapm_routes[] = {
+	{"Headphones", NULL, "HPOL"},
+	{"Headphones", NULL, "HPOR"},
+	{"Lineout", NULL, "LOUTL"},
+	{"Lineout", NULL, "LOUTR"},
+	{"AIF2 Playback", NULL, "HDMIIN"},
+};
+
+static const struct snd_kcontrol_new rockchip_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphones"),
+	SOC_DAPM_PIN_SWITCH("Lineout"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+};
+
+static int rockchip_rt5651_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int mclk, ret;
+
+	/* in bypass mode, the mclk has to be one of the frequencies below */
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 11289600;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set cpu clock out %d\n", ret);
+		return ret;
+	}
+
+	snd_soc_dai_set_pll(codec_dai, 0, RT5651_PLL1_S_MCLK, mclk, mclk * 2);
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT5651_SCLK_S_PLL1, mclk * 2,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set codec clock in %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_rt5651_voice_hw_params(struct snd_pcm_substream *substream,
+					   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int mclk, ret;
+
+	/* in bypass mode, the mclk has to be one of the frequencies below */
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		mclk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		mclk = 11289600;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*Set the system clk for codec*/
+	snd_soc_dai_set_pll(codec_dai, 0, RT5651_PLL1_S_MCLK, mclk, 24576000);
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT5651_SCLK_S_PLL1, 24576000,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set codec clock in %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static struct snd_soc_ops rockchip_sound_rt5651_hifi_ops = {
+	.hw_params = rockchip_rt5651_hw_params,
+};
+
+static struct snd_soc_ops rockchip_sound_rt5651_voice_ops = {
+	.hw_params = rockchip_rt5651_voice_hw_params,
+};
+
+enum {
+	DAILINK_RT5651_HIFI,
+	DAILINK_RT5651_VOICE,
+	DAILINK_RT5651_MAX
+};
+
+static struct snd_soc_dai_link rockchip_dailinks[] = {
+	[DAILINK_RT5651_HIFI] = {
+		.name = "RT5651 HIFI",
+		.stream_name = "RT5651 PCM",
+		.codec_dai_name = "rt5651-aif1",
+		.ops = &rockchip_sound_rt5651_hifi_ops,
+		/* set rt5651 as slave */
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+	},
+	[DAILINK_RT5651_VOICE] = {
+		.name = "RT5651 HDMIIN",
+		.stream_name = "RT5651 PCM",
+		.codec_dai_name = "rt5651-aif2",
+		.ops = &rockchip_sound_rt5651_voice_ops,
+		/* set rt5651 as slave */
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+	},
+};
+
+static struct snd_soc_card rockchip_sound_card = {
+	.name = "realtekrt5651codec_hdmiin",
+	.owner = THIS_MODULE,
+	.dai_link = rockchip_dailinks,
+	.num_links =  ARRAY_SIZE(rockchip_dailinks),
+	.dapm_widgets = rockchip_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(rockchip_dapm_widgets),
+	.dapm_routes = rockchip_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(rockchip_dapm_routes),
+	.controls = rockchip_controls,
+	.num_controls = ARRAY_SIZE(rockchip_controls),
+};
+
+static int rockchip_sound_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &rockchip_sound_card;
+	struct device_node *cpu_node;
+	int i, ret;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	cpu_node = of_parse_phandle(pdev->dev.of_node, "rockchip,cpu", 0);
+	if (!cpu_node) {
+		dev_err(&pdev->dev,
+			"Property 'rockchip,cpu' failed\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < DAILINK_RT5651_MAX; i++) {
+		rockchip_dailinks[i].platform_of_node = cpu_node;
+		rockchip_dailinks[i].cpu_of_node = cpu_node;
+
+		rockchip_dailinks[i].codec_of_node =
+			of_parse_phandle(pdev->dev.of_node,
+					 "rockchip,codec", i);
+		if (!rockchip_dailinks[i].codec_of_node) {
+			dev_err(&pdev->dev,
+				"Property[%d] 'rockchip,codec' failed\n", i);
+			return -EINVAL;
+		}
+	}
+
+	card->dev = &pdev->dev;
+	platform_set_drvdata(pdev, card);
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret)
+		dev_err(&pdev->dev, "%s register card failed %d\n",
+			__func__, ret);
+
+	dev_info(&pdev->dev, "snd_soc_register_card successful\n");
+	return ret;
+}
+
+static const struct of_device_id rockchip_sound_of_match[] = {
+	{ .compatible = "rockchip,rockchip-rt5651-sound", },
+	{},
+};
+
+static struct platform_driver rockchip_sound_driver = {
+	.probe = rockchip_sound_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = rockchip_sound_of_match,
+#ifdef CONFIG_PM
+		.pm = &snd_soc_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(rockchip_sound_driver);
+
+MODULE_AUTHOR("Xiaotan Luo <lxt@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip ASoC Machine Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_sound_of_match);
diff --git a/sound/soc/rockchip/rockchip_spdif.c b/sound/soc/rockchip/rockchip_spdif.c
index 674810851..f71736144 100644
--- a/sound/soc/rockchip/rockchip_spdif.c
+++ b/sound/soc/rockchip/rockchip_spdif.c
@@ -41,7 +41,7 @@ struct rk_spdif_dev {
 	struct regmap *regmap;
 };
 
-static const struct of_device_id rk_spdif_match[] = {
+static const struct of_device_id rk_spdif_match[] __maybe_unused = {
 	{ .compatible = "rockchip,rk3066-spdif",
 	  .data = (void *)RK_SPDIF_RK3066 },
 	{ .compatible = "rockchip,rk3188-spdif",
@@ -58,6 +58,10 @@ static const struct of_device_id rk_spdif_match[] = {
 	  .data = (void *)RK_SPDIF_RK3366 },
 	{ .compatible = "rockchip,rk3399-spdif",
 	  .data = (void *)RK_SPDIF_RK3366 },
+	{ .compatible = "rockchip,rk3568-spdif",
+	  .data = (void *)RK_SPDIF_RK3366 },
+	{ .compatible = "rockchip,rk3588-spdif",
+	  .data = (void *)RK_SPDIF_RK3366 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rk_spdif_match);
@@ -103,8 +107,8 @@ static int __maybe_unused rk_spdif_runtime_resume(struct device *dev)
 }
 
 static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
-				  struct snd_pcm_hw_params *params,
-				  struct snd_soc_dai *dai)
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
 {
 	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
 	unsigned int val = SPDIF_CFGR_HALFWORD_ENABLE;
@@ -137,15 +141,15 @@ static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	ret = regmap_update_bits(spdif->regmap, SPDIF_CFGR,
-		SPDIF_CFGR_CLK_DIV_MASK | SPDIF_CFGR_HALFWORD_ENABLE |
-		SDPIF_CFGR_VDW_MASK,
-		val);
+				 SPDIF_CFGR_CLK_DIV_MASK |
+				 SPDIF_CFGR_HALFWORD_ENABLE |
+				 SDPIF_CFGR_VDW_MASK, val);
 
 	return ret;
 }
 
 static int rk_spdif_trigger(struct snd_pcm_substream *substream,
-				int cmd, struct snd_soc_dai *dai)
+			    int cmd, struct snd_soc_dai *dai)
 {
 	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
 	int ret;
@@ -155,31 +159,31 @@ static int rk_spdif_trigger(struct snd_pcm_substream *substream,
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		ret = regmap_update_bits(spdif->regmap, SPDIF_DMACR,
-				   SPDIF_DMACR_TDE_ENABLE |
-				   SPDIF_DMACR_TDL_MASK,
-				   SPDIF_DMACR_TDE_ENABLE |
-				   SPDIF_DMACR_TDL(16));
+					 SPDIF_DMACR_TDE_ENABLE |
+					 SPDIF_DMACR_TDL_MASK,
+					 SPDIF_DMACR_TDE_ENABLE |
+					 SPDIF_DMACR_TDL(16));
 
 		if (ret != 0)
 			return ret;
 
 		ret = regmap_update_bits(spdif->regmap, SPDIF_XFER,
-				   SPDIF_XFER_TXS_START,
-				   SPDIF_XFER_TXS_START);
+					 SPDIF_XFER_TXS_START,
+					 SPDIF_XFER_TXS_START);
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		ret = regmap_update_bits(spdif->regmap, SPDIF_DMACR,
-				   SPDIF_DMACR_TDE_ENABLE,
-				   SPDIF_DMACR_TDE_DISABLE);
+					 SPDIF_DMACR_TDE_ENABLE,
+					 SPDIF_DMACR_TDE_DISABLE);
 
 		if (ret != 0)
 			return ret;
 
 		ret = regmap_update_bits(spdif->regmap, SPDIF_XFER,
-				   SPDIF_XFER_TXS_START,
-				   SPDIF_XFER_TXS_STOP);
+					 SPDIF_XFER_TXS_START,
+					 SPDIF_XFER_TXS_STOP);
 		break;
 	default:
 		ret = -EINVAL;
@@ -247,6 +251,7 @@ static bool rk_spdif_rd_reg(struct device *dev, unsigned int reg)
 	case SPDIF_INTCR:
 	case SPDIF_INTSR:
 	case SPDIF_XFER:
+	case SPDIF_SMPDR:
 		return true;
 	default:
 		return false;
@@ -258,6 +263,7 @@ static bool rk_spdif_volatile_reg(struct device *dev, unsigned int reg)
 	switch (reg) {
 	case SPDIF_INTSR:
 	case SPDIF_SDBLR:
+	case SPDIF_SMPDR:
 		return true;
 	default:
 		return false;
@@ -291,7 +297,7 @@ static int rk_spdif_probe(struct platform_device *pdev)
 		grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
 		if (IS_ERR(grf)) {
 			dev_err(&pdev->dev,
-				"rockchip_spdif missing 'rockchip,grf' \n");
+				"rockchip_spdif missing 'rockchip,grf'\n");
 			return PTR_ERR(grf);
 		}
 
@@ -313,8 +319,7 @@ static int rk_spdif_probe(struct platform_device *pdev)
 	if (IS_ERR(spdif->mclk))
 		return PTR_ERR(spdif->mclk);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
+	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs))
 		return PTR_ERR(regs);
 
diff --git a/sound/soc/rockchip/rockchip_spdifrx.c b/sound/soc/rockchip/rockchip_spdifrx.c
new file mode 100644
index 000000000..0e4572321
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_spdifrx.c
@@ -0,0 +1,415 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip SPDIF_RX Controller driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "rockchip_spdifrx.h"
+
+struct rk_spdifrx_dev {
+	struct device *dev;
+	struct clk *mclk;
+	struct clk *hclk;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct regmap *regmap;
+	struct reset_control *reset;
+	int irq;
+};
+
+static int rk_spdifrx_runtime_suspend(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(spdifrx->mclk);
+	clk_disable_unprepare(spdifrx->hclk);
+
+	return 0;
+}
+
+static int rk_spdifrx_runtime_resume(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(spdifrx->mclk);
+	if (ret) {
+		dev_err(spdifrx->dev, "mclk clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(spdifrx->hclk);
+	if (ret) {
+		dev_err(spdifrx->dev, "hclk clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rk_spdifrx_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_INTEN,
+			   SPDIFRX_INTEN_SYNCIE_MASK |
+			   SPDIFRX_INTEN_NSYNCIE_MASK,
+			   SPDIFRX_INTEN_SYNCIE_EN |
+			   SPDIFRX_INTEN_NSYNCIE_EN);
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+			   SPDIFRX_DMACR_RDL_MASK, SPDIFRX_DMACR_RDL(8));
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_CDR,
+			   SPDIFRX_CDR_AVGSEL_MASK | SPDIFRX_CDR_BYPASS_MASK,
+			   SPDIFRX_CDR_AVGSEL_MIN | SPDIFRX_CDR_BYPASS_DIS);
+	return 0;
+}
+
+static void rk_spdifrx_reset(struct rk_spdifrx_dev *spdifrx)
+{
+	reset_control_assert(spdifrx->reset);
+	udelay(1);
+	reset_control_deassert(spdifrx->reset);
+}
+
+static int rk_spdifrx_trigger(struct snd_pcm_substream *substream,
+			      int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		rk_spdifrx_reset(spdifrx);
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+					 SPDIFRX_DMACR_RDE_MASK,
+					 SPDIFRX_DMACR_RDE_ENABLE);
+
+		if (ret != 0)
+			return ret;
+
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_CFGR,
+					 SPDIFRX_EN_MASK,
+					 SPDIFRX_EN);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+					 SPDIFRX_DMACR_RDE_MASK,
+					 SPDIFRX_DMACR_RDE_DISABLE);
+
+		if (ret != 0)
+			return ret;
+
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_CFGR,
+					 SPDIFRX_EN_MASK,
+					 SPDIFRX_DIS);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rk_spdifrx_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = &spdifrx->capture_dma_data;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rk_spdifrx_dai_ops = {
+	.hw_params = rk_spdifrx_hw_params,
+	.trigger = rk_spdifrx_trigger,
+};
+
+static struct snd_soc_dai_driver rk_spdifrx_dai = {
+	.probe = rk_spdifrx_dai_probe,
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 |
+			  SNDRV_PCM_RATE_44100 |
+			  SNDRV_PCM_RATE_48000 |
+			  SNDRV_PCM_RATE_96000 |
+			  SNDRV_PCM_RATE_192000),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE),
+	},
+	.ops = &rk_spdifrx_dai_ops,
+};
+
+static const struct snd_soc_component_driver rk_spdifrx_component = {
+	.name = "rockchip-spdifrx",
+};
+
+static bool rk_spdifrx_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CFGR:
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_DMACR:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTEN:
+	case SPDIFRX_INTMASK:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_SMPDR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk_spdifrx_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CFGR:
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_DMACR:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTEN:
+	case SPDIFRX_INTMASK:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_SMPDR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk_spdifrx_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_SMPDR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk_spdifrx_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_SMPDR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config rk_spdifrx_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SPDIFRX_BURSTINFO,
+	.writeable_reg = rk_spdifrx_wr_reg,
+	.readable_reg = rk_spdifrx_rd_reg,
+	.volatile_reg = rk_spdifrx_volatile_reg,
+	.precious_reg = rk_spdifrx_precious_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static irqreturn_t rk_spdifrx_isr(int irq, void *dev_id)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_id;
+	u32 intsr;
+
+	regmap_read(spdifrx->regmap, SPDIFRX_INTSR, &intsr);
+
+	if (intsr & BIT(7)) {
+		dev_dbg(spdifrx->dev, "NSYNC\n");
+		regmap_write(spdifrx->regmap, SPDIFRX_INTCLR, BIT(7));
+	}
+
+	if (intsr & BIT(9)) {
+		dev_dbg(spdifrx->dev, "SYNC\n");
+		regmap_write(spdifrx->regmap, SPDIFRX_INTCLR, BIT(9));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int rk_spdifrx_probe(struct platform_device *pdev)
+{
+	struct rk_spdifrx_dev *spdifrx;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+
+	spdifrx = devm_kzalloc(&pdev->dev, sizeof(*spdifrx), GFP_KERNEL);
+	if (!spdifrx)
+		return -ENOMEM;
+
+	spdifrx->reset = devm_reset_control_get(&pdev->dev, "spdifrx-m");
+	if (IS_ERR(spdifrx->reset)) {
+		ret = PTR_ERR(spdifrx->reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	spdifrx->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(spdifrx->hclk))
+		return PTR_ERR(spdifrx->hclk);
+
+	spdifrx->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(spdifrx->mclk))
+		return PTR_ERR(spdifrx->mclk);
+
+	spdifrx->irq = platform_get_irq(pdev, 0);
+	if (spdifrx->irq < 0)
+		return spdifrx->irq;
+
+	ret = devm_request_threaded_irq(&pdev->dev, spdifrx->irq, NULL,
+					rk_spdifrx_isr,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					dev_name(&pdev->dev), spdifrx);
+	if (ret)
+		return ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	spdifrx->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+						&rk_spdifrx_regmap_config);
+	if (IS_ERR(spdifrx->regmap))
+		return PTR_ERR(spdifrx->regmap);
+
+	spdifrx->capture_dma_data.addr = res->start + SPDIFRX_SMPDR;
+	spdifrx->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdifrx->capture_dma_data.maxburst = 4;
+
+	spdifrx->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, spdifrx);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = rk_spdifrx_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_runtime;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rk_spdifrx_component,
+					      &rk_spdifrx_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI\n");
+		goto err_pm_suspend;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		goto err_pm_suspend;
+	}
+
+	return 0;
+
+err_pm_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_spdifrx_runtime_suspend(&pdev->dev);
+err_pm_runtime:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rk_spdifrx_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_spdifrx_runtime_suspend(&pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_spdifrx_suspend(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(spdifrx->regmap);
+
+	return 0;
+}
+
+static int rockchip_spdifrx_resume(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(spdifrx->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rk_spdifrx_pm_ops = {
+	SET_RUNTIME_PM_OPS(rk_spdifrx_runtime_suspend, rk_spdifrx_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_spdifrx_suspend, rockchip_spdifrx_resume)
+};
+
+static const struct of_device_id rk_spdifrx_match[] = {
+	{ .compatible = "rockchip,rk3308-spdifrx", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk_spdifrx_match);
+
+static struct platform_driver rk_spdifrx_driver = {
+	.probe = rk_spdifrx_probe,
+	.remove = rk_spdifrx_remove,
+	.driver = {
+		.name = "rockchip-spdifrx",
+		.of_match_table = of_match_ptr(rk_spdifrx_match),
+		.pm = &rk_spdifrx_pm_ops,
+	},
+};
+module_platform_driver(rk_spdifrx_driver);
+
+MODULE_ALIAS("platform:rockchip-spdifrx");
+MODULE_DESCRIPTION("ROCKCHIP SPDIFRX Controller Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/rockchip/rockchip_spdifrx.h b/sound/soc/rockchip/rockchip_spdifrx.h
new file mode 100644
index 000000000..e75b2d5af
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_spdifrx.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * ALSA SoC Audio Layer - Rockchip SPDIF_RX Controller driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_SPDIFRX_H
+#define _ROCKCHIP_SPDIFRX_H
+
+/* CFGR */
+#define SPDIFRX_CFGR_TWAD_SHIFT		1
+#define SPDIFRX_CFGR_TWAD_DATA_ONLY	(0 << 1)
+#define SPDIFRX_CFGR_TWAD_STREAM	BIT(1)
+#define SPDIFRX_EN_MASK			BIT(0)
+#define SPDIFRX_EN			BIT(0)
+#define SPDIFRX_DIS			0
+
+/* CLR */
+#define SPDIFRX_CLR_RXSC		BIT(0)
+
+/* CDR */
+#define SPDIFRX_CDR_CS_MASK		GENMASK(10, 9)
+#define SPDIFRX_CDR_AVGSEL_MASK		BIT(1)
+#define SPDIFRX_CDR_AVGSEL_MIN		(0 << 1)
+#define SPDIFRX_CDR_AVGSEL_AVG		BIT(1)
+#define SPDIFRX_CDR_BYPASS_MASK		BIT(0)
+#define SPDIFRX_CDR_BYPASS_EN		BIT(0)
+#define SPDIFRX_CDR_BYPASS_DIS		0
+
+/* CDRST */
+#define SPDIFRX_CDRST_NOSTRTHR_MASK	GENMASK(31, 16)
+#define SPDIFRX_CDRST_MAXCNT_MASK	GENMASK(15, 8)
+#define SPDIFRX_CDRST_MINCNT_MASK	GENMASK(7, 0)
+
+/* DMACR */
+#define SPDIFRX_DMACR_RDE_MASK		BIT(5)
+#define SPDIFRX_DMACR_RDE_DISABLE	(0 << 5)
+#define SPDIFRX_DMACR_RDE_ENABLE	BIT(5)
+#define SPDIFRX_DMACR_RDL_MASK		GENMASK(4, 0)
+#define SPDIFRX_DMACR_RDL(x)		(((x) - 1) << 0)
+
+/* FIFOCTRL */
+#define SPDIFRX_FIFOCTRL_RFL_MASK	GENMASK(13, 8)
+#define SPDIFRX_FIFOCTRL_RFT_MASK	GENMASK(4, 0)
+
+/* INTEN */
+#define SPDIFRX_INTEN_UBCIE_MASK	BIT(10)
+#define SPDIFRX_INTEN_UBCIE_EN		BIT(10)
+#define SPDIFRX_INTEN_UBCIE_DIS		(0 << 10)
+#define SPDIFRX_INTEN_SYNCIE_MASK	BIT(9)
+#define SPDIFRX_INTEN_SYNCIE_EN		BIT(9)
+#define SPDIFRX_INTEN_SYNCIE_DIS	(0 << 9)
+#define SPDIFRX_INTEN_BTEIE_MASK	BIT(8)
+#define SPDIFRX_INTEN_BTEIE_EN		BIT(8)
+#define SPDIFRX_INTEN_BTEIE_DIS		(0 << 8)
+#define SPDIFRX_INTEN_NSYNCIE_MASK	BIT(7)
+#define SPDIFRX_INTEN_NSYNCIE_EN	BIT(7)
+#define SPDIFRX_INTEN_NSYNCIE_DIS	(0 << 7)
+
+/* INTMASK */
+#define SPDIFRX_INTMASK_UBCIMSK		BIT(10)
+#define SPDIFRX_INTMASK_UBCIUMSK	(0 << 10)
+#define SPDIFRX_INTMASK_SYNCIMSK	BIT(9)
+#define SPDIFRX_INTMASK_SYNCIUMSK	(0 << 9)
+#define SPDIFRX_INTMASK_BTEIMSK		BIT(8)
+#define SPDIFRX_INTMASK_BTEIUMSK	(0 << 8)
+#define SPDIFRX_INTMASK_NSYNCIMSK	BIT(7)
+#define SPDIFRX_INTMASK_NSYNCIUMSK	(0 << 7)
+
+/* INTSR */
+#define SPDIFRX_INTSR_UBCISR_ACTIVE	BIT(10)
+#define SPDIFRX_INTSR_SYNCISR_ACTIVE	BIT(9)
+#define SPDIFRX_INTSR_BTEISR_ACTIVE	BIT(8)
+#define SPDIFRX_INTSR_NSYNCISR_ACTIVE	BIT(7)
+
+/* INTCLR */
+#define SPDIFRX_INTCLR_UBCICLR_MASK	BIT(10)
+#define SPDIFRX_INTCLR_UBCICLR		BIT(10)
+#define SPDIFRX_INTCLR_SYNCICLR_MASK	BIT(9)
+#define SPDIFRX_INTCLR_SYNCICLR		BIT(9)
+#define SPDIFRX_INTCLR_BTECLR_MASK	BIT(8)
+#define SPDIFRX_INTCLR_BIECLR		BIT(8)
+#define SPDIFRX_INTCLR_NSYNCICLR_MASK	BIT(7)
+#define SPDIFRX_INTCLR_NSYNCICLR	BIT(7)
+
+/* BURSTINFO */
+#define SPDIFRX_BURSTINFO_PD_MASK	GENMASK(31, 16)
+#define SPDIFRX_BURSTINFO_BSNUM_MASK	GENMASK(15, 13)
+#define SPDIFRX_BURSTINFO_DATAINFO_MASK	GENMASK(12, 8)
+#define SPDIFRX_BURSTINFO_ERRFLAG_MASK	BIT(7)
+#define SPDIFRX_BURSTINFO_ERR		BIT(7)
+#define SPDIFRX_BURSTINFO_VALID		(0 << 7)
+#define SPDIFRX_BURSTINFO_DATATYPE_MASK	GENMASK(6, 0)
+
+#define SPDIFRX_VERSION			(0x0000)
+#define SPDIFRX_CFGR			(0x0004)
+#define SPDIFRX_CLR			(0x0008)
+#define SPDIFRX_CDR			(0x000c)
+#define SPDIFRX_CDRST			(0x0010)
+#define SPDIFRX_DMACR			(0x0014)
+#define SPDIFRX_FIFOCTRL		(0x0018)
+#define SPDIFRX_INTEN			(0x001C)
+#define SPDIFRX_INTMASK			(0x0020)
+#define SPDIFRX_INTSR			(0x0024)
+#define SPDIFRX_INTCLR			(0x0028)
+#define SPDIFRX_SMPDR			(0x002C)
+#define SPDIFRX_USRDRN			(0x0030)
+#define SPDIFRX_CHNSRN			(0x0060)
+#define SPDIFRX_BURSTINFO		(0x0100)
+
+#endif /* _ROCKCHIP_SPDIFRX_H */
diff --git a/sound/soc/rockchip/rockchip_vad.c b/sound/soc/rockchip/rockchip_vad.c
new file mode 100644
index 000000000..d69278aa5
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_vad.c
@@ -0,0 +1,1316 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Rockchip VAD driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rockchip_vad.h"
+#include "rockchip_multi_dais.h"
+#include "vad_preprocess.h"
+
+#define DRV_NAME "rockchip-vad"
+
+#define VAD_RATES	SNDRV_PCM_RATE_8000_192000
+#define VAD_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+#define ACODEC_REG_NUM	28
+#define CHUNK_SIZE	64 /* bytes */
+
+static struct snd_pcm_substream *vad_substream;
+static unsigned int voice_inactive_frames;
+module_param(voice_inactive_frames, uint, 0644);
+MODULE_PARM_DESC(voice_inactive_frames, "voice inactive frame count");
+
+enum rk_vad_version {
+	VAD_RK1808ES = 1,
+	VAD_RK1808,
+	VAD_RK3308,
+};
+
+struct vad_buf {
+	void __iomem *begin;
+	void __iomem *end;
+	void __iomem *cur;
+	void __iomem *pos;
+	int size;
+	int loop_cnt;
+	bool loop;
+	bool sorted;
+};
+
+struct audio_src_addr_map {
+	u32 id;
+	u32 addr;
+};
+
+struct vad_soc_data {
+	enum rk_vad_version version;
+	const struct audio_src_addr_map *map;
+};
+
+struct rockchip_vad {
+	struct device *dev;
+	struct device_node *audio_node;
+	struct clk *hclk;
+	struct regmap *regmap;
+	unsigned int memphy;
+	unsigned int memphy_end;
+	void __iomem *membase;
+	struct vad_buf vbuf;
+	struct vad_params params;
+	struct vad_uparams uparams;
+	struct snd_soc_dai *cpu_dai;
+	struct snd_pcm_substream *substream;
+	struct vad_soc_data *soc_data;
+	int mode;
+	u32 audio_src;
+	u32 audio_src_addr;
+	u32 audio_chnl;
+	u32 channels;
+	u32 sample_bytes;
+	u32 buffer_time; /* msec */
+	struct dentry *debugfs_dir;
+	void *buf;
+	bool acodec_cfg;
+	bool vswitch;
+	bool h_16bit;
+	enum rk_vad_version version;
+};
+
+static inline int vframe_size(struct rockchip_vad *vad, int bytes)
+{
+	return bytes / vad->channels / vad->sample_bytes;
+}
+
+static int chunk_sort(void __iomem *pos, void __iomem *end, int loop_cnt)
+{
+	char tbuf[CHUNK_SIZE];
+	int size1, size2;
+
+	size1 = loop_cnt * 4;
+	size2 = CHUNK_SIZE - size1;
+
+	while (pos < end) {
+		memcpy_fromio(&tbuf[0], pos + size1, size2);
+		memcpy_fromio(&tbuf[size2], pos, size1);
+		memcpy_toio(pos, &tbuf[0], CHUNK_SIZE);
+		pos += CHUNK_SIZE;
+	}
+
+	return 0;
+}
+
+static int vad_buffer_sort(struct rockchip_vad *vad)
+{
+	struct vad_buf *vbuf = &vad->vbuf;
+	int loop_cnt = vbuf->loop_cnt;
+
+	if (vad->version != VAD_RK1808ES)
+		return 0;
+
+	if (vbuf->sorted || !vbuf->loop)
+		return 0;
+
+	/* 16 words align */
+	if ((vbuf->pos - vbuf->begin) % CHUNK_SIZE ||
+	    (vbuf->end - vbuf->pos) % CHUNK_SIZE)
+		return -EINVAL;
+
+	switch (loop_cnt) {
+	case 0:
+		loop_cnt = 16;
+		chunk_sort(vbuf->pos, vbuf->end, loop_cnt - 1);
+		vbuf->sorted = true;
+		break;
+	case 1:
+		chunk_sort(vbuf->begin, vbuf->pos, loop_cnt);
+		vbuf->sorted = true;
+		break;
+	case 2 ... 15:
+		chunk_sort(vbuf->pos, vbuf->end, loop_cnt - 1);
+		chunk_sort(vbuf->begin, vbuf->pos, loop_cnt);
+		vbuf->sorted = true;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rockchip_vad_stop(struct rockchip_vad *vad)
+{
+	unsigned int val, frames;
+	struct vad_buf *vbuf = &vad->vbuf;
+	struct vad_params *params = &vad->params;
+
+	regmap_read(vad->regmap, VAD_CTRL, &val);
+	if ((val & VAD_EN_MASK) == VAD_DISABLE)
+		return 0;
+
+	/* sample cnt will be clear after vad disabled */
+	if (vad->version == VAD_RK1808ES)
+		regmap_read(vad->regmap, VAD_SAMPLE_CNT, &frames);
+	regmap_update_bits(vad->regmap, VAD_CTRL, VAD_EN_MASK, VAD_DISABLE);
+	regmap_read(vad->regmap, VAD_CTRL, &val);
+	vad->h_16bit = (val & AUDIO_24BIT_SAT_MASK) == AUDIO_H16B;
+	regmap_read(vad->regmap, VAD_RAM_END_ADDR, &val);
+	vbuf->end = vbuf->begin + (val - vad->memphy) + 0x8;
+	regmap_read(vad->regmap, VAD_INT, &val);
+	val &= BIT(8);
+	vbuf->loop = val;
+	regmap_read(vad->regmap, VAD_RAM_CUR_ADDR, &val);
+	if (!val) {
+		vbuf->size = 0;
+		vbuf->cur = vbuf->begin;
+		return 0;
+	}
+	vbuf->cur = vbuf->begin + (val - vad->memphy);
+
+	if (vbuf->loop) {
+		vbuf->size = vbuf->end - vbuf->begin;
+		vbuf->pos = vbuf->cur;
+	} else {
+		vbuf->size = vbuf->cur - vbuf->begin;
+		vbuf->end = vbuf->cur;
+		vbuf->pos = vbuf->begin;
+	}
+
+	if (vad->version == VAD_RK1808ES) {
+		vbuf->loop_cnt = (frames / vframe_size(vad, vbuf->size)) % 16;
+		/* due to get loop_cnt before vad disable, we should take
+		 * the boundary issue into account, and judge whether the
+		 * loop_cnt change to loop_cnt + 1 or not when vad disable.
+		 */
+		if (vbuf->loop) {
+			frames = frames % vframe_size(vad, vbuf->size);
+			val = vframe_size(vad, vbuf->pos - vbuf->begin);
+			if (frames > val)
+				vbuf->loop_cnt = (vbuf->loop_cnt + 1) % 16;
+		}
+		vbuf->sorted = false;
+	}
+	regmap_read(vad->regmap, VAD_DET_CON0, &val);
+	params->noise_level = (val & NOISE_LEVEL_MASK) >> NOISE_LEVEL_SHIFT;
+	params->vad_con_thd = (val & VAD_CON_THD_MASK) >> VAD_CON_THD_SHIFT;
+	params->voice_gain = (val & GAIN_MASK) >> GAIN_SHIFT;
+	regmap_read(vad->regmap, VAD_DET_CON1, &val);
+	params->sound_thd = val & SOUND_THD_MASK;
+	regmap_read(vad->regmap, VAD_DET_CON5, &val);
+	params->noise_abs = val & NOISE_ABS_MASK;
+
+	vad_preprocess_init(params);
+	voice_inactive_frames = 0;
+
+	dev_info(vad->dev, "bufsize: %d, hw_abs: 0x%x\n",
+		 vbuf->size, params->noise_abs);
+
+	return 0;
+}
+
+static int rockchip_vad_setup(struct rockchip_vad *vad)
+{
+	struct regmap *regmap = vad->regmap;
+	u32 val, mask;
+
+	dev_info(vad->dev, "sw_abs: 0x%x\n",
+		 vad->uparams.noise_abs);
+	regmap_update_bits(regmap, VAD_DET_CON5,
+			   NOISE_ABS_MASK, vad->uparams.noise_abs);
+	regmap_update_bits(regmap, VAD_CTRL, VAD_EN_MASK, VAD_EN);
+
+	val = ERR_INT_EN | VAD_DET_INT_EN;
+	mask = ERR_INT_EN_MASK | VAD_DET_INT_EN_MASK;
+
+	regmap_update_bits(regmap, VAD_INT, mask, val);
+
+	vad_preprocess_destroy();
+
+	return 0;
+}
+
+static struct rockchip_vad *substream_get_drvdata(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rockchip_vad *vad = NULL;
+	unsigned int i;
+
+	if (!rtd)
+		return NULL;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, i);
+
+		if (strstr(codec_dai->name, "vad"))
+			vad = snd_soc_component_get_drvdata(codec_dai->component);
+	}
+
+	return vad;
+}
+
+/**
+ * snd_pcm_vad_avail - Get the available (readable) space for vad
+ * @runtime: PCM substream instance
+ *
+ * Result is between 0 ... (boundary - 1)
+ */
+snd_pcm_uframes_t snd_pcm_vad_avail(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rockchip_vad *vad = NULL;
+	struct vad_buf *vbuf;
+	snd_pcm_uframes_t vframes;
+
+	vad = substream_get_drvdata(substream);
+
+	if (!vad)
+		return 0;
+
+	vbuf = &vad->vbuf;
+
+	if (vbuf->size <= 0)
+		return 0;
+
+	vframes = samples_to_bytes(runtime, vad->channels);
+	if (vframes)
+		vframes = vbuf->size / vframes;
+	if (!vframes)
+		dev_err(vad->dev, "residue bytes: %d\n", vbuf->size);
+
+	return vframes;
+}
+EXPORT_SYMBOL(snd_pcm_vad_avail);
+
+snd_pcm_sframes_t snd_pcm_vad_read(struct snd_pcm_substream *substream,
+				   void __user *buf, snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rockchip_vad *vad = NULL;
+	struct vad_buf *vbuf;
+	snd_pcm_uframes_t avail;
+	int bytes, vbytes, frame_sz, vframe_sz, padding_sz;
+	unsigned int i;
+	void *pbuf, *sbuf;
+
+	vad = substream_get_drvdata(substream);
+
+	if (!vad)
+		return -EFAULT;
+
+	vbuf = &vad->vbuf;
+
+	avail = snd_pcm_vad_avail(substream);
+	avail = avail > frames ? frames : avail;
+	bytes = frames_to_bytes(runtime, avail);
+	if (bytes <= 0)
+		return -EFAULT;
+
+	if (vad_buffer_sort(vad) < 0) {
+		dev_err(vad->dev, "buffer sort failed\n");
+		return -EFAULT;
+	}
+
+	if (!vad->buf) {
+		vad->buf = kzalloc(bytes, GFP_KERNEL);
+		if (!vad->buf)
+			return -ENOMEM;
+	}
+
+	frame_sz = frames_to_bytes(runtime, 1);
+	vframe_sz = samples_to_bytes(runtime, vad->channels);
+	padding_sz = frame_sz - vframe_sz;
+	vbytes = vframe_sz * avail;
+	sbuf = vad->buf;
+	pbuf = vad->buf + bytes - vbytes;
+	if (!vbuf->loop) {
+		memcpy_fromio(pbuf, vbuf->pos, vbytes);
+		vbuf->pos += vbytes;
+	} else {
+		if ((vbuf->pos + vbytes) <= vbuf->end) {
+			memcpy_fromio(pbuf, vbuf->pos, vbytes);
+			vbuf->pos += vbytes;
+		} else {
+			int part1 = vbuf->end - vbuf->pos;
+			int part2 = vbytes - part1;
+
+			memcpy_fromio(pbuf, vbuf->pos, part1);
+			memcpy_fromio(pbuf + part1, vbuf->begin, part2);
+			vbuf->pos = vbuf->begin + part2;
+		}
+	}
+
+	if (padding_sz) {
+		for (i = 0; i < avail; i++) {
+			memmove(sbuf, pbuf, vframe_sz);
+			sbuf += vframe_sz;
+			pbuf += vframe_sz;
+			memset(sbuf, 0x0, padding_sz);
+			sbuf += padding_sz;
+		}
+	}
+
+	if (copy_to_user(buf, vad->buf, bytes))
+		return -EFAULT;
+
+	vbuf->size -= vbytes;
+	if (vbuf->size <= 0) {
+		kfree(vad->buf);
+		vad->buf = NULL;
+	}
+
+	return avail;
+}
+EXPORT_SYMBOL(snd_pcm_vad_read);
+
+int snd_pcm_vad_preprocess(struct snd_pcm_substream *substream,
+			   void *buf, snd_pcm_uframes_t size)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rockchip_vad *vad = NULL;
+	unsigned int i;
+	s16 *data;
+
+	vad = substream_get_drvdata(substream);
+
+	if (!vad)
+		return 0;
+
+	buf += samples_to_bytes(runtime, vad->audio_chnl);
+	/* retrieve the high 16bit data */
+	if (runtime->sample_bits == 32 && vad->h_16bit)
+		buf += 2;
+	for (i = 0; i < size; i++) {
+		data = buf;
+		if (vad_preprocess(*data))
+			voice_inactive_frames = 0;
+		else
+			voice_inactive_frames++;
+		buf += frames_to_bytes(runtime, 1);
+	}
+
+	vad_preprocess_update_params(&vad->uparams);
+	return 0;
+}
+EXPORT_SYMBOL(snd_pcm_vad_preprocess);
+
+/**
+ * snd_pcm_vad_attached - Check whether vad is attached to substream or not
+ * @substream: PCM substream instance
+ *
+ * Result is true for attached or false for detached
+ */
+bool snd_pcm_vad_attached(struct snd_pcm_substream *substream)
+{
+	struct rockchip_vad *vad = NULL;
+
+	if (vad_substream == substream)
+		vad = substream_get_drvdata(substream);
+
+	if (vad && vad->vswitch)
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(snd_pcm_vad_attached);
+
+static int vad_memcpy_fromio(void *to, void __iomem *from,
+			     int size, int frame_sz, int padding_sz)
+{
+	int i, step_src, step_dst, fcount;
+
+	step_src = frame_sz;
+	step_dst = frame_sz + padding_sz;
+
+	if (size % frame_sz) {
+		pr_err("%s: invalid size: %d\n", __func__, size);
+		return -EINVAL;
+	}
+
+	fcount = size / frame_sz;
+	if (padding_sz) {
+		for (i = 0; i < fcount; i++) {
+			memcpy_fromio(to, from, frame_sz);
+			to += step_dst;
+			from += step_src;
+		}
+	} else {
+		memcpy_fromio(to, from, size);
+	}
+
+	return 0;
+}
+
+/**
+ * snd_pcm_vad_memcpy - Copy vad data to dst
+ * @substream: PCM substream instance
+ * @buf: dst buf
+ * @frames:  size in frame
+ *
+ * Result is copied frames for success or errno for fail
+ */
+snd_pcm_sframes_t snd_pcm_vad_memcpy(struct snd_pcm_substream *substream,
+				     void *buf, snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct rockchip_vad *vad = NULL;
+	struct vad_buf *vbuf;
+	snd_pcm_uframes_t avail;
+	int bytes, vbytes, frame_sz, vframe_sz, padding_sz;
+
+	vad = substream_get_drvdata(substream);
+
+	if (!vad)
+		return -EFAULT;
+
+	vbuf = &vad->vbuf;
+
+	avail = snd_pcm_vad_avail(substream);
+	avail = avail > frames ? frames : avail;
+	bytes = frames_to_bytes(runtime, avail);
+
+	if (bytes <= 0)
+		return -EFAULT;
+
+	if (vad_buffer_sort(vad) < 0) {
+		dev_err(vad->dev, "buffer sort failed\n");
+		return -EFAULT;
+	}
+
+	frame_sz = frames_to_bytes(runtime, 1);
+	vframe_sz = samples_to_bytes(runtime, vad->channels);
+	padding_sz = frame_sz - vframe_sz;
+	vbytes = vframe_sz * avail;
+
+	memset(buf, 0x0, bytes);
+	if (!vbuf->loop) {
+		vad_memcpy_fromio(buf, vbuf->pos, vbytes,
+				  vframe_sz, padding_sz);
+		vbuf->pos += vbytes;
+	} else {
+		if ((vbuf->pos + vbytes) <= vbuf->end) {
+			vad_memcpy_fromio(buf, vbuf->pos, vbytes,
+					  vframe_sz, padding_sz);
+			vbuf->pos += vbytes;
+		} else {
+			int part1 = vbuf->end - vbuf->pos;
+			int part2 = vbytes - part1;
+			int offset = part1;
+
+			if (padding_sz)
+				offset = part1 / vframe_sz * frame_sz;
+			vad_memcpy_fromio(buf, vbuf->pos, part1,
+					  vframe_sz, padding_sz);
+			vad_memcpy_fromio(buf + offset, vbuf->begin, part2,
+					  vframe_sz, padding_sz);
+			vbuf->pos = vbuf->begin + part2;
+		}
+	}
+
+	vbuf->size -= vbytes;
+
+	return avail;
+}
+EXPORT_SYMBOL(snd_pcm_vad_memcpy);
+
+static bool rockchip_vad_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static bool rockchip_vad_readable_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static bool rockchip_vad_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case VAD_INT:
+	case VAD_RAM_CUR_ADDR:
+	case VAD_DET_CON5:
+	case VAD_SAMPLE_CNT:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct reg_default rk1808_vad_reg_defaults[] = {
+	{VAD_CTRL,     0x03000000},
+	{VAD_DET_CON0, 0x01024008},
+	{VAD_DET_CON1, 0x04ff0064},
+	{VAD_DET_CON2, 0x3bf5e663},
+	{VAD_DET_CON3, 0x3bf58817},
+	{VAD_DET_CON4, 0x382b8858},
+};
+
+static const struct reg_default rk3308_vad_reg_defaults[] = {
+	{VAD_CTRL,     0x03000000},
+	{VAD_DET_CON0, 0x00024020},
+	{VAD_DET_CON1, 0x00ff0064},
+	{VAD_DET_CON2, 0x3bf5e663},
+	{VAD_DET_CON3, 0x3bf58817},
+	{VAD_DET_CON4, 0x382b8858},
+	{VAD_RAM_BEGIN_ADDR, 0xfff88000},
+	{VAD_RAM_END_ADDR, 0xfffbfff8},
+};
+
+static const struct regmap_config rk1808_vad_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = VAD_NOISE_DATA,
+	.reg_defaults = rk1808_vad_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk1808_vad_reg_defaults),
+	.writeable_reg = rockchip_vad_writeable_reg,
+	.readable_reg = rockchip_vad_readable_reg,
+	.volatile_reg = rockchip_vad_volatile_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static const struct regmap_config rk3308_vad_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = VAD_INT,
+	.reg_defaults = rk3308_vad_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk3308_vad_reg_defaults),
+	.writeable_reg = rockchip_vad_writeable_reg,
+	.readable_reg = rockchip_vad_readable_reg,
+	.volatile_reg = rockchip_vad_volatile_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static const struct audio_src_addr_map rk1808_addr_map[] = {
+	{ 1, RK1808_I2S0 },
+	{ 3, RK1808_I2S1 },
+	{ 4, RK1808_PDM },
+	{ /* sentinel */ },
+};
+
+static const struct audio_src_addr_map rk3308_addr_map[] = {
+	{ 0, RK3308_I2S_8CH_0 },
+	{ 1, RK3308_I2S_8CH_1 },
+	{ 2, RK3308_I2S_8CH_2 },
+	{ 3, RK3308_I2S_8CH_3 },
+	{ 4, RK3308_PDM_8CH },
+	{ /* sentinel */ },
+};
+
+static const struct audio_src_addr_map rk3568_addr_map[] = {
+	{ 0, RK3568_I2S_8CH_1 },
+	{ 1, RK3568_I2S_2CH_2 },
+	{ 2, RK3568_I2S_2CH_3 },
+	{ 3, RK3568_PDM },
+	{ /* sentinel */ },
+};
+
+static const struct audio_src_addr_map rk3588_addr_map[] = {
+	{ 0, RK3588_PDM0 },
+	{ 1, RK3588_I2S1_8CH },
+	{ /* sentinel */ },
+};
+
+static const struct vad_soc_data rk1808es_soc_data = {
+	.version = VAD_RK1808ES,
+	.map = rk1808_addr_map,
+};
+
+static const struct vad_soc_data rk1808_soc_data = {
+	.version = VAD_RK1808,
+	.map = rk1808_addr_map,
+};
+
+static const struct vad_soc_data rk3308_soc_data = {
+	.version = VAD_RK3308,
+	.map = rk3308_addr_map,
+};
+
+static const struct vad_soc_data rk3568_soc_data = {
+	.version = VAD_RK1808,
+	.map = rk3568_addr_map,
+};
+
+static const struct vad_soc_data rk3588_soc_data = {
+	.version = VAD_RK1808,
+	.map = rk3588_addr_map,
+};
+
+static int rockchip_vad_get_audio_src_address(struct rockchip_vad *vad,
+					      u32 addr)
+{
+	const struct audio_src_addr_map *map = vad->soc_data->map;
+
+	for (; map->addr; map++) {
+		if ((map->addr & 0xffff0000) == addr) {
+			vad->audio_src = map->id;
+			vad->audio_src_addr = map->addr;
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static irqreturn_t rockchip_vad_irq(int irqno, void *dev_id)
+{
+	struct rockchip_vad *vad = dev_id;
+	unsigned  int val;
+
+	regmap_read(vad->regmap, VAD_INT, &val);
+	regmap_write(vad->regmap, VAD_INT, val);
+
+	dev_dbg(vad->dev, "irq 0x%08x\n", val);
+
+	return IRQ_HANDLED;
+}
+
+static const struct reg_sequence rockchip_vad_acodec_adc_enable[] = {
+	{ VAD_OD_ADDR0, 0x36261606 },
+	{ VAD_D_DATA0, 0x51515151 },
+	{ VAD_OD_ADDR1, 0x30201000 },
+	{ VAD_D_DATA1, 0xbbbbbbbb },
+	{ VAD_OD_ADDR2, 0x32221202 },
+	{ VAD_D_DATA2, 0x11111111 },
+	{ VAD_OD_ADDR3, 0x35251505 },
+	{ VAD_D_DATA3, 0x77777777 },
+	{ VAD_OD_ADDR4, 0x32221202 },
+	{ VAD_D_DATA4, 0x33333333 },
+	{ VAD_OD_ADDR5, 0x30201000 },
+	{ VAD_D_DATA5, 0xffffffff },
+	{ VAD_OD_ADDR6, 0x32221202 },
+	{ VAD_D_DATA6, 0x77777777 },
+};
+
+static int rockchip_vad_config_acodec(struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+	unsigned int val = 0;
+
+	if (!vad->acodec_cfg)
+		return 0;
+
+	val = ACODEC_BASE + ACODEC_ADC_ANA_CON0;
+	regmap_write(vad->regmap, VAD_ID_ADDR, val);
+
+	regmap_multi_reg_write(vad->regmap, rockchip_vad_acodec_adc_enable,
+			       ARRAY_SIZE(rockchip_vad_acodec_adc_enable));
+
+	regmap_update_bits(vad->regmap, VAD_CTRL, ACODE_CFG_REG_NUM_MASK,
+			   ACODE_CFG_REG_NUM(ACODEC_REG_NUM));
+	regmap_update_bits(vad->regmap, VAD_CTRL, CFG_ACODE_AFTER_DET_EN_MASK,
+			   CFG_ACODE_AFTER_DET_EN);
+
+	return 0;
+}
+
+static struct snd_soc_dai *rockchip_vad_find_dai(struct device_node *np)
+{
+	struct snd_soc_dai_link_component dai_component = { 0 };
+
+	dai_component.of_node = np;
+
+	return snd_soc_find_dai(&dai_component);
+}
+
+static void hw_refine_channels(struct snd_pcm_hw_params *params,
+			       unsigned int channel)
+{
+	struct snd_interval *c =
+		hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	c->min = channel;
+	c->max = channel;
+}
+
+static void rockchip_vad_params_fixup(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(dai->component);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai, *audio_src_dai;
+	struct device_node *np;
+	struct rk_mdais_dev *mdais;
+	unsigned int *channel_maps;
+	int i;
+
+	cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	vad->cpu_dai = cpu_dai;
+	vad->substream = substream;
+	np = cpu_dai->dev->of_node;
+	if (of_device_is_compatible(np, "rockchip,multi-dais")) {
+		audio_src_dai = rockchip_vad_find_dai(vad->audio_node);
+		mdais = snd_soc_dai_get_drvdata(cpu_dai);
+		channel_maps = mdais->capture_channel_maps;
+		for (i = 0; i < mdais->num_dais; i++) {
+			if (audio_src_dai == mdais->dais[i].dai &&
+			    channel_maps[i])
+				hw_refine_channels(params, channel_maps[i]);
+		}
+	}
+}
+
+static int rockchip_vad_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+	unsigned int val = 0, mask = 0, frame_bytes, buf_time;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+
+	rockchip_vad_params_fixup(substream, params, dai);
+	vad->channels = params_channels(params);
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val = AUDIO_CHNL_16B;
+		vad->sample_bytes = 2;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		val = AUDIO_CHNL_24B;
+		vad->sample_bytes = 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(vad->regmap, VAD_CTRL, AUDIO_CHNL_BW_MASK, val);
+	regmap_update_bits(vad->regmap, VAD_CTRL, AUDIO_CHNL_NUM_MASK,
+			   AUDIO_CHNL_NUM(params_channels(params)));
+
+	val = SRC_ADDR_MODE_INC | SRC_BURST_INCR;
+	mask = SRC_ADDR_MODE_MASK | SRC_BURST_MASK | INCR_BURST_LEN_MASK;
+	switch (params_channels(params)) {
+	case 8:
+		/* fallthrough */
+	case 6:
+		/* fallthrough */
+	case 4:
+		/* fallthrough */
+	case 2:
+		val |= INCR_BURST_LEN(params_channels(params));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (vad->version == VAD_RK1808ES) {
+		val = SRC_ADDR_MODE_INC | SRC_BURST_INCR16;
+		mask = SRC_ADDR_MODE_MASK | SRC_BURST_MASK | SRC_BURST_NUM_MASK;
+		if (params_channels(params) == 6)
+			val |= SRC_BURST_NUM(3);
+	}
+	regmap_update_bits(vad->regmap, VAD_CTRL, mask, val);
+
+	/* calculate buffer space according buffer time */
+	if (vad->buffer_time) {
+		frame_bytes = snd_pcm_format_size(params_format(params),
+						  params_channels(params));
+
+		buf_time = vad->memphy_end - vad->memphy + 0x8;
+		buf_time *= 1000;
+		buf_time /= (frame_bytes * params_rate(params));
+		if (buf_time < vad->buffer_time)
+			dev_info(vad->dev, "max buffer time: %u ms.\n", buf_time);
+		buf_time = min(buf_time, vad->buffer_time);
+
+		val = params_rate(params) * buf_time / 1000;
+		if (vad->version == VAD_RK1808ES)
+			val &= ~0xf; /* 16 align */
+		val *= frame_bytes;
+		val += vad->memphy;
+		val -= 0x8;
+		if (val < vad->memphy || val > vad->memphy_end)
+			return -EINVAL;
+		regmap_write(vad->regmap, VAD_RAM_END_ADDR, val);
+	}
+
+	/*
+	 * config acodec
+	 * audio_src 2/3 is connected to acodec
+	 */
+	val = vad->audio_src >> AUDIO_SRC_SEL_SHIFT;
+	if (val == 2 || val == 3)
+		rockchip_vad_config_acodec(params, dai);
+
+	return 0;
+}
+
+static int rockchip_vad_enable_cpudai(struct rockchip_vad *vad)
+{
+	struct snd_soc_dai *cpu_dai;
+	struct snd_pcm_substream *substream;
+	int ret = 0;
+
+	cpu_dai = vad->cpu_dai;
+	substream = vad->substream;
+
+	if (!cpu_dai || !substream)
+		return 0;
+
+	pm_runtime_get_sync(cpu_dai->dev);
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->trigger)
+		ret = cpu_dai->driver->ops->trigger(substream,
+						    SNDRV_PCM_TRIGGER_START,
+						    cpu_dai);
+
+	return ret;
+}
+
+static int rockchip_vad_disable_cpudai(struct rockchip_vad *vad)
+{
+	struct snd_soc_dai *cpu_dai;
+	struct snd_pcm_substream *substream;
+	int ret = 0;
+
+	cpu_dai = vad->cpu_dai;
+	substream = vad->substream;
+
+	if (!cpu_dai || !substream)
+		return 0;
+
+	pm_runtime_get_sync(cpu_dai->dev);
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->trigger)
+		ret = cpu_dai->driver->ops->trigger(substream,
+						    SNDRV_PCM_TRIGGER_STOP,
+						    cpu_dai);
+
+	pm_runtime_put(cpu_dai->dev);
+	return ret;
+}
+
+static int rockchip_vad_pcm_startup(struct snd_pcm_substream *substream,
+				    struct snd_soc_dai *dai)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+
+	vad_substream = substream;
+
+	return 0;
+}
+
+static void rockchip_vad_pcm_shutdown(struct snd_pcm_substream *substream,
+				      struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return;
+
+	if (vad->vswitch) {
+		rockchip_vad_enable_cpudai(vad);
+		rockchip_vad_setup(vad);
+	}
+
+	vad_substream = NULL;
+}
+
+static int rockchip_vad_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			return 0;
+		rockchip_vad_stop(vad);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops rockchip_vad_dai_ops = {
+	.hw_params = rockchip_vad_hw_params,
+	.shutdown = rockchip_vad_pcm_shutdown,
+	.startup = rockchip_vad_pcm_startup,
+	.trigger = rockchip_vad_trigger,
+};
+
+static struct snd_soc_dai_driver vad_dai = {
+	.name = "vad",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = VAD_RATES,
+		.formats = VAD_FORMATS,
+	},
+	.capture = {
+		 .stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = VAD_RATES,
+		.formats = VAD_FORMATS,
+	},
+	.ops = &rockchip_vad_dai_ops,
+};
+
+static int rockchip_vad_switch_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int rockchip_vad_switch_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = vad->vswitch;
+
+	return 0;
+}
+
+static int rockchip_vad_switch_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct rockchip_vad *vad = snd_soc_component_get_drvdata(component);
+	int val;
+
+	val = ucontrol->value.integer.value[0];
+	if (val && !vad->vswitch) {
+		vad->vswitch = true;
+	} else if (!val && vad->vswitch) {
+		vad->vswitch = false;
+
+		regmap_read(vad->regmap, VAD_CTRL, &val);
+		if ((val & VAD_EN_MASK) == VAD_DISABLE)
+			return 0;
+		rockchip_vad_stop(vad);
+		rockchip_vad_disable_cpudai(vad);
+		/* this case we don't need vad data */
+		vad->vbuf.size = 0;
+	}
+
+	return 0;
+}
+
+#define SOC_ROCKCHIP_VAD_SWITCH_DECL(xname) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = rockchip_vad_switch_info, .get = rockchip_vad_switch_get, \
+	.put = rockchip_vad_switch_put, }
+
+static const struct snd_kcontrol_new rockchip_vad_dapm_controls[] = {
+	SOC_ROCKCHIP_VAD_SWITCH_DECL("vad switch"),
+};
+
+static const struct snd_soc_component_driver soc_vad_codec = {
+	.controls = rockchip_vad_dapm_controls,
+	.num_controls = ARRAY_SIZE(rockchip_vad_dapm_controls),
+};
+
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+static int rockchip_vad_debugfs_reg_show(struct seq_file *s, void *v)
+{
+	struct rockchip_vad *vad = s->private;
+	unsigned int i;
+	unsigned int val;
+	unsigned int max_register;
+
+	if (vad->version == VAD_RK1808 ||
+	    vad->version == VAD_RK1808ES)
+		max_register = VAD_NOISE_DATA;
+	else
+		max_register = VAD_INT;
+	for (i = VAD_CTRL; i <= max_register; i += 4) {
+		regmap_read(vad->regmap, i, &val);
+		if (!(i % 16))
+			seq_printf(s, "\n%08x:  ", i);
+		seq_printf(s, "%08x ", val);
+	}
+
+	return 0;
+}
+
+static ssize_t rockchip_vad_debugfs_reg_write(struct file *file,
+					      const char __user *buf,
+					      size_t count, loff_t *ppos)
+{
+	struct rockchip_vad *vad = ((struct seq_file *)file->private_data)->private;
+	unsigned int reg, val;
+	char kbuf[24];
+
+	if (count >= sizeof(kbuf))
+		return -EINVAL;
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	kbuf[count] = '\0';
+	if (sscanf(kbuf, "%x %x", &reg, &val) != 2)
+		return -EFAULT;
+
+	regmap_write(vad->regmap, reg, val);
+
+	return count;
+}
+
+static int rockchip_vad_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rockchip_vad_debugfs_reg_show, inode->i_private);
+}
+
+static const struct file_operations rockchip_vad_reg_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.open = rockchip_vad_debugfs_open,
+	.read = seq_read,
+	.write = rockchip_vad_debugfs_reg_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
+static void rockchip_vad_init(struct rockchip_vad *vad)
+{
+	unsigned int val, mask;
+
+	regmap_write(vad->regmap, VAD_RAM_BEGIN_ADDR, vad->memphy);
+	regmap_write(vad->regmap, VAD_RAM_END_ADDR, vad->memphy_end);
+	vad->vbuf.begin = vad->membase;
+	regmap_write(vad->regmap, VAD_IS_ADDR, vad->audio_src_addr);
+
+	val = VAD_DET_CHNL(vad->audio_chnl);
+	val |= vad->audio_src;
+	val |= vad->mode << VAD_MODE_SHIFT;
+	mask = VAD_DET_CHNL_MASK | AUDIO_SRC_SEL_MASK |
+	       VAD_MODE_MASK;
+
+	regmap_update_bits(vad->regmap, VAD_CTRL, mask, val);
+	if (vad->version == VAD_RK1808 ||
+	    vad->version == VAD_RK1808ES) {
+		regmap_update_bits(vad->regmap, VAD_AUX_CONTROL,
+				   RAM_ITF_EN_MASK | BUS_WRITE_EN_MASK,
+				   RAM_ITF_DIS | BUS_WRITE_EN);
+		regmap_update_bits(vad->regmap, VAD_AUX_CONTROL,
+				   SAMPLE_CNT_EN_MASK, SAMPLE_CNT_EN);
+	}
+}
+
+static const struct of_device_id rockchip_vad_match[] = {
+	{ .compatible = "rockchip,rk1808es-vad", .data = &rk1808es_soc_data },
+	{ .compatible = "rockchip,rk1808-vad", .data = &rk1808_soc_data },
+	{ .compatible = "rockchip,rk3308-vad", .data = &rk3308_soc_data },
+	{ .compatible = "rockchip,rk3568-vad", .data = &rk3568_soc_data },
+	{ .compatible = "rockchip,rk3588-vad", .data = &rk3588_soc_data },
+	{},
+};
+
+static int rockchip_vad_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *asrc_np = NULL;
+	struct device_node *sram_np = NULL;
+	const struct of_device_id *match;
+	const struct regmap_config *regmap_config;
+	struct rockchip_vad *vad;
+	struct resource *res;
+	struct resource audio_res;
+	struct resource sram_res;
+	void __iomem *regbase;
+	int irq;
+	int ret;
+
+	vad = devm_kzalloc(&pdev->dev, sizeof(*vad), GFP_KERNEL);
+	if (!vad)
+		return -ENOMEM;
+
+	vad->dev = &pdev->dev;
+
+	match = of_match_device(rockchip_vad_match, &pdev->dev);
+	if (!match || !match->data)
+		return -EINVAL;
+
+	vad->soc_data = (struct vad_soc_data *)match->data;
+	vad->version = vad->soc_data->version;
+
+	switch (vad->version) {
+	case VAD_RK1808:
+	case VAD_RK1808ES:
+		regmap_config = &rk1808_vad_regmap_config;
+		break;
+	case VAD_RK3308:
+		regmap_config = &rk3308_vad_regmap_config;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	vad->acodec_cfg = of_property_read_bool(np, "rockchip,acodec-cfg");
+	of_property_read_u32(np, "rockchip,mode", &vad->mode);
+	of_property_read_u32(np, "rockchip,det-channel", &vad->audio_chnl);
+	of_property_read_u32(np, "rockchip,buffer-time-ms", &vad->buffer_time);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vad");
+	regbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regbase))
+		return PTR_ERR(regbase);
+
+	sram_np = of_parse_phandle(np, "rockchip,audio-sram", 0);
+	if (!sram_np) {
+		dev_err(&pdev->dev, "could not find sram dt node\n");
+		return -ENODEV;
+	}
+
+	asrc_np = of_parse_phandle(np, "rockchip,audio-src", 0);
+	if (!asrc_np) {
+		ret = -ENODEV;
+		goto err_phandle;
+	}
+
+	ret = of_address_to_resource(asrc_np, 0, &audio_res);
+	if (ret)
+		goto err_phandle;
+	ret = rockchip_vad_get_audio_src_address(vad, audio_res.start);
+	if (ret)
+		goto err_phandle;
+	vad->audio_node = asrc_np;
+	vad->audio_src <<= AUDIO_SRC_SEL_SHIFT;
+
+	ret = of_address_to_resource(sram_np, 0, &sram_res);
+	if (ret)
+		goto err_phandle;
+	vad->memphy = sram_res.start;
+	vad->memphy_end = sram_res.start + resource_size(&sram_res) - 0x8;
+	vad->membase = devm_ioremap(&pdev->dev, sram_res.start,
+				    resource_size(&sram_res));
+	if (!vad->membase) {
+		ret = -ENOMEM;
+		goto err_phandle;
+	}
+
+	if (IS_ERR(vad->membase)) {
+		ret = PTR_ERR(vad->membase);
+		goto err_phandle;
+	}
+
+	vad->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(vad->hclk)) {
+		ret = PTR_ERR(vad->hclk);
+		goto err_phandle;
+	}
+
+	ret = clk_prepare_enable(vad->hclk);
+	if (ret)
+		goto err_phandle;
+
+	vad->regmap = devm_regmap_init_mmio(&pdev->dev, regbase,
+					    regmap_config);
+	if (IS_ERR(vad->regmap)) {
+		ret = PTR_ERR(vad->regmap);
+		goto err;
+	}
+
+	rockchip_vad_init(vad);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = irq;
+		goto err;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, rockchip_vad_irq,
+			       0, dev_name(&pdev->dev), vad);
+	if (ret < 0)
+		goto err;
+
+#if defined(CONFIG_DEBUG_FS)
+	vad->debugfs_dir = debugfs_create_dir("vad", NULL);
+	if (IS_ERR(vad->debugfs_dir))
+		dev_err(&pdev->dev, "failed to create debugfs dir for vad!\n");
+	else
+		debugfs_create_file("reg", 0644, vad->debugfs_dir, vad,
+				    &rockchip_vad_reg_debugfs_fops);
+#endif
+
+	platform_set_drvdata(pdev, vad);
+	ret = snd_soc_register_component(&pdev->dev, &soc_vad_codec,
+					 &vad_dai, 1);
+	if (ret)
+		goto err;
+
+	of_node_put(sram_np);
+
+	return 0;
+err:
+	clk_disable_unprepare(vad->hclk);
+err_phandle:
+	of_node_put(sram_np);
+	of_node_put(asrc_np);
+	return ret;
+}
+
+static int rockchip_vad_remove(struct platform_device *pdev)
+{
+	struct rockchip_vad *vad = dev_get_drvdata(&pdev->dev);
+
+	if (!IS_ERR(vad->hclk))
+		clk_disable_unprepare(vad->hclk);
+	of_node_put(vad->audio_node);
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver rockchip_vad_driver = {
+	.probe = rockchip_vad_probe,
+	.remove = rockchip_vad_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_vad_match),
+	},
+};
+module_platform_driver(rockchip_vad_driver);
+
+MODULE_DESCRIPTION("Rockchip VAD Controller");
+MODULE_AUTHOR("Andy Yan <andy.yan@rock-chips.com>");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_vad_match);
diff --git a/sound/soc/rockchip/rockchip_vad.h b/sound/soc/rockchip/rockchip_vad.h
new file mode 100644
index 000000000..1121e7149
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_vad.h
@@ -0,0 +1,231 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip VAD driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_VAD_H
+#define _ROCKCHIP_VAD_H
+
+#define VAD_CTRL			0x00
+#define VAD_DET_CHNL_SHIFT		29
+#define VAD_DET_CHNL_MASK		GENMASK(31, 29)
+#define VAD_DET_CHNL(x)			((x) << VAD_DET_CHNL_SHIFT)
+#define AUDIO_24BIT_SAT_SHIFT		28
+#define AUDIO_24BIT_SAT_MASK		BIT(28)
+#define AUDIO_H16B			0
+#define AUDIO_SAT_24TO16		BIT(28)
+#define AUDIO_24BIT_ALIGN_MODE_SHIFT	27
+#define AUDIO_24BIT_ALIGN_MODE_MASK	BIT(27)
+#define AUDIO_24BIT_ALIGN_8_31B		0
+#define AUDIO_24BIT_ALIGN_0_23B		BIT(27)
+#define AUDIO_CHNL_BW_SHIFT		26
+#define AUDIO_CHNL_BW_MASK		BIT(26)
+#define AUDIO_CHNL_16B			0
+#define AUDIO_CHNL_24B			BIT(26)
+#define AUDIO_CHNL_NUM_SHIFT		23
+#define AUDIO_CHNL_NUM_MASK		GENMASK(25, 23)
+#define AUDIO_CHNL_NUM(x)		((x - 1) << AUDIO_CHNL_NUM_SHIFT)
+#define CFG_ACODE_AFTER_DET_EN_SHIFT	22
+#define CFG_ACODE_AFTER_DET_EN_MASK	BIT(22)
+#define CFG_ACODE_AFTER_DET_EN		BIT(22)
+#define VAD_MODE_SHIFT			20
+#define VAD_MODE_MASK			GENMASK(21, 20)
+#define STORE_DATA_VAD_DET_ONLY		0
+#define STORE_DATA_ALL			(1 << VAD_MODE_SHIFT)
+#define NO_STORE_DATA			(2 << VAD_MODE_SHIFT)
+#define ACODE_CFG_REG_NUM_SHIFT		15
+#define ACODE_CFG_REG_NUM_MASK		GENMASK(19, 15)
+#define ACODE_CFG_REG_NUM(x)		((x - 1) << ACODE_CFG_REG_NUM_SHIFT)
+#define SRC_ADDR_MODE_SHIFT		14
+#define SRC_ADDR_MODE_MASK		BIT(14)
+#define SRC_ADDR_MODE_INC		0
+#define SRC_ADDR_MODE_FIXED		BIT(14)
+#define INCR_BURST_LEN_SHIFT		10
+#define INCR_BURST_LEN_MASK		GENMASK(13, 10)
+#define INCR_BURST_LEN(x)		((x - 1) << INCR_BURST_LEN_SHIFT)
+#define SRC_BURST_NUM_SHIFT		7
+#define SRC_BURST_NUM_MASK		GENMASK(9, 7)
+#define SRC_BURST_NUM(x)		((x - 1) << SRC_BURST_NUM_SHIFT)
+#define SRC_BURST_SHIFT			4
+#define SRC_BURST_MASK			GENMASK(6, 4)
+#define SRC_BURST_SIGNLE		0
+#define SRC_BURST_INCR			(1 << SRC_BURST_SHIFT)
+#define SRC_BURST_INCR4			(3 << SRC_BURST_SHIFT)
+#define SRC_BURST_INCR8			(5 << SRC_BURST_SHIFT)
+#define SRC_BURST_INCR16		(7 << SRC_BURST_SHIFT)
+#define AUDIO_SRC_SEL_SHIFT		1
+#define AUDIO_SRC_SEL_MASK		GENMASK(3, 1)
+#define AUDIO_SRC_SEL_I2S0		0
+#define AUDIO_SRC_SEL_I2S1		(1 << AUDIO_SRC_SEL_MASK)
+#define AUDIO_SRC_SEL_I2S2		(2 << AUDIO_SRC_SEL_MASK)
+#define AUDIO_SRC_SEL_I2S3		(3 << AUDIO_SRC_SEL_MASK)
+#define AUDIO_SRC_SEL_PDM		(4 << AUDIO_SRC_SEL_MASK)
+#define VAD_EN_SHIFT			0
+#define VAD_EN_MASK			BIT(0)
+#define VAD_EN				BIT(0)
+#define VAD_DISABLE			0
+#define VAD_IS_ADDR			4
+#define VAD_ID_ADDR			8
+#define VAD_OD_ADDR0			0x0c
+#define VAD_OD_ADDR1			0x10
+#define VAD_OD_ADDR2			0x14
+#define VAD_OD_ADDR3			0x18
+#define VAD_OD_ADDR4			0x1c
+#define VAD_OD_ADDR5			0x20
+#define VAD_OD_ADDR6			0x24
+#define VAD_OD_ADDR7			0x28
+#define VAD_D_DATA0			0x2c
+#define VAD_D_DATA1			0x30
+#define VAD_D_DATA2			0x34
+#define VAD_D_DATA3			0x38
+#define VAD_D_DATA4			0x3c
+#define VAD_D_DATA5			0x40
+#define VAD_D_DATA6			0x44
+#define VAD_D_DATA7			0x48
+
+#define VAD_TIMEOUT			0x4c
+#define WORK_TIMEOUT_EN_MASK		BIT(31)
+#define WORK_TIMEOUT_EN			BIT(31)
+#define WORK_TIMEOUT_DISABLE		0
+#define IDLE_TIMEOUT_EN_MASK		BIT(30)
+#define IDLE_TIMEOUT_EN			BIT(30)
+#define IDLE_TIMEOUT_DISABLE		0
+#define WORK_TIMEOUT_THD_SHIFT		20
+#define WORK_TIMEOUT_THD_MASK		GENMASK(29, 20)
+#define WORK_TIMEOUT_THD(x)		((x) << WORK_TIMEOUT_THD_SHIFT)
+#define IDLE_TIMEOUT_THD_SHIFT		0
+#define IDLE_TIMEOUT_THD_MASK		GENMASK(19, 0)
+#define IDLE_TIMEOUT_THD(x)		((x) << IDLE_TIMEOUT_THD_SHIFT)
+
+#define VAD_RAM_BEGIN_ADDR		0x50
+#define VAD_RAM_END_ADDR		0x54
+#define VAD_RAM_CUR_ADDR		0x58
+#define VAD_DET_CON0			0x5c
+#define VAD_CON_THD_SHIFT		16
+#define VAD_CON_THD_MASK		GENMASK(23, 16)
+#define VAD_CON_THD(x)			((x) << VAD_CON_THD_SHIFT)
+#define NOISE_LEVEL_SHIFT		12
+#define NOISE_LEVEL_MASK		GENMASK(14, 12)
+#define NOISE_LEVEL(x)			((x) << NOISE_LEVEL_SHIFT)
+#define GAIN_SHIFT			0
+#define GAIN_MASK			GENMASK(9, 0)
+#define GAIN(x)				(x)
+
+#define VAD_DET_CON1			0x60
+#define MIN_NOISE_FIND_MODE_SHIFT	30
+#define MIN_NOISE_FIN_MODE_MASK		BIT(30)
+#define MIN_NOISE_FIND_MODE0		0
+#define MIN_NOISE_FIND_MODE1		BIT(30)
+#define NOISE_CLEAN_MODE_SHIFT		29
+#define NOISE_CLEAN_MODE_MASK		BIT(29)
+#define NOISE_CLEAN_MODE0		0
+#define NOISE_CLEAN_MODE1		BIT(29)
+#define NOISE_CLK_FORCE_EN_MASK		BIT(28)
+#define NOISE_CLK_AUTO_GATING		0
+#define NOISE_CLK_FORCE_EN		BIT(28)
+#define NOISE_SAMPLE_NUM_SHIFT		16
+#define NOISE_SAMPLE_NUM_MASK		GENMASK(25, 16)
+#define NOISE_SAMPLE_NUM		((x) << NOISE_SAMPLE_NUM_SHIFT)
+#define SOUND_THD_MASK			GENMASK(15, 0)
+#define SOUND_THD(x)			(x)
+
+#define VAD_DET_CON2			0x64
+#define IIR_B0_SHIFT			16
+#define IIR_B0_MASK			GENMASK(31, 16)
+#define IIR_B0(x)			((x) << IIR_B0_SHIFT)
+#define NOISE_ALPHA_SHIFT		8
+#define NOISE_ALPHA_MASK		GENMASK(15, 8)
+#define NOISE_ALPHA(x)			((x) << NOISE_ALPHA_SHIFT)
+#define NOISE_FRM_NUM_MASK		GENMASK(6, 0)
+#define NOISE_FRM_NUM(x)		(x)
+
+#define VAD_DET_CON3			0x68
+#define IIR_B2_MASK			GENMASK(31, 16)
+#define IIR_B2(x)			((x) << 16)
+#define IIR_B1_MASK			GENMASK(15, 0)
+#define IIR_B1(x)			(x)
+
+#define VAD_DET_CON4			0x6c
+#define IIR_A2_MASK			GENMASK(31, 16)
+#define IIR_A2(x)			((x) << 16)
+#define IIR_A1_MASK			GENMASK(15, 0)
+#define IIR_A1(x)			(x)
+
+#define VAD_DET_CON5			0x70
+#define IIR_RESULT_SHIFT		16
+#define IIR_RESULT_MASK			GENMASK(31, 16)
+#define NOISE_ABS_MASK			GENMASK(15, 0)
+#define NOISE_ABS(x)			(x)
+
+#define VAD_INT				0x74
+#define VAD_DATA_TRANS_INT_FLAG_MASK	BIT(11)
+#define VAD_DATA_TRANS_INT_EN_MASK	BIT(10)
+#define VAD_DATA_TRANS_INT_EN		BIT(10)
+#define VAD_IDLE_MASK			BIT(9)
+#define RAM_LOOP_FLGA_MASK		BIT(8)
+#define WORK_TIMEOUT_FLAG_MASK		BIT(7)
+#define IDLE_TIMEOUT_FLAG_MASK		BIT(6)
+#define ERR_INT_FLAG_MASK		BIT(5)
+#define VAD_DET_INT_FLAG_MASK		BIT(4)
+#define WORK_TIMEOUT_INT_EN_MASK	BIT(3)
+#define WORK_TIMEOUT_INT_EN		BIT(3)
+#define IDLE_TIMEOUT_INT_EN_MASK	BIT(2)
+#define IDLE_TIMEOUT_INT_EN		BIT(2)
+#define ERR_INT_EN_MASK			BIT(1)
+#define ERR_INT_EN			BIT(1)
+#define VAD_DET_INT_EN_MASK		BIT(0)
+#define VAD_DET_INT_EN			BIT(0)
+
+#define VAD_AUX_CONTROL			0x78
+#define SAMPLE_CNT_EN_MASK		BIT(29)
+#define SAMPLE_CNT_EN			BIT(29)
+#define SAMPLE_CNT_DIS			0
+#define INT_TRIG_CTRL_EN_MASK		BIT(28)
+#define INT_TRIG_CTRL_EN		BIT(28)
+#define INT_TRIG_CTRL_DIS		0
+#define INT_TRIG_VALID_THD_MASK		GENMASK(27, 16)
+#define INT_TRIG_VALID_THD(x)		(((x) - 1) << 16)
+#define DATA_TRANS_KBYTE_THD_MASK	GENMASK(11, 4)
+#define DATA_TRANS_KBYTE_THD(x)		(((x) - 1) << 4)
+#define DATA_TRANS_TRIG_INT_EN_MASK	BIT(2)
+#define DATA_TRANS_TRIG_INT_EN		BIT(2)
+#define DATA_TRANS_TRIG_INT_DIS		0
+#define RAM_ITF_EN_MASK			BIT(1)
+#define RAM_ITF_EN			0
+#define RAM_ITF_DIS			BIT(1)
+#define BUS_WRITE_EN_MASK		BIT(0)
+#define BUS_WRITE_EN			BIT(0)
+#define BUS_WRITE_DIS			0
+
+#define VAD_SAMPLE_CNT			0x7c
+#define VAD_NOISE_DATA			0x100
+
+/* RK1808 SOC */
+#define RK1808_I2S0			0xff7e0800
+#define RK1808_I2S1			0xff7f0800
+#define RK1808_PDM			0xff800400
+
+/* RK3308 SOC */
+#define ACODEC_BASE			0xff560000
+#define ACODEC_ADC_ANA_CON0		0X340
+
+#define RK3308_I2S_8CH_0		0xff300800
+#define RK3308_I2S_8CH_1		0xff310800
+#define RK3308_I2S_8CH_2		0xff320800
+#define RK3308_I2S_8CH_3		0xff330800
+#define RK3308_PDM_8CH			0xff380400
+
+/* RK3568 SOC */
+#define RK3568_I2S_8CH_1		0xfe410800
+#define RK3568_I2S_2CH_2		0xfe420800
+#define RK3568_I2S_2CH_3		0xfe430800
+#define RK3568_PDM			0xfe440400
+
+/* RK3588 SOC */
+#define RK3588_I2S1_8CH			0xfe480800
+#define RK3588_PDM0			0xfe4b0400
+
+#endif
diff --git a/sound/soc/rockchip/vad_preprocess.h b/sound/soc/rockchip/vad_preprocess.h
new file mode 100644
index 000000000..85e4d1022
--- /dev/null
+++ b/sound/soc/rockchip/vad_preprocess.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip VAD Preprocess
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_VAD_PREPROCESS_H
+#define _ROCKCHIP_VAD_PREPROCESS_H
+
+struct vad_params {
+	int noise_abs;
+	int noise_level;
+	int sound_thd;
+	int vad_con_thd;
+	int voice_gain;
+};
+
+struct vad_uparams {
+	int noise_abs;
+};
+
+void vad_preprocess_init(struct vad_params *params);
+void vad_preprocess_destroy(void);
+void vad_preprocess_update_params(struct vad_uparams *uparams);
+int vad_preprocess(int data);
+
+#endif
diff --git a/sound/soc/rockchip/vad_preprocess_arm.S b/sound/soc/rockchip/vad_preprocess_arm.S
new file mode 100644
index 000000000..a0d3eabf2
--- /dev/null
+++ b/sound/soc/rockchip/vad_preprocess_arm.S
@@ -0,0 +1,348 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip VAD Preprocess
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+	.arch armv7-a
+	.fpu softvfp
+	.eabi_attribute 20, 1
+	.eabi_attribute 21, 1
+	.eabi_attribute 23, 3
+	.eabi_attribute 24, 1
+	.eabi_attribute 25, 1
+	.eabi_attribute 26, 2
+	.eabi_attribute 30, 4
+	.eabi_attribute 34, 1
+	.eabi_attribute 18, 4
+	.file	"vad_preprocess_arm.S"
+	.text
+	.align	2
+	.global	vad_preprocess_init
+	.type	vad_preprocess_init, %function
+vad_preprocess_init:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	@ link register save eliminated.
+	ldr	r2, .L4
+	ldr	r3, [r0, #8]
+	strh	r3, [r2]	@ movhi
+	ldr	r3, [r0, #4]
+	strh	r3, [r2, #2]	@ movhi
+	ldr	r3, [r0, #12]
+	strh	r3, [r2, #4]	@ movhi
+	ldr	r3, [r0]
+	strh	r3, [r2, #6]	@ movhi
+	ldr	r3, [r0, #16]
+	tst	r3, #512
+	ubfx	r3, r3, #0, #9
+	eorne	r3, r3, #65280
+	eorne	r3, r3, #255
+	uxtheq	r3, r3
+	strh	r3, [r2, #8]	@ movhi
+	bx	lr
+.L5:
+	.align	2
+.L4:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_init, .-vad_preprocess_init
+	.align	2
+	.global	vad_preprocess
+	.type	vad_preprocess, %function
+vad_preprocess:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	ldr	r3, .L27
+	stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
+	.save {r4, r5, r6, r7, r8, r9, lr}
+	movw	lr, #15349
+	ldrsh	r2, [r3, #8]
+	ldrh	ip, [r3, #10]
+	ldr	r1, .L27+4
+	mul	r0, r2, r0
+	ldrh	r4, [r3, #12]
+	smulbb	r1, ip, r1
+	add	r2, r0, #31
+	cmp	r0, #0
+	movlt	r0, r2
+	ldrh	r2, [r3, #14]
+	mov	r0, r0, asr #5
+	mla	r1, lr, r0, r1
+	smlabb	r1, r4, lr, r1
+	ldr	r4, .L27+8
+	ldrsh	lr, [r3, #16]
+	smulbb	r4, r2, r4
+	rsb	r4, r4, r1
+	movw	r1, #14379
+	mls	r4, lr, r1, r4
+	cmp	r4, #1
+	mov	r5, r4, asr #31
+	sbcs	r1, r5, #0
+	blt	.L7
+	adds	r4, r4, #8192
+	adc	r5, r5, #0
+	b	.L24
+.L7:
+	subs	r4, r4, #8192
+	movw	r8, #16383
+	sbc	r5, r5, #0
+	mov	r9, #0
+	mov	r6, r5, asr #31
+	mov	r7, r6, asr #31
+	and	r6, r6, r8
+	and	r7, r7, r9
+	adds	r4, r4, r6
+	adc	r5, r5, r7
+.L24:
+	strh	ip, [r3, #12]	@ movhi
+	mov	r1, r4, lsr #14
+	ldrh	ip, [r3, #18]
+	orr	r1, r1, r5, asl #18
+	strh	r0, [r3, #10]	@ movhi
+	add	ip, ip, #1
+	uxth	r1, r1
+	ldr	r0, .L27+12
+	uxth	ip, ip
+	strh	r1, [r3, #14]	@ movhi
+	strh	ip, [r3, #18]	@ movhi
+	sxth	r1, r1
+	sxth	ip, ip
+	cmp	r1, #0
+	and	r0, r0, ip
+	rsblt	r1, r1, #0
+	cmp	r0, #0
+	strh	r2, [r3, #16]	@ movhi
+	sublt	r0, r0, #1
+	ldr	r2, [r3, #20]
+	mvnlt	r0, r0, asl #24
+	add	r2, r1, r2
+	mvnlt	r0, r0, lsr #24
+	addlt	r0, r0, #1
+	cmp	r0, #0
+	str	r2, [r3, #20]
+	bne	.L9
+	ldr	r0, [r3, #24]
+	ldr	ip, .L27
+	cmp	r0, #99
+	bgt	.L11
+	add	r2, r2, #128
+	add	ip, ip, r0, asl #1
+	add	lr, r2, #255
+	cmp	r2, #0
+	movlt	r2, lr
+	mov	r2, r2, asr #8
+	strh	r2, [ip, #28]	@ movhi
+	b	.L12
+.L11:
+	add	lr, ip, #28
+	add	ip, ip, #226
+.L13:
+	ldrh	r4, [lr, #2]
+	strh	r4, [lr], #2	@ movhi
+	cmp	lr, ip
+	bne	.L13
+	add	r2, r2, #128
+	add	ip, r2, #255
+	cmp	r2, #0
+	movlt	r2, ip
+	mov	r2, r2, asr #8
+	strh	r2, [r3, #226]	@ movhi
+.L12:
+	cmp	r0, #99
+	ldrh	r2, [r3, #28]
+	ldrle	r4, .L27+16
+	movle	lr, #1
+	bgt	.L26
+.L15:
+	cmp	lr, r0
+	bge	.L17
+	ldrsh	ip, [r4], #2
+	sxth	r2, r2
+	add	lr, lr, #1
+	cmp	ip, r2
+	movge	ip, r2
+	uxth	r2, ip
+	b	.L15
+.L26:
+	ldr	ip, .L27+16
+	add	r4, ip, #198
+.L18:
+	ldrsh	lr, [ip], #2
+	sxth	r2, r2
+	cmp	r2, lr
+	movge	r2, lr
+	cmp	ip, r4
+	uxth	r2, r2
+	bne	.L18
+.L17:
+	ldrh	lr, [r3, #6]
+	mov	ip, #128
+	mov	r4, #230
+	add	r0, r0, #1
+	str	r0, [r3, #24]
+	smlabb	ip, lr, r4, ip
+	mov	lr, #26
+	smlabb	r2, r2, lr, ip
+	add	ip, r2, #255
+	cmp	r2, #0
+	movlt	r2, ip
+	mov	r2, r2, asr #8
+	strh	r2, [r3, #6]	@ movhi
+	mov	r2, #0
+	str	r2, [r3, #20]
+	strh	r2, [r3, #18]	@ movhi
+.L9:
+	ldrh	r2, [r3, #6]
+	ldrh	ip, [r3, #2]
+	ldrsh	r3, [r3]
+	ldr	r0, .L27
+	smlabb	r3, r2, ip, r3
+	add	r2, r0, #428
+	cmp	r1, r3
+	ble	.L19
+	ldrh	r3, [r2]
+	ldrsh	r0, [r0, #4]
+	add	r3, r3, #1
+	uxth	r3, r3
+	strh	r3, [r2]	@ movhi
+	sxth	r3, r3
+	cmp	r0, r3
+	movge	r0, #0
+	movlt	r0, #1
+	ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
+.L19:
+	mov	r0, #0
+	strh	r0, [r2]	@ movhi
+	ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
+.L28:
+	.align	2
+.L27:
+	.word	.LANCHOR0
+	.word	-30697
+	.word	-30632
+	.word	-2147483393
+	.word	.LANCHOR0+30
+	.fnend
+	.size	vad_preprocess, .-vad_preprocess
+	.align	2
+	.global	vad_preprocess_destroy
+	.type	vad_preprocess_destroy, %function
+vad_preprocess_destroy:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	@ link register save eliminated.
+	ldr	r2, .L32
+	mov	r3, #0
+	mov	ip, r3
+	strh	r3, [r2, #10]	@ movhi
+	strh	r3, [r2, #12]	@ movhi
+	strh	r3, [r2, #14]	@ movhi
+	strh	r3, [r2, #16]	@ movhi
+	strh	r3, [r2, #18]	@ movhi
+	add	r2, r2, #428
+	strh	r3, [r2]	@ movhi
+.L30:
+	ldr	r2, .L32
+	mov	r1, #0
+	add	r0, r2, #28
+	strh	ip, [r3, r0]	@ movhi
+	add	r3, r3, #2
+	cmp	r3, #200
+	bne	.L30
+	mov	r3, #32
+	str	r1, [r2, #20]
+	strh	r1, [r2, #6]	@ movhi
+	strh	r3, [r2, #8]	@ movhi
+	str	r1, [r2, #24]
+	bx	lr
+.L33:
+	.align	2
+.L32:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_destroy, .-vad_preprocess_destroy
+	.align	2
+	.global	vad_preprocess_update_params
+	.type	vad_preprocess_update_params, %function
+vad_preprocess_update_params:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	@ link register save eliminated.
+	ldr	r3, .L35
+	ldrsh	r3, [r3, #6]
+	str	r3, [r0]
+	bx	lr
+.L36:
+	.align	2
+.L35:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_update_params, .-vad_preprocess_update_params
+	.bss
+	.align	2
+.LANCHOR0 = . + 0
+	.type	g_sound_thd, %object
+	.size	g_sound_thd, 2
+g_sound_thd:
+	.space	2
+	.type	g_noise_level, %object
+	.size	g_noise_level, 2
+g_noise_level:
+	.space	2
+	.type	g_vad_con_thd, %object
+	.size	g_vad_con_thd, 2
+g_vad_con_thd:
+	.space	2
+	.type	g_noise_abs, %object
+	.size	g_noise_abs, 2
+g_noise_abs:
+	.space	2
+	.type	g_signal_gain, %object
+	.size	g_signal_gain, 2
+g_signal_gain:
+	.space	2
+	.type	g_xn_1, %object
+	.size	g_xn_1, 2
+g_xn_1:
+	.space	2
+	.type	g_xn_2, %object
+	.size	g_xn_2, 2
+g_xn_2:
+	.space	2
+	.type	g_yn_1, %object
+	.size	g_yn_1, 2
+g_yn_1:
+	.space	2
+	.type	g_yn_2, %object
+	.size	g_yn_2, 2
+g_yn_2:
+	.space	2
+	.type	g_sample_cnt, %object
+	.size	g_sample_cnt, 2
+g_sample_cnt:
+	.space	2
+	.type	g_sum_abs_frm, %object
+	.size	g_sum_abs_frm, 4
+g_sum_abs_frm:
+	.space	4
+	.type	frm_count, %object
+	.size	frm_count, 4
+frm_count:
+	.space	4
+	.type	g_ave_abs_rec, %object
+	.size	g_ave_abs_rec, 400
+g_ave_abs_rec:
+	.space	400
+	.type	g_vad_cnt, %object
+	.size	g_vad_cnt, 2
+g_vad_cnt:
+	.space	2
+	.ident	"GCC: (GNU) 4.9 20150123 (prerelease)"
+	.section	.note.GNU-stack,"",%progbits
diff --git a/sound/soc/rockchip/vad_preprocess_arm64.S b/sound/soc/rockchip/vad_preprocess_arm64.S
new file mode 100644
index 000000000..823757c17
--- /dev/null
+++ b/sound/soc/rockchip/vad_preprocess_arm64.S
@@ -0,0 +1,273 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip VAD Preprocess
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+	.arch armv8-a
+	.file	"vad_preprocess_arm64.S"
+	.text
+	.align	2
+	.global	vad_preprocess_init
+	.type	vad_preprocess_init, %function
+vad_preprocess_init:
+	adrp	x2, .LANCHOR0
+	add	x1, x2, :lo12:.LANCHOR0
+	ldr	w3, [x0, 8]
+	strh	w3, [x2, #:lo12:.LANCHOR0]
+	ldr	w2, [x0, 4]
+	strh	w2, [x1, 2]
+	ldr	w2, [x0, 12]
+	strh	w2, [x1, 4]
+	ldr	w2, [x0]
+	strh	w2, [x1, 6]
+	ldr	w2, [x0, 16]
+	and	w0, w2, 511
+	tbz	x2, 9, .L2
+	mvn	w0, w0
+.L2:
+	strh	w0, [x1, 8]
+	ret
+	.size	vad_preprocess_init, .-vad_preprocess_init
+	.align	2
+	.global	vad_preprocess
+	.type	vad_preprocess, %function
+vad_preprocess:
+	adrp	x4, .LANCHOR0
+	add	x2, x4, :lo12:.LANCHOR0
+	mov	w8, 15349
+	ldrsh	w1, [x2, 8]
+	ldrsh	w7, [x2, 10]
+	ldrsh	w6, [x2, 12]
+	ldrsh	w3, [x2, 16]
+	mul	w0, w1, w0
+	mov	w1, 32
+	sdiv	w0, w0, w1
+	ldrsh	w1, [x2, 14]
+	mov	w2, -30697
+	mul	w2, w7, w2
+	mul	w5, w0, w8
+	sxtw	x2, w2
+	add	x2, x2, w5, sxtw
+	smaddl	x3, w3, w8, x2
+	mov	w2, -30632
+	smsubl	x2, w6, w2, x3
+	mov	w3, 14379
+	smsubl	x1, w1, w3, x2
+	cmp	x1, 0
+	ble	.L5
+	add	x1, x1, 8192
+	asr	x1, x1, 14
+.L6:
+	add	x2, x4, :lo12:.LANCHOR0
+	sxth	w1, w1
+	cmp	w1, 0
+	ldrh	w3, [x2, 18]
+	strh	w0, [x2, 10]
+	add	w3, w3, 1
+	ldr	w0, [x2, 20]
+	sxth	w3, w3
+	strh	w1, [x2, 12]
+	csneg	w1, w1, w1, ge
+	strh	w3, [x2, 18]
+	negs	w5, w3
+	add	w0, w1, w0
+	strh	w7, [x2, 16]
+	and	w3, w3, 255
+	strh	w6, [x2, 14]
+	and	w5, w5, 255
+	str	w0, [x2, 20]
+	csneg	w3, w3, w5, mi
+	cbnz	w3, .L7
+	ldr	w3, [x2, 24]
+	cmp	w3, 99
+	bgt	.L8
+	add	w0, w0, 128
+	mov	w5, 256
+	add	x2, x2, 32
+	sdiv	w0, w0, w5
+	strh	w0, [x2, w3, sxtw 1]
+.L9:
+	add	x2, x4, :lo12:.LANCHOR0
+	cmp	w3, 99
+	ldrsh	w0, [x2, 32]
+	bgt	.L11
+	add	x2, x2, 32
+	mov	x5, 0
+.L12:
+	add	x5, x5, 1
+	cmp	w3, w5
+	bgt	.L13
+.L14:
+	add	x2, x4, :lo12:.LANCHOR0
+	mov	w6, 230
+	add	w3, w3, 1
+	ldrsh	w5, [x2, 6]
+	strh	wzr, [x2, 18]
+	stp	wzr, w3, [x2, 20]
+	mul	w5, w5, w6
+	mov	w6, 26
+	add	w5, w5, 128
+	madd	w0, w0, w6, w5
+	mov	w5, 256
+	sdiv	w0, w0, w5
+	strh	w0, [x2, 6]
+.L7:
+	add	x0, x4, :lo12:.LANCHOR0
+	ldrsh	w3, [x4, #:lo12:.LANCHOR0]
+	ldrsh	w2, [x0, 6]
+	ldrsh	w5, [x0, 2]
+	madd	w2, w2, w5, w3
+	cmp	w1, w2
+	ble	.L16
+	ldrh	w1, [x0, 432]
+	add	w1, w1, 1
+	sxth	w1, w1
+	strh	w1, [x0, 432]
+	ldrsh	w0, [x0, 4]
+	cmp	w0, w1
+	cset	w0, lt
+	ret
+.L5:
+	sub	x1, x1, #8192
+	mov	x2, 16384
+	sdiv	x1, x1, x2
+	b	.L6
+.L8:
+	add	x5, x2, 34
+	add	x2, x2, 232
+.L10:
+	ldrh	w6, [x5]
+	add	x5, x5, 2
+	strh	w6, [x5, -4]
+	cmp	x2, x5
+	bne	.L10
+	add	w0, w0, 128
+	mov	w5, 256
+	add	x2, x4, :lo12:.LANCHOR0
+	sdiv	w0, w0, w5
+	strh	w0, [x2, 230]
+	b	.L9
+.L13:
+	lsl	x6, x5, 1
+	ldrsh	w7, [x6, x2]
+	ldrh	w6, [x6, x2]
+	cmp	w7, w0
+	csel	w0, w6, w0, le
+	sxth	w0, w0
+	b	.L12
+.L11:
+	add	x5, x2, 34
+	add	x2, x2, 232
+.L15:
+	ldrsh	w7, [x5]
+	ldrh	w6, [x5], 2
+	cmp	w7, w0
+	csel	w0, w6, w0, le
+	cmp	x2, x5
+	sxth	w0, w0
+	bne	.L15
+	b	.L14
+.L16:
+	strh	wzr, [x0, 432]
+	mov	w0, 0
+	ret
+	.size	vad_preprocess, .-vad_preprocess
+	.align	2
+	.global	vad_preprocess_destroy
+	.type	vad_preprocess_destroy, %function
+vad_preprocess_destroy:
+	adrp	x0, .LANCHOR0
+	add	x0, x0, :lo12:.LANCHOR0
+	add	x2, x0, 32
+	mov	x1, 0
+	strh	wzr, [x0, 10]
+	strh	wzr, [x0, 16]
+	strh	wzr, [x0, 12]
+	strh	wzr, [x0, 14]
+	strh	wzr, [x0, 18]
+	strh	wzr, [x0, 432]
+.L21:
+	strh	wzr, [x1, x2]
+	add	x1, x1, 2
+	cmp	x1, 200
+	bne	.L21
+	mov	w1, 32
+	strh	wzr, [x0, 6]
+	strh	w1, [x0, 8]
+	stp	wzr, wzr, [x0, 20]
+	ret
+	.size	vad_preprocess_destroy, .-vad_preprocess_destroy
+	.align	2
+	.global	vad_preprocess_update_params
+	.type	vad_preprocess_update_params, %function
+vad_preprocess_update_params:
+	adrp	x1, .LANCHOR0+6
+	ldrsh	w1, [x1, #:lo12:.LANCHOR0+6]
+	str	w1, [x0]
+	ret
+	.size	vad_preprocess_update_params, .-vad_preprocess_update_params
+	.bss
+	.align	3
+	.set	.LANCHOR0,. + 0
+	.type	g_sound_thd, %object
+	.size	g_sound_thd, 2
+g_sound_thd:
+	.zero	2
+	.type	g_noise_level, %object
+	.size	g_noise_level, 2
+g_noise_level:
+	.zero	2
+	.type	g_vad_con_thd, %object
+	.size	g_vad_con_thd, 2
+g_vad_con_thd:
+	.zero	2
+	.type	g_noise_abs, %object
+	.size	g_noise_abs, 2
+g_noise_abs:
+	.zero	2
+	.type	g_signal_gain, %object
+	.size	g_signal_gain, 2
+g_signal_gain:
+	.zero	2
+	.type	g_xn_1, %object
+	.size	g_xn_1, 2
+g_xn_1:
+	.zero	2
+	.type	g_yn_1, %object
+	.size	g_yn_1, 2
+g_yn_1:
+	.zero	2
+	.type	g_yn_2, %object
+	.size	g_yn_2, 2
+g_yn_2:
+	.zero	2
+	.type	g_xn_2, %object
+	.size	g_xn_2, 2
+g_xn_2:
+	.zero	2
+	.type	g_sample_cnt, %object
+	.size	g_sample_cnt, 2
+g_sample_cnt:
+	.zero	2
+	.type	g_sum_abs_frm, %object
+	.size	g_sum_abs_frm, 4
+g_sum_abs_frm:
+	.zero	4
+	.type	frm_count, %object
+	.size	frm_count, 4
+frm_count:
+	.zero	4
+	.zero	4
+	.type	g_ave_abs_rec, %object
+	.size	g_ave_abs_rec, 400
+g_ave_abs_rec:
+	.zero	400
+	.type	g_vad_cnt, %object
+	.size	g_vad_cnt, 2
+g_vad_cnt:
+	.zero	2
+	.ident	"GCC: (Linaro GCC 6.3-2017.05) 6.3.1 20170404"
+	.section	.note.GNU-stack,"",@progbits
diff --git a/sound/soc/rockchip/vad_preprocess_thumb.S b/sound/soc/rockchip/vad_preprocess_thumb.S
new file mode 100644
index 000000000..a105634e6
--- /dev/null
+++ b/sound/soc/rockchip/vad_preprocess_thumb.S
@@ -0,0 +1,360 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip VAD Preprocess
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+	.syntax unified
+	.arch armv7-a
+	.fpu softvfp
+	.eabi_attribute 20, 1
+	.eabi_attribute 21, 1
+	.eabi_attribute 23, 3
+	.eabi_attribute 24, 1
+	.eabi_attribute 25, 1
+	.eabi_attribute 26, 2
+	.eabi_attribute 30, 4
+	.eabi_attribute 34, 1
+	.eabi_attribute 18, 4
+	.thumb
+	.file	"vad_preprocess_thumb.S"
+	.text
+	.align	1
+	.global	vad_preprocess_init
+	.thumb
+	.thumb_func
+	.type	vad_preprocess_init, %function
+vad_preprocess_init:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	@ link register save eliminated.
+	ldr	r2, .L4
+	ldr	r3, [r0, #8]
+	strh	r3, [r2]	@ movhi
+	ldr	r3, [r0, #4]
+	strh	r3, [r2, #2]	@ movhi
+	ldr	r3, [r0, #12]
+	strh	r3, [r2, #4]	@ movhi
+	ldr	r3, [r0]
+	strh	r3, [r2, #6]	@ movhi
+	ldr	r3, [r0, #16]
+	tst	r3, #512
+	ubfx	r3, r3, #0, #9
+	itte	ne
+	eorne	r3, r3, #65280
+	eorne	r3, r3, #255
+	uxtheq	r3, r3
+	strh	r3, [r2, #8]	@ movhi
+	bx	lr
+.L5:
+	.align	2
+.L4:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_init, .-vad_preprocess_init
+	.align	1
+	.global	vad_preprocess
+	.thumb
+	.thumb_func
+	.type	vad_preprocess, %function
+vad_preprocess:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	ldr	r3, .L29
+	movw	r2, #34839
+	push	{r4, r5, r6, r7, r8, r9, lr}
+	.save {r4, r5, r6, r7, r8, r9, lr}
+	movw	r1, #15349
+	ldrsh	r5, [r3, #8]
+	muls	r0, r5, r0
+	ldrh	r7, [r3, #10]
+	it	mi
+	addmi	r0, r0, #31
+	ldrh	r4, [r3, #12]
+	asrs	r0, r0, #5
+	ldrh	r6, [r3, #14]
+	smulbb	r2, r7, r2
+	mla	r2, r1, r0, r2
+	smlabb	r2, r4, r1, r2
+	movw	r1, #34904
+	smulbb	r1, r6, r1
+	ldrsh	r4, [r3, #16]
+	subs	r1, r2, r1
+	movw	r2, #14379
+	mls	r4, r4, r2, r1
+	cmp	r4, #1
+	asr	r5, r4, #31
+	sbcs	r2, r5, #0
+	blt	.L8
+	adds	r4, r4, #8192
+	adc	r5, r5, #0
+	b	.L10
+.L8:
+	subs	r4, r4, #8192
+	adc	r5, r5, #-1
+	cmp	r4, #0
+	sbcs	r2, r5, #0
+	bge	.L10
+	movw	r8, #16383
+	mov	r9, #0
+	adds	r4, r4, r8
+	adc	r5, r5, r9
+.L10:
+	lsrs	r1, r4, #14
+	ldrh	r4, [r3, #18]
+	orr	r1, r1, r5, lsl #18
+	ldr	r2, .L29+4
+	adds	r4, r4, #1
+	strh	r0, [r3, #10]	@ movhi
+	uxth	r1, r1
+	strh	r1, [r3, #14]	@ movhi
+	uxth	r4, r4
+	strh	r4, [r3, #18]	@ movhi
+	sxth	r1, r1
+	ldr	r0, [r3, #20]
+	sxth	r4, r4
+	cmp	r1, #0
+	and	r2, r2, r4
+	it	lt
+	rsblt	r1, r1, #0
+	cmp	r2, #0
+	add	r0, r0, r1
+	it	lt
+	addlt	r2, r2, #-1
+	strh	r7, [r3, #12]	@ movhi
+	it	lt
+	ornlt	r2, r2, #255
+	strh	r6, [r3, #16]	@ movhi
+	it	lt
+	addlt	r2, r2, #1
+	str	r0, [r3, #20]
+	cmp	r2, #0
+	bne	.L11
+	ldr	r4, [r3, #24]
+	ldr	r2, .L29
+	cmp	r4, #99
+	bgt	.L13
+	adds	r5, r0, #128
+	add	r2, r2, r4, lsl #1
+	it	mi
+	addwmi	r5, r0, #383
+	asrs	r5, r5, #8
+	strh	r5, [r2, #28]	@ movhi
+	b	.L15
+.L13:
+	add	r5, r2, #28
+	adds	r2, r2, #226
+.L16:
+	ldrh	r6, [r5, #2]
+	strh	r6, [r5], #2	@ movhi
+	cmp	r5, r2
+	bne	.L16
+	adds	r2, r0, #128
+	it	mi
+	addwmi	r2, r0, #383
+	ldr	r0, .L29
+	asrs	r2, r2, #8
+	strh	r2, [r0, #226]	@ movhi
+.L15:
+	cmp	r4, #99
+	ldrh	r2, [r3, #28]
+	mov	r0, #1
+	bgt	.L18
+	ldr	r5, .L29+8
+.L19:
+	cmp	r0, r4
+	bge	.L21
+	ldrsh	r6, [r5, r0, lsl #1]
+	sxth	r2, r2
+	adds	r0, r0, #1
+	cmp	r2, r6
+	it	ge
+	movge	r2, r6
+	uxth	r2, r2
+	b	.L19
+.L18:
+	ldr	r6, .L29+8
+.L22:
+	ldrsh	r5, [r6, r0, lsl #1]
+	sxth	r2, r2
+	adds	r0, r0, #1
+	cmp	r2, r5
+	it	ge
+	movge	r2, r5
+	cmp	r0, #100
+	uxth	r2, r2
+	bne	.L22
+.L21:
+	ldrh	r5, [r3, #6]
+	movs	r0, #128
+	movs	r6, #230
+	adds	r4, r4, #1
+	str	r4, [r3, #24]
+	smlabb	r0, r5, r6, r0
+	movs	r5, #26
+	smlabb	r2, r2, r5, r0
+	ldr	r0, .L29
+	cmp	r2, #0
+	it	lt
+	addlt	r2, r2, #255
+	asrs	r2, r2, #8
+	strh	r2, [r0, #6]	@ movhi
+	movs	r2, #0
+	str	r2, [r3, #20]
+	strh	r2, [r3, #18]	@ movhi
+.L11:
+	ldrh	r0, [r3, #6]
+	ldrh	r4, [r3, #2]
+	ldrsh	r3, [r3]
+	ldr	r2, .L29
+	smlabb	r3, r0, r4, r3
+	cmp	r1, r3
+	ble	.L24
+	ldrh	r3, [r2, #428]
+	ldrsh	r0, [r2, #4]
+	adds	r3, r3, #1
+	uxth	r3, r3
+	strh	r3, [r2, #428]	@ movhi
+	sxth	r3, r3
+	cmp	r0, r3
+	ite	ge
+	movge	r0, #0
+	movlt	r0, #1
+	pop	{r4, r5, r6, r7, r8, r9, pc}
+.L24:
+	movs	r0, #0
+	strh	r0, [r2, #428]	@ movhi
+	pop	{r4, r5, r6, r7, r8, r9, pc}
+.L30:
+	.align	2
+.L29:
+	.word	.LANCHOR0
+	.word	-2147483393
+	.word	.LANCHOR0+28
+	.fnend
+	.size	vad_preprocess, .-vad_preprocess
+	.align	1
+	.global	vad_preprocess_destroy
+	.thumb
+	.thumb_func
+	.type	vad_preprocess_destroy, %function
+vad_preprocess_destroy:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	movs	r3, #0
+	ldr	r2, .L34
+	push	{r4, lr}
+	.save {r4, lr}
+	mov	r4, r3
+	strh	r3, [r2, #10]	@ movhi
+	strh	r3, [r2, #12]	@ movhi
+	strh	r3, [r2, #14]	@ movhi
+	strh	r3, [r2, #16]	@ movhi
+	strh	r3, [r2, #18]	@ movhi
+	strh	r3, [r2, #428]	@ movhi
+.L32:
+	ldr	r2, .L34
+	movs	r1, #0
+	add	r0, r2, #28
+	strh	r4, [r0, r3, lsl #1]	@ movhi
+	adds	r3, r3, #1
+	cmp	r3, #100
+	bne	.L32
+	movs	r3, #32
+	str	r1, [r2, #20]
+	strh	r1, [r2, #6]	@ movhi
+	strh	r3, [r2, #8]	@ movhi
+	str	r1, [r2, #24]
+	pop	{r4, pc}
+.L35:
+	.align	2
+.L34:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_destroy, .-vad_preprocess_destroy
+	.align	1
+	.global	vad_preprocess_update_params
+	.thumb
+	.thumb_func
+	.type	vad_preprocess_update_params, %function
+vad_preprocess_update_params:
+	.fnstart
+	@ args = 0, pretend = 0, frame = 0
+	@ frame_needed = 0, uses_anonymous_args = 0
+	@ link register save eliminated.
+	ldr	r3, .L37
+	ldrsh	r3, [r3, #6]
+	str	r3, [r0]
+	bx	lr
+.L38:
+	.align	2
+.L37:
+	.word	.LANCHOR0
+	.fnend
+	.size	vad_preprocess_update_params, .-vad_preprocess_update_params
+	.bss
+	.align	2
+.LANCHOR0 = . + 0
+	.type	g_sound_thd, %object
+	.size	g_sound_thd, 2
+g_sound_thd:
+	.space	2
+	.type	g_noise_level, %object
+	.size	g_noise_level, 2
+g_noise_level:
+	.space	2
+	.type	g_vad_con_thd, %object
+	.size	g_vad_con_thd, 2
+g_vad_con_thd:
+	.space	2
+	.type	g_noise_abs, %object
+	.size	g_noise_abs, 2
+g_noise_abs:
+	.space	2
+	.type	g_signal_gain, %object
+	.size	g_signal_gain, 2
+g_signal_gain:
+	.space	2
+	.type	g_xn_1, %object
+	.size	g_xn_1, 2
+g_xn_1:
+	.space	2
+	.type	g_xn_2, %object
+	.size	g_xn_2, 2
+g_xn_2:
+	.space	2
+	.type	g_yn_1, %object
+	.size	g_yn_1, 2
+g_yn_1:
+	.space	2
+	.type	g_yn_2, %object
+	.size	g_yn_2, 2
+g_yn_2:
+	.space	2
+	.type	g_sample_cnt, %object
+	.size	g_sample_cnt, 2
+g_sample_cnt:
+	.space	2
+	.type	g_sum_abs_frm, %object
+	.size	g_sum_abs_frm, 4
+g_sum_abs_frm:
+	.space	4
+	.type	frm_count, %object
+	.size	frm_count, 4
+frm_count:
+	.space	4
+	.type	g_ave_abs_rec, %object
+	.size	g_ave_abs_rec, 400
+g_ave_abs_rec:
+	.space	400
+	.type	g_vad_cnt, %object
+	.size	g_vad_cnt, 2
+g_vad_cnt:
+	.space	2
+	.ident	"GCC: (GNU) 4.9 20150123 (prerelease)"
+	.section	.note.GNU-stack,"",%progbits
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a45b27a2e..657c35354 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1523,6 +1523,9 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05a3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x05a7, 0x1020): /* Bose Companion 5 */
+#ifdef CONFIG_HID_RKVR
+	case USB_ID(0x071B, 0x3205): /* RockChip NanoC VR */
+#endif
 	case USB_ID(0x074d, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
@@ -1838,6 +1841,9 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 					  int stream)
 {
 	switch (chip->usb_id) {
+#ifdef CONFIG_HID_RKVR
+	case USB_ID(0x071B, 0x3205): /* RockChip NanoC VR */
+#endif
 	case USB_ID(0x0a92, 0x0053): /* AudioTrak Optoplay */
 		/* Optoplay sets the sample rate attribute although
 		 * it seems not supporting it in fact.
-- 
2.25.1

