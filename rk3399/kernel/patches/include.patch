From df3435536b976411eaa4d9e508dc73c3159e8319 Mon Sep 17 00:00:00 2001
From: jiewangdp <jiewangdp@isoftstone.com>
Date: Mon, 20 Jun 2022 21:09:18 +0800
Subject: [PATCH] include

Change-Id: I6404592276b7392a681ec25caa3d1f11b7e81438
---
 include/drm/bridge/analogix_dp.h              |   21 +
 include/drm/bridge/dw_hdmi.h                  |  119 +-
 include/drm/bridge/dw_mipi_dsi.h              |    1 +
 include/drm/drm_auth.h                        |    1 -
 include/drm/drm_connector.h                   |   54 +
 include/drm/drm_crtc.h                        |   11 +-
 include/drm/drm_drv.h                         |   10 +
 include/drm/drm_edid.h                        |  124 +-
 include/drm/drm_file.h                        |   21 +-
 include/drm/drm_mipi_dsi.h                    |   12 +
 include/drm/drm_mode_config.h                 |   13 +
 include/drm/drm_mode_object.h                 |    2 +-
 include/drm/drm_prime.h                       |    1 +
 include/drm/drm_sync_helper.h                 |  156 ++
 include/dt-bindings/clock/rk3399-cru.h        |   33 +-
 include/dt-bindings/clock/rockchip-ddr.h      |   63 +
 include/dt-bindings/clock/rockchip.h          |  101 +
 include/dt-bindings/display/drm_mipi_dsi.h    |   53 +
 .../dt-bindings/display/media-bus-format.h    |  152 ++
 include/dt-bindings/display/mipi_dsi.h        |  106 +
 include/dt-bindings/display/rockchip_vop.h    |   21 +
 include/dt-bindings/input/rk-input.h          |  814 ++++++++
 include/dt-bindings/memory/rk3399-dram.h      |  107 +
 include/dt-bindings/memory/rockchip-dram.h    |   94 +
 include/dt-bindings/phy/phy-snps-pcie3.h      |   21 +
 include/dt-bindings/sensor-dev.h              |   18 +
 include/dt-bindings/soc/rockchip,boot-mode.h  |   10 +-
 .../dt-bindings/soc/rockchip-system-status.h  |   48 +
 include/dt-bindings/suspend/rockchip-rk3399.h |   61 +
 include/linux/blk_types.h                     |    1 +
 include/linux/bpf.h                           |    3 +-
 include/linux/cgroup-defs.h                   |  111 +-
 include/linux/cgroup.h                        |   29 +-
 include/linux/clk-provider.h                  |    9 +
 include/linux/clk/rockchip.h                  |   18 +
 include/linux/cpufreq_times.h                 |   42 +
 include/linux/cpuset.h                        |    7 +-
 include/linux/dma-buf-cache.h                 |   32 +
 include/linux/dma-buf.h                       |  116 ++
 include/linux/dma-fence.h                     |    3 +
 include/linux/dma-heap.h                      |   62 +-
 include/linux/dma-iommu.h                     |   16 +
 include/linux/dma-map-ops.h                   |    8 +
 include/linux/dma-mapping.h                   |   17 +
 include/linux/dmaengine.h                     |    5 +
 include/linux/energy_model.h                  |   12 +-
 include/linux/extcon.h                        |    1 +
 include/linux/freezer.h                       |    6 +
 include/linux/initramfs.h                     |   40 +
 include/linux/iommu.h                         |   47 +-
 include/linux/iova.h                          |    1 +
 include/linux/irqchip/arm-gic-v3.h            |    2 +
 include/linux/irqchip/arm-gic-v4.h            |    4 +
 include/linux/memblock.h                      |   24 +-
 include/linux/memory_group_manager.h          |  198 ++
 include/linux/mfd/rk808.h                     |  453 +++-
 include/linux/mmc/host.h                      |    4 +
 include/linux/mmu_context.h                   |    8 +
 include/linux/phy/pcie.h                      |   12 +
 include/linux/phy/phy-rockchip-typec.h        |   34 +
 include/linux/phy/phy-rockchip-usbdp.h        |   70 +
 include/linux/power/bq25700-charge.h          |   20 +
 include/linux/power/cw2015_battery.h          |  119 ++
 include/linux/power/rk_usbbc.h                |   44 +
 include/linux/power_supply.h                  |   23 +
 include/linux/psi_types.h                     |    1 +
 include/linux/pwm.h                           |    3 +
 include/linux/reboot.h                        |   20 +
 include/linux/regulator/driver.h              |    3 +
 include/linux/regulator/fan53555.h            |    2 +
 include/linux/rfkill-bt.h                     |   72 +
 include/linux/rfkill-wlan.h                   |   62 +
 include/linux/rk_keys.h                       |   19 +
 include/linux/rockchip-iovmm.h                |   91 +
 include/linux/rockchip/cpu.h                  |   75 +
 include/linux/rockchip/psci.h                 |   76 +
 include/linux/rockchip/rockchip_sip.h         |  363 ++++
 include/linux/rockchip_ion.h                  |   41 +
 include/linux/sched.h                         |  145 +-
 include/linux/sched/core_ctl.h                |   14 -
 include/linux/sched/cpufreq.h                 |    3 -
 include/linux/sched/frame_rtg.h               |   75 -
 include/linux/sched/hotplug.h                 |    4 +
 include/linux/sched/isolation.h               |   19 -
 include/linux/sched/rtg.h                     |   65 -
 include/linux/sched/rtg_ctrl.h                |   99 -
 include/linux/sched/stat.h                    |    9 -
 include/linux/sched/wake_q.h                  |    2 +
 include/linux/sched/xacct.h                   |    9 +
 include/linux/sensor-dev.h                    |  349 ++++
 include/linux/soc/rockchip/pvtm.h             |   17 +
 include/linux/soc/rockchip/rk_fiq_debugger.h  |   22 +
 .../linux/soc/rockchip/rk_vendor_storage.h    |   58 +
 .../linux/soc/rockchip/rockchip_decompress.h  |   22 +
 .../rockchip/rockchip_thunderboot_crypto.h    |    9 +
 include/linux/stmmac.h                        |    1 +
 include/linux/stop_machine.h                  |   25 +-
 include/linux/thermal.h                       |    5 +
 include/linux/usb/audio-v2.h                  |   17 +
 include/linux/usb/audio.h                     |    1 +
 include/linux/usb/ch9.h                       |   62 +-
 include/linux/usb/composite.h                 |    3 +
 include/linux/usb/f_accessory.h               |   23 +
 include/linux/usb/gadget.h                    |   15 +
 include/linux/usb/pd.h                        |    7 +
 include/linux/usb/pd_ext_sdb.h                |    4 -
 include/linux/usb/pd_vdo.h                    |  314 ++-
 include/linux/usb/quirks.h                    |    3 +
 include/linux/usb/tcpm.h                      |   56 +-
 include/linux/usb/typec.h                     |   25 +
 include/linux/usb/typec_altmode.h             |   10 +
 include/linux/usb/typec_tbt.h                 |    6 +-
 include/linux/usb/usbnet.h                    |    2 -
 include/linux/wakelock.h                      |   76 +
 include/linux/wakeup_reason.h                 |   37 +
 include/media/tc35874x.h                      |  132 ++
 include/media/v4l2-async.h                    |   15 +
 include/soc/rockchip/pm_domains.h             |   53 +
 include/soc/rockchip/rkfb_dmc.h               |   11 +
 include/soc/rockchip/rockchip-system-status.h |   53 +
 include/soc/rockchip/rockchip_dmc.h           |  121 ++
 include/soc/rockchip/rockchip_iommu.h         |   24 +
 include/soc/rockchip/rockchip_ipa.h           |   40 +
 include/soc/rockchip/rockchip_opp_select.h    |  152 ++
 include/soc/rockchip/rockchip_performance.h   |   23 +
 include/soc/rockchip/rockchip_sip.h           |    8 +-
 .../soc/rockchip/rockchip_system_monitor.h    |  205 ++
 include/soc/rockchip/scpi.h                   |  147 ++
 include/sound/hdmi-codec.h                    |   17 +-
 include/trace/events/cpuhp.h                  |   22 +
 include/trace/events/sched.h                  |    7 +-
 include/trace/events/thermal_ipa_power.h      |   47 +
 include/trace/hooks/cgroup.h                  |   32 +
 include/trace/hooks/dtask.h                   |   62 +
 include/trace/hooks/mm.h                      |  134 ++
 include/trace/hooks/psi.h                     |   33 +
 include/trace/hooks/sched.h                   |  397 ++++
 include/trace/hooks/vendor_hooks.h            |  114 +
 include/uapi/drm/drm_fourcc.h                 |    2 +
 include/uapi/drm/rockchip_drm.h               |  134 ++
 include/uapi/linux/fec-config.h               |   33 +
 include/uapi/linux/media-bus-format.h         |    6 +-
 include/uapi/linux/rk-camera-module.h         |  560 +++++
 include/uapi/linux/rk-led-flash.h             |    9 +
 include/uapi/linux/rk-pcie-dma.h              |   61 +
 include/uapi/linux/rk-preisp.h                |  118 ++
 include/uapi/linux/rk-video-format.h          |   35 +
 include/uapi/linux/rk803.h                    |   16 +
 include/uapi/linux/rk_vcm_head.h              |  114 +
 include/uapi/linux/rkcif-config.h             |   57 +
 include/uapi/linux/rkisp1-config.h            |  872 ++++++++
 include/uapi/linux/rkisp2-config.h            | 1853 +++++++++++++++++
 include/uapi/linux/rkisp21-config.h           |  804 +++++++
 include/uapi/linux/rkisp3-config.h            | 1072 ++++++++++
 include/uapi/linux/rkispp-config.h            |  370 ++++
 include/uapi/linux/serial_reg.h               |    1 +
 include/uapi/linux/usb/ch9.h                  |   13 +
 include/uapi/linux/usb/f_accessory.h          |  146 ++
 include/uapi/linux/usb/g_uvc.h                |    4 +-
 include/uapi/linux/usb/video.h                |   58 +
 include/uapi/linux/v4l2-controls.h            |    6 +
 include/uapi/linux/videodev2.h                |    1 +
 include/uapi/misc/rkflash_vendor_storage.h    |   21 +
 163 files changed, 13890 insertions(+), 615 deletions(-)
 create mode 100644 include/drm/drm_sync_helper.h
 create mode 100644 include/dt-bindings/clock/rockchip-ddr.h
 create mode 100644 include/dt-bindings/clock/rockchip.h
 create mode 100644 include/dt-bindings/display/drm_mipi_dsi.h
 create mode 100644 include/dt-bindings/display/media-bus-format.h
 create mode 100644 include/dt-bindings/display/mipi_dsi.h
 create mode 100644 include/dt-bindings/display/rockchip_vop.h
 create mode 100644 include/dt-bindings/input/rk-input.h
 create mode 100644 include/dt-bindings/memory/rk3399-dram.h
 create mode 100644 include/dt-bindings/memory/rockchip-dram.h
 create mode 100644 include/dt-bindings/phy/phy-snps-pcie3.h
 create mode 100644 include/dt-bindings/sensor-dev.h
 create mode 100644 include/dt-bindings/soc/rockchip-system-status.h
 create mode 100644 include/dt-bindings/suspend/rockchip-rk3399.h
 create mode 100644 include/linux/clk/rockchip.h
 create mode 100644 include/linux/cpufreq_times.h
 create mode 100644 include/linux/dma-buf-cache.h
 create mode 100644 include/linux/initramfs.h
 create mode 100644 include/linux/memory_group_manager.h
 create mode 100644 include/linux/phy/pcie.h
 create mode 100644 include/linux/phy/phy-rockchip-typec.h
 create mode 100644 include/linux/phy/phy-rockchip-usbdp.h
 create mode 100644 include/linux/power/bq25700-charge.h
 create mode 100644 include/linux/power/cw2015_battery.h
 create mode 100644 include/linux/power/rk_usbbc.h
 create mode 100644 include/linux/rfkill-bt.h
 create mode 100644 include/linux/rfkill-wlan.h
 create mode 100644 include/linux/rk_keys.h
 create mode 100644 include/linux/rockchip-iovmm.h
 create mode 100644 include/linux/rockchip/cpu.h
 create mode 100644 include/linux/rockchip/psci.h
 create mode 100644 include/linux/rockchip/rockchip_sip.h
 create mode 100644 include/linux/rockchip_ion.h
 delete mode 100644 include/linux/sched/core_ctl.h
 delete mode 100644 include/linux/sched/frame_rtg.h
 delete mode 100644 include/linux/sched/rtg.h
 delete mode 100644 include/linux/sched/rtg_ctrl.h
 create mode 100644 include/linux/sensor-dev.h
 create mode 100644 include/linux/soc/rockchip/pvtm.h
 create mode 100644 include/linux/soc/rockchip/rk_fiq_debugger.h
 create mode 100644 include/linux/soc/rockchip/rk_vendor_storage.h
 create mode 100644 include/linux/soc/rockchip/rockchip_decompress.h
 create mode 100644 include/linux/soc/rockchip/rockchip_thunderboot_crypto.h
 create mode 100644 include/linux/usb/f_accessory.h
 create mode 100644 include/linux/wakelock.h
 create mode 100644 include/linux/wakeup_reason.h
 create mode 100644 include/media/tc35874x.h
 create mode 100644 include/soc/rockchip/pm_domains.h
 create mode 100644 include/soc/rockchip/rkfb_dmc.h
 create mode 100644 include/soc/rockchip/rockchip-system-status.h
 create mode 100644 include/soc/rockchip/rockchip_dmc.h
 create mode 100644 include/soc/rockchip/rockchip_iommu.h
 create mode 100644 include/soc/rockchip/rockchip_ipa.h
 create mode 100644 include/soc/rockchip/rockchip_opp_select.h
 create mode 100644 include/soc/rockchip/rockchip_performance.h
 create mode 100644 include/soc/rockchip/rockchip_system_monitor.h
 create mode 100644 include/soc/rockchip/scpi.h
 create mode 100644 include/trace/events/thermal_ipa_power.h
 create mode 100644 include/trace/hooks/cgroup.h
 create mode 100644 include/trace/hooks/dtask.h
 create mode 100644 include/trace/hooks/mm.h
 create mode 100644 include/trace/hooks/psi.h
 create mode 100644 include/trace/hooks/sched.h
 create mode 100644 include/trace/hooks/vendor_hooks.h
 create mode 100644 include/uapi/drm/rockchip_drm.h
 create mode 100644 include/uapi/linux/fec-config.h
 create mode 100644 include/uapi/linux/rk-camera-module.h
 create mode 100644 include/uapi/linux/rk-led-flash.h
 create mode 100644 include/uapi/linux/rk-pcie-dma.h
 create mode 100644 include/uapi/linux/rk-preisp.h
 create mode 100644 include/uapi/linux/rk-video-format.h
 create mode 100644 include/uapi/linux/rk803.h
 create mode 100644 include/uapi/linux/rk_vcm_head.h
 create mode 100644 include/uapi/linux/rkcif-config.h
 create mode 100644 include/uapi/linux/rkisp1-config.h
 create mode 100644 include/uapi/linux/rkisp2-config.h
 create mode 100644 include/uapi/linux/rkisp21-config.h
 create mode 100644 include/uapi/linux/rkisp3-config.h
 create mode 100644 include/uapi/linux/rkispp-config.h
 create mode 100644 include/uapi/linux/usb/f_accessory.h
 create mode 100644 include/uapi/misc/rkflash_vendor_storage.h

diff --git a/include/drm/bridge/analogix_dp.h b/include/drm/bridge/analogix_dp.h
index b0dcc0733..291eb8787 100644
--- a/include/drm/bridge/analogix_dp.h
+++ b/include/drm/bridge/analogix_dp.h
@@ -8,6 +8,7 @@
 #define _ANALOGIX_DP_H_
 
 #include <drm/drm_crtc.h>
+#include <sound/hdmi-codec.h>
 
 struct analogix_dp_device;
 
@@ -25,21 +26,32 @@ static inline bool is_rockchip(enum analogix_dp_devtype type)
 struct analogix_dp_plat_data {
 	enum analogix_dp_devtype dev_type;
 	struct drm_panel *panel;
+	struct drm_bridge *bridge;
 	struct drm_encoder *encoder;
 	struct drm_connector *connector;
 	bool skip_connector;
+	bool ssc;
+
+	bool split_mode;
+	struct analogix_dp_device *left;
+	struct analogix_dp_device *right;
 
 	int (*power_on_start)(struct analogix_dp_plat_data *);
 	int (*power_on_end)(struct analogix_dp_plat_data *);
 	int (*power_off)(struct analogix_dp_plat_data *);
 	int (*attach)(struct analogix_dp_plat_data *, struct drm_bridge *,
 		      struct drm_connector *);
+	void (*detach)(struct analogix_dp_plat_data *, struct drm_bridge *);
 	int (*get_modes)(struct analogix_dp_plat_data *,
 			 struct drm_connector *);
+	void (*convert_to_split_mode)(struct drm_display_mode *);
+	void (*convert_to_origin_mode)(struct drm_display_mode *);
 };
 
 int analogix_dp_resume(struct analogix_dp_device *dp);
 int analogix_dp_suspend(struct analogix_dp_device *dp);
+int analogix_dp_runtime_resume(struct analogix_dp_device *dp);
+int analogix_dp_runtime_suspend(struct analogix_dp_device *dp);
 
 struct analogix_dp_device *
 analogix_dp_probe(struct device *dev, struct analogix_dp_plat_data *plat_data);
@@ -50,4 +62,13 @@ void analogix_dp_remove(struct analogix_dp_device *dp);
 int analogix_dp_start_crc(struct drm_connector *connector);
 int analogix_dp_stop_crc(struct drm_connector *connector);
 
+int analogix_dp_audio_hw_params(struct analogix_dp_device *dp,
+				struct hdmi_codec_daifmt *daifmt,
+				struct hdmi_codec_params *params);
+void analogix_dp_audio_shutdown(struct analogix_dp_device *dp);
+int analogix_dp_audio_startup(struct analogix_dp_device *dp);
+int analogix_dp_audio_get_eld(struct analogix_dp_device *dp,
+			      u8 *buf, size_t len);
+int analogix_dp_loader_protect(struct analogix_dp_device *dp);
+
 #endif /* _ANALOGIX_DP_H_ */
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ea34ca146..0b7f860d9 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -6,12 +6,15 @@
 #ifndef __DW_HDMI__
 #define __DW_HDMI__
 
+#include <drm/drm_property.h>
 #include <sound/hdmi-codec.h>
+#include <media/cec.h>
 
 struct drm_display_info;
 struct drm_display_mode;
 struct drm_encoder;
 struct dw_hdmi;
+struct dw_hdmi_qp;
 struct platform_device;
 
 /**
@@ -92,6 +95,13 @@ enum dw_hdmi_phy_type {
 	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
 };
 
+struct dw_hdmi_audio_tmds_n {
+	unsigned long tmds;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
 struct dw_hdmi_mpll_config {
 	unsigned long mpixelclock;
 	struct {
@@ -112,6 +122,15 @@ struct dw_hdmi_phy_config {
 	u16 vlev_ctr;   /* voltage level control */
 };
 
+struct dw_hdmi_link_config {
+	bool dsc_mode;
+	bool frl_mode;
+	int frl_lanes;
+	int rate_per_lane;
+	int hcactive;
+	u8 pps_payload[128];
+};
+
 struct dw_hdmi_phy_ops {
 	int (*init)(struct dw_hdmi *hdmi, void *data,
 		    const struct drm_display_info *display,
@@ -123,12 +142,48 @@ struct dw_hdmi_phy_ops {
 	void (*setup_hpd)(struct dw_hdmi *hdmi, void *data);
 };
 
+struct dw_hdmi_qp_phy_ops {
+	int (*init)(struct dw_hdmi_qp *hdmi, void *data,
+		    struct drm_display_mode *mode);
+	void (*disable)(struct dw_hdmi_qp *hdmi, void *data);
+	enum drm_connector_status (*read_hpd)(struct dw_hdmi_qp *hdmi,
+					      void *data);
+	void (*update_hpd)(struct dw_hdmi_qp *hdmi, void *data,
+			   bool force, bool disabled, bool rxsense);
+	void (*setup_hpd)(struct dw_hdmi_qp *hdmi, void *data);
+	void (*set_mode)(struct dw_hdmi_qp *dw_hdmi, void *data,
+			 u32 mode_mask, bool enable);
+};
+
+struct dw_hdmi_property_ops {
+	void (*attach_properties)(struct drm_connector *connector,
+				  unsigned int color, int version,
+				  void *data);
+	void (*destroy_properties)(struct drm_connector *connector,
+				   void *data);
+	int (*set_property)(struct drm_connector *connector,
+			    struct drm_connector_state *state,
+			    struct drm_property *property,
+			    u64 val,
+			    void *data);
+	int (*get_property)(struct drm_connector *connector,
+			    const struct drm_connector_state *state,
+			    struct drm_property *property,
+			    u64 *val,
+			    void *data);
+};
+
 struct dw_hdmi_plat_data {
 	struct regmap *regm;
 
+	unsigned long input_bus_format;
 	unsigned long input_bus_encoding;
+	unsigned int max_tmdsclk;
 	bool use_drm_infoframe;
 	bool ycbcr_420_allowed;
+	bool unsupported_yuv_input;
+	bool unsupported_deep_color;
+	bool is_hdmi_qp;
 
 	/*
 	 * Private data passed to all the .mode_valid() and .configure_phy()
@@ -137,22 +192,55 @@ struct dw_hdmi_plat_data {
 	void *priv_data;
 
 	/* Platform-specific mode validation (optional). */
-	enum drm_mode_status (*mode_valid)(struct dw_hdmi *hdmi, void *data,
+	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
+					   void *data,
 					   const struct drm_display_info *info,
 					   const struct drm_display_mode *mode);
 
 	/* Vendor PHY support */
 	const struct dw_hdmi_phy_ops *phy_ops;
+	const struct dw_hdmi_qp_phy_ops *qp_phy_ops;
 	const char *phy_name;
 	void *phy_data;
 	unsigned int phy_force_vendor;
+	const struct dw_hdmi_audio_tmds_n *tmds_n_table;
+
+	/* split mode */
+	bool split_mode;
+	bool first_screen;
+	struct dw_hdmi_qp *left;
+	struct dw_hdmi_qp *right;
 
 	/* Synopsys PHY support */
 	const struct dw_hdmi_mpll_config *mpll_cfg;
+	const struct dw_hdmi_mpll_config *mpll_cfg_420;
 	const struct dw_hdmi_curr_ctrl *cur_ctr;
 	const struct dw_hdmi_phy_config *phy_config;
 	int (*configure_phy)(struct dw_hdmi *hdmi, void *data,
 			     unsigned long mpixelclock);
+
+	unsigned long (*get_input_bus_format)(void *data);
+	unsigned long (*get_output_bus_format)(void *data);
+	unsigned long (*get_enc_in_encoding)(void *data);
+	unsigned long (*get_enc_out_encoding)(void *data);
+	unsigned long (*get_quant_range)(void *data);
+	struct drm_property *(*get_hdr_property)(void *data);
+	struct drm_property_blob *(*get_hdr_blob)(void *data);
+	bool (*get_color_changed)(void *data);
+	int (*get_yuv422_format)(struct drm_connector *connector,
+				 struct edid *edid);
+	int (*get_edid_dsc_info)(void *data, struct edid *edid);
+	int (*get_next_hdr_data)(void *data, struct edid *edid,
+				 struct drm_connector *connector);
+	struct dw_hdmi_link_config *(*get_link_cfg)(void *data);
+	void (*set_grf_cfg)(void *data);
+	void (*convert_to_split_mode)(struct drm_display_mode *mode);
+	void (*convert_to_origin_mode)(struct drm_display_mode *mode);
+	int (*dclk_set)(void *data, bool enable);
+
+	/* Vendor Property support */
+	const struct dw_hdmi_property_ops *property_ops;
+	struct drm_connector *connector;
 };
 
 struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
@@ -161,8 +249,9 @@ void dw_hdmi_remove(struct dw_hdmi *hdmi);
 void dw_hdmi_unbind(struct dw_hdmi *hdmi);
 struct dw_hdmi *dw_hdmi_bind(struct platform_device *pdev,
 			     struct drm_encoder *encoder,
-			     const struct dw_hdmi_plat_data *plat_data);
+			     struct dw_hdmi_plat_data *plat_data);
 
+void dw_hdmi_suspend(struct dw_hdmi *hdmi);
 void dw_hdmi_resume(struct dw_hdmi *hdmi);
 
 void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
@@ -192,5 +281,31 @@ enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
 void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
 			    bool force, bool disabled, bool rxsense);
 void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data);
+void dw_hdmi_set_quant_range(struct dw_hdmi *hdmi);
+void dw_hdmi_set_output_type(struct dw_hdmi *hdmi, u64 val);
+bool dw_hdmi_get_output_whether_hdmi(struct dw_hdmi *hdmi);
+int dw_hdmi_get_output_type_cap(struct dw_hdmi *hdmi);
+void dw_hdmi_set_cec_adap(struct dw_hdmi *hdmi, struct cec_adapter *adap);
+
+void dw_hdmi_qp_unbind(struct dw_hdmi_qp *hdmi);
+struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
+				struct drm_encoder *encoder,
+				struct dw_hdmi_plat_data *plat_data);
+void dw_hdmi_qp_suspend(struct device *dev, struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_cec_set_hpd(struct dw_hdmi_qp *hdmi, bool plug_in, bool change);
+void dw_hdmi_qp_set_cec_adap(struct dw_hdmi_qp *hdmi, struct cec_adapter *adap);
+int dw_hdmi_qp_set_earc(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
+void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
+void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status,
+				   bool ref2stream);
+void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
+void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
+				    struct hdmi_codec_params *hparms);
+void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
+int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
+			      struct device *codec_dev);
 
 #endif /* __IMX_HDMI_H__ */
diff --git a/include/drm/bridge/dw_mipi_dsi.h b/include/drm/bridge/dw_mipi_dsi.h
index bda8aa7c2..f89b0476a 100644
--- a/include/drm/bridge/dw_mipi_dsi.h
+++ b/include/drm/bridge/dw_mipi_dsi.h
@@ -66,5 +66,6 @@ void dw_mipi_dsi_remove(struct dw_mipi_dsi *dsi);
 int dw_mipi_dsi_bind(struct dw_mipi_dsi *dsi, struct drm_encoder *encoder);
 void dw_mipi_dsi_unbind(struct dw_mipi_dsi *dsi);
 void dw_mipi_dsi_set_slave(struct dw_mipi_dsi *dsi, struct dw_mipi_dsi *slave);
+struct drm_connector *dw_mipi_dsi_get_connector(struct dw_mipi_dsi *dsi);
 
 #endif /* __DW_MIPI_DSI__ */
diff --git a/include/drm/drm_auth.h b/include/drm/drm_auth.h
index f99d3417f..6bf8b2b78 100644
--- a/include/drm/drm_auth.h
+++ b/include/drm/drm_auth.h
@@ -107,7 +107,6 @@ struct drm_master {
 };
 
 struct drm_master *drm_master_get(struct drm_master *master);
-struct drm_master *drm_file_get_master(struct drm_file *file_priv);
 void drm_master_put(struct drm_master **master);
 bool drm_is_current_master(struct drm_file *fpriv);
 
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 928136556..f8cd5d8e5 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -175,6 +175,48 @@ struct drm_scdc {
 	struct drm_scrambling scrambling;
 };
 
+#ifdef CONFIG_NO_GKI
+/**
+ * struct drm_hdmi_dsc_cap - DSC capabilities of HDMI sink
+ *
+ * Describes the DSC support provided by HDMI 2.1 sink.
+ * The information is fetched fom additional HFVSDB blocks defined
+ * for HDMI 2.1.
+ */
+struct drm_hdmi_dsc_cap {
+	/** @v_1p2: flag for dsc1.2 version support by sink */
+	bool v_1p2;
+
+	/** @native_420: Does sink support DSC with 4:2:0 compression */
+	bool native_420;
+
+	/**
+	 * @all_bpp: Does sink support all bpp with 4:4:4: or 4:2:2
+	 * compressed formats
+	 */
+	bool all_bpp;
+
+	/**
+	 * @bpc_supported: compressed bpc supported by sink : 10, 12 or 16 bpc
+	 */
+	u8 bpc_supported;
+
+	/** @max_slices: maximum number of Horizontal slices supported by */
+	u8 max_slices;
+
+	/** @clk_per_slice : max pixel clock in MHz supported per slice */
+	int clk_per_slice;
+
+	/** @max_lanes : dsc max lanes supported for Fixed rate Link training */
+	u8 max_lanes;
+
+	/** @max_frl_rate_per_lane : maximum frl rate with DSC per lane */
+	u8 max_frl_rate_per_lane;
+
+	/** @total_chunk_kbytes: max size of chunks in KBs supported per line*/
+	u8 total_chunk_kbytes;
+};
+#endif
 
 /**
  * struct drm_hdmi_info - runtime information about the connected HDMI sink
@@ -207,6 +249,17 @@ struct drm_hdmi_info {
 
 	/** @y420_dc_modes: bitmap of deep color support index */
 	u8 y420_dc_modes;
+
+#ifdef CONFIG_NO_GKI
+	/** @max_frl_rate_per_lane: support fixed rate link */
+	u8 max_frl_rate_per_lane;
+
+	/** @max_lanes: supported by sink */
+	u8 max_lanes;
+
+	/** @dsc_cap: DSC capabilities of the sink */
+	struct drm_hdmi_dsc_cap dsc_cap;
+#endif
 };
 
 /**
@@ -1596,6 +1649,7 @@ drm_connector_is_unregistered(struct drm_connector *connector)
 		DRM_CONNECTOR_UNREGISTERED;
 }
 
+void drm_connector_oob_hotplug_event(struct fwnode_handle *connector_fwnode);
 const char *drm_get_connector_type_name(unsigned int connector_type);
 const char *drm_get_connector_status_name(enum drm_connector_status status);
 const char *drm_get_subpixel_order_name(enum subpixel_order order);
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 59b51a09c..3a3d9d887 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -287,7 +287,16 @@ struct drm_crtc_state {
 	 * NULL) is an array of &struct drm_color_lut.
 	 */
 	struct drm_property_blob *gamma_lut;
-
+#if defined(CONFIG_ROCKCHIP_DRM_CUBIC_LUT)
+	/**
+	 * @cubic_lut:
+	 *
+	 * Cubic Lookup table for converting pixel data. See
+	 * drm_crtc_enable_color_mgmt(). The blob (if not NULL) is a 3D array
+	 * of &struct drm_color_lut.
+	 */
+	struct drm_property_blob *cubic_lut;
+#endif
 	/**
 	 * @target_vblank:
 	 *
diff --git a/include/drm/drm_drv.h b/include/drm/drm_drv.h
index e57d0440f..e395d1fc1 100644
--- a/include/drm/drm_drv.h
+++ b/include/drm/drm_drv.h
@@ -29,6 +29,7 @@
 
 #include <linux/list.h>
 #include <linux/irqreturn.h>
+#include <linux/uuid.h>
 
 #include <drm/drm_device.h>
 
@@ -460,6 +461,15 @@ struct drm_driver {
 	int (*gem_prime_mmap)(struct drm_gem_object *obj,
 				struct vm_area_struct *vma);
 
+	/**
+	 * @gem_prime_get_uuid
+	 *
+	 * get_uuid hook for GEM drivers. Retrieves the virtio uuid of the
+	 * given GEM buffer.
+	 */
+	int (*gem_prime_get_uuid)(struct drm_gem_object *obj,
+				  uuid_t *uuid);
+
 	/**
 	 * @dumb_create:
 	 *
diff --git a/include/drm/drm_edid.h b/include/drm/drm_edid.h
index e97daf6ff..043491c74 100644
--- a/include/drm/drm_edid.h
+++ b/include/drm/drm_edid.h
@@ -229,6 +229,38 @@ struct detailed_timing {
 				    DRM_EDID_YCBCR420_DC_36 | \
 				    DRM_EDID_YCBCR420_DC_30)
 
+#ifdef CONFIG_NO_GKI
+/* HDMI 2.1 additional fields */
+#define DRM_EDID_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_FAPA_START_LOCATION		(1 << 0)
+#define DRM_EDID_ALLM				(1 << 1)
+#define DRM_EDID_FVA				(1 << 2)
+
+/* Deep Color specific */
+#define DRM_EDID_DC_30BIT_420			(1 << 0)
+#define DRM_EDID_DC_36BIT_420			(1 << 1)
+#define DRM_EDID_DC_48BIT_420			(1 << 2)
+
+/* VRR specific */
+#define DRM_EDID_CNMVRR				(1 << 3)
+#define DRM_EDID_CINEMA_VRR			(1 << 4)
+#define DRM_EDID_MDELTA				(1 << 5)
+#define DRM_EDID_VRR_MAX_UPPER_MASK		0xc0
+#define DRM_EDID_VRR_MAX_LOWER_MASK		0xff
+#define DRM_EDID_VRR_MIN_MASK			0x3f
+
+/* DSC specific */
+#define DRM_EDID_DSC_10BPC			(1 << 0)
+#define DRM_EDID_DSC_12BPC			(1 << 1)
+#define DRM_EDID_DSC_16BPC			(1 << 2)
+#define DRM_EDID_DSC_ALL_BPP			(1 << 3)
+#define DRM_EDID_DSC_NATIVE_420			(1 << 6)
+#define DRM_EDID_DSC_1P2			(1 << 7)
+#define DRM_EDID_DSC_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_DSC_MAX_SLICES			0xf
+#define DRM_EDID_DSC_TOTAL_CHUNK_KBYTES		0x3f
+#endif
+
 /* ELD Header Block */
 #define DRM_ELD_HEADER_BLOCK_SIZE	4
 
@@ -359,8 +391,6 @@ drm_load_edid_firmware(struct drm_connector *connector)
 }
 #endif
 
-bool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2);
-
 int
 drm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,
 					 const struct drm_connector *connector,
@@ -483,35 +513,99 @@ struct edid *drm_do_get_edid(struct drm_connector *connector,
 	int (*get_edid_block)(void *data, u8 *buf, unsigned int block,
 			      size_t len),
 	void *data);
-struct edid *drm_get_edid(struct drm_connector *connector,
-			  struct i2c_adapter *adapter);
 struct edid *drm_get_edid_switcheroo(struct drm_connector *connector,
 				     struct i2c_adapter *adapter);
-struct edid *drm_edid_duplicate(const struct edid *edid);
-int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
-int drm_add_override_edid_modes(struct drm_connector *connector);
 
-u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
 bool drm_detect_hdmi_monitor(struct edid *edid);
-bool drm_detect_monitor_audio(struct edid *edid);
 enum hdmi_quantization_range
 drm_default_rgb_quant_range(const struct drm_display_mode *mode);
-int drm_add_modes_noedid(struct drm_connector *connector,
-			 int hdisplay, int vdisplay);
 void drm_set_preferred_mode(struct drm_connector *connector,
 			    int hpref, int vpref);
 
 int drm_edid_header_is_valid(const u8 *raw_edid);
 bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
 			  bool *edid_corrupt);
-bool drm_edid_is_valid(struct edid *edid);
+struct drm_display_mode *
+drm_display_mode_from_cea_vic(struct drm_device *dev,
+			      u8 video_code);
+
+#ifdef CONFIG_DRM_EDID
+struct edid *drm_get_edid(struct drm_connector *connector,
+			  struct i2c_adapter *adapter);
+struct edid *drm_edid_duplicate(const struct edid *edid);
+int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
+int drm_add_override_edid_modes(struct drm_connector *connector);
+u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
+int drm_add_modes_noedid(struct drm_connector *connector,
+			 int hdisplay, int vdisplay);
+bool drm_detect_monitor_audio(struct edid *edid);
 void drm_edid_get_monitor_name(struct edid *edid, char *name,
 			       int buflen);
+bool drm_edid_is_valid(struct edid *edid);
+bool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh,
 					   bool rb);
-struct drm_display_mode *
-drm_display_mode_from_cea_vic(struct drm_device *dev,
-			      u8 video_code);
+#else
+static inline struct edid *drm_get_edid(struct drm_connector *connector,
+					struct i2c_adapter *adapter)
+{
+	return NULL;
+}
+
+static inline struct edid *drm_edid_duplicate(const struct edid *edid)
+{
+	return NULL;
+}
+
+static inline int drm_add_edid_modes(struct drm_connector *connector,
+				     struct edid *edid)
+{
+	return 0;
+}
+
+static inline int drm_add_override_edid_modes(struct drm_connector *connector)
+{
+	return 0;
+}
+
+static inline u8 drm_match_cea_mode(const struct drm_display_mode *to_match)
+{
+	return 0;
+}
+
+static inline int drm_add_modes_noedid(struct drm_connector *connector,
+				       int hdisplay, int vdisplay)
+{
+	return 0;
+}
+
+static inline bool drm_detect_monitor_audio(struct edid *edid)
+{
+	return false;
+}
+
+static inline void drm_edid_get_monitor_name(struct edid *edid, char *name,
+					     int buflen)
+{
+}
+
+static inline bool drm_edid_is_valid(struct edid *edid)
+{
+	return false;
+}
+
+static inline bool drm_edid_are_equal(const struct edid *edid1, const struct edid *edid2)
+{
+	return false;
+}
+
+static inline struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
+					   int hsize, int vsize, int fresh,
+					   bool rb)
+{
+	return NULL;
+}
+#endif
 
 #endif /* __DRM_EDID_H__ */
diff --git a/include/drm/drm_file.h b/include/drm/drm_file.h
index 42d04607d..b81b3bfb0 100644
--- a/include/drm/drm_file.h
+++ b/include/drm/drm_file.h
@@ -226,27 +226,15 @@ struct drm_file {
 	/**
 	 * @master:
 	 *
-	 * Master this node is currently associated with. Protected by struct
-	 * &drm_device.master_mutex, and serialized by @master_lookup_lock.
-	 *
-	 * Only relevant if drm_is_primary_client() returns true. Note that
-	 * this only matches &drm_device.master if the master is the currently
-	 * active one.
-	 *
-	 * When dereferencing this pointer, either hold struct
-	 * &drm_device.master_mutex for the duration of the pointer's use, or
-	 * use drm_file_get_master() if struct &drm_device.master_mutex is not
-	 * currently held and there is no other need to hold it. This prevents
-	 * @master from being freed during use.
+	 * Master this node is currently associated with. Only relevant if
+	 * drm_is_primary_client() returns true. Note that this only
+	 * matches &drm_device.master if the master is the currently active one.
 	 *
 	 * See also @authentication and @is_master and the :ref:`section on
 	 * primary nodes and authentication <drm_primary_node>`.
 	 */
 	struct drm_master *master;
 
-	/** @master_lock: Serializes @master. */
-	spinlock_t master_lookup_lock;
-
 	/** @pid: Process that opened this file. */
 	struct pid *pid;
 
@@ -411,6 +399,9 @@ void drm_event_cancel_free(struct drm_device *dev,
 			   struct drm_pending_event *p);
 void drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e);
 void drm_send_event(struct drm_device *dev, struct drm_pending_event *e);
+void drm_send_event_timestamp_locked(struct drm_device *dev,
+				     struct drm_pending_event *e,
+				     ktime_t timestamp);
 
 struct file *mock_drm_getfile(struct drm_minor *minor, unsigned int flags);
 
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index 360e6377e..952f475a6 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -19,12 +19,18 @@ struct drm_dsc_picture_parameter_set;
 #define MIPI_DSI_MSG_REQ_ACK	BIT(0)
 /* use Low Power Mode to transmit message */
 #define MIPI_DSI_MSG_USE_LPM	BIT(1)
+/* read mipi_dsi_msg.ctrl and unicast to only that ctrls */
+#define MIPI_DSI_MSG_UNICAST	BIT(2)
+/* Stack all commands until lastcommand bit and trigger all in one go */
+#define MIPI_DSI_MSG_LASTCOMMAND BIT(3)
 
 /**
  * struct mipi_dsi_msg - read/write DSI buffer
  * @channel: virtual channel id
  * @type: payload data type
  * @flags: flags controlling this message transmission
+ * @ctrl: ctrl index to transmit on
+ * @wait_ms: duration in ms to wait after message transmission
  * @tx_len: length of @tx_buf
  * @tx_buf: data to be written
  * @rx_len: length of @rx_buf
@@ -34,6 +40,8 @@ struct mipi_dsi_msg {
 	u8 channel;
 	u8 type;
 	u16 flags;
+	u32 ctrl;
+	u32 wait_ms;
 
 	size_t tx_len;
 	const void *tx_buf;
@@ -132,6 +140,10 @@ struct mipi_dsi_host *of_find_mipi_dsi_host_by_node(struct device_node *node);
 #define MIPI_DSI_CLOCK_NON_CONTINUOUS	BIT(10)
 /* transmit data in low power */
 #define MIPI_DSI_MODE_LPM		BIT(11)
+/* disable BLLP area */
+#define MIPI_DSI_MODE_VIDEO_BLLP	BIT(12)
+/* disable EOF BLLP area */
+#define MIPI_DSI_MODE_VIDEO_EOF_BLLP	BIT(13)
 
 enum mipi_dsi_pixel_format {
 	MIPI_DSI_FMT_RGB888,
diff --git a/include/drm/drm_mode_config.h b/include/drm/drm_mode_config.h
index a18f73eb3..76d114569 100644
--- a/include/drm/drm_mode_config.h
+++ b/include/drm/drm_mode_config.h
@@ -794,6 +794,19 @@ struct drm_mode_config {
 	 */
 	struct drm_property *gamma_lut_size_property;
 
+#if defined(CONFIG_ROCKCHIP_DRM_CUBIC_LUT)
+	/**
+	 * @cubic_lut_property: Optional CRTC property to set the 3D LUT used to
+	 * convert color spaces.
+	 */
+	struct drm_property *cubic_lut_property;
+	/**
+	 * @cubic_lut_size_property: Optional CRTC property for the size of the
+	 * 3D LUT as supported by the driver (read-only).
+	 */
+	struct drm_property *cubic_lut_size_property;
+#endif
+
 	/**
 	 * @suggested_x_property: Optional connector property with a hint for
 	 * the position of the output on the host's screen.
diff --git a/include/drm/drm_mode_object.h b/include/drm/drm_mode_object.h
index c34a3e803..6292fa663 100644
--- a/include/drm/drm_mode_object.h
+++ b/include/drm/drm_mode_object.h
@@ -60,7 +60,7 @@ struct drm_mode_object {
 	void (*free_cb)(struct kref *kref);
 };
 
-#define DRM_OBJECT_MAX_PROPERTY 24
+#define DRM_OBJECT_MAX_PROPERTY 64
 /**
  * struct drm_object_properties - property tracking for &drm_mode_object
  */
diff --git a/include/drm/drm_prime.h b/include/drm/drm_prime.h
index 0f69f9fbf..a9d0c6b08 100644
--- a/include/drm/drm_prime.h
+++ b/include/drm/drm_prime.h
@@ -107,5 +107,6 @@ void drm_prime_gem_destroy(struct drm_gem_object *obj, struct sg_table *sg);
 int drm_prime_sg_to_page_addr_arrays(struct sg_table *sgt, struct page **pages,
 				     dma_addr_t *addrs, int max_pages);
 
+int drm_gem_dmabuf_get_uuid(struct dma_buf *dma_buf, uuid_t *uuid);
 
 #endif /* __DRM_PRIME_H__ */
diff --git a/include/drm/drm_sync_helper.h b/include/drm/drm_sync_helper.h
new file mode 100644
index 000000000..a5586c674
--- /dev/null
+++ b/include/drm/drm_sync_helper.h
@@ -0,0 +1,156 @@
+/*
+ * drm_sync_helper.h: software fence and helper functions for fences and
+ * reservations used for dma buffer access synchronization between drivers.
+ *
+ * Copyright 2014 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DRM_SYNC_HELPER_H_
+#define _DRM_SYNC_HELPER_H_
+
+#include <linux/fence.h>
+#include <linux/reservation.h>
+#include <linux/atomic.h>
+#include <linux/workqueue.h>
+
+/**
+ * Create software fence
+ * @context: execution context
+ * @seqno: the sequence number of this fence inside the execution context
+ */
+struct fence *drm_sw_fence_new(unsigned int context,
+			unsigned seqno);
+
+/**
+ * Signal and decrease reference count for a fence if it exists
+ * @fence: fence to signal
+ *
+ * Utility function called when owner access to object associated with fence is
+ * finished (e.g. GPU done with rendering).
+ */
+static inline void drm_fence_signal_and_put(struct fence **fence)
+{
+	if (*fence) {
+		fence_signal(*fence);
+		fence_put(*fence);
+		*fence = NULL;
+	}
+}
+
+struct drm_reservation_cb;
+
+struct drm_reservation_fence_cb {
+	struct fence_cb base;
+	struct drm_reservation_cb *parent;
+	struct fence *fence;
+};
+
+/**
+ * Callback executed when all fences in reservation callback are signaled
+ * @rcb: reservation callback structure
+ * @context: context provided by user at init time
+ */
+typedef void (*drm_reservation_cb_func_t)(struct drm_reservation_cb *rcb,
+					  void *context);
+
+/**
+ * Reservation callback structure
+ * @work: work context in which func is executed
+ * @fence_cbs: fence callbacks array
+ * @num_fence_cbs: number of fence callbacks
+ * @count: count of signaled fences, when it drops to 0 func is called
+ * @func: callback to execute when all fences are signaled
+ * @context: context provided by user during initialization
+ *
+ * It is safe and expected that func will destroy this structure before
+ * returning.
+ */
+struct drm_reservation_cb {
+	struct work_struct work;
+	struct drm_reservation_fence_cb **fence_cbs;
+	unsigned num_fence_cbs;
+	atomic_t count;
+	void *context;
+	drm_reservation_cb_func_t func;
+};
+
+/**
+ * Initialize reservation callback
+ * @rcb: reservation callback structure to initialize
+ * @func: function to call when all fences are signaled
+ * @context: parameter to call func with
+ */
+void drm_reservation_cb_init(struct drm_reservation_cb *rcb,
+			     drm_reservation_cb_func_t func,
+			     void *context);
+
+/**
+ * Add fences from reservation object to callback
+ * @rcb: reservation callback structure
+ * @resv: reservation object
+ * @exclusive: (for exclusive wait) when true add all fences, otherwise only
+ *    exclusive fence
+ */
+int drm_reservation_cb_add(struct drm_reservation_cb *rcb,
+			   struct reservation_object *resv,
+			   bool exclusive);
+
+/**
+ * Finish adding fences
+ * @rcb: reservation callback structure
+ *
+ * It will trigger callback worker if all fences were signaled before.
+ */
+void drm_reservation_cb_done(struct drm_reservation_cb *rcb);
+
+/**
+ * Cleanup reservation callback structure
+ * @rcb: reservation callback structure
+ *
+ * Can be called to cancel primed reservation callback.
+ */
+void drm_reservation_cb_fini(struct drm_reservation_cb *rcb);
+
+/**
+ * Add reservation to array of reservations
+ * @resv: reservation to add
+ * @resvs: array of reservations
+ * @excl_resvs_bitmap: bitmap for exclusive reservations
+ * @num_resvs: number of reservations in array
+ * @exclusive: bool to store in excl_resvs_bitmap
+ */
+void
+drm_add_reservation(struct reservation_object *resv,
+			struct reservation_object **resvs,
+			unsigned long *excl_resvs_bitmap,
+			unsigned int *num_resvs, bool exclusive);
+
+/**
+ * Acquire ww_mutex lock on all reservations in the array
+ * @resvs: array of reservations
+ * @num_resvs: number of reservations in the array
+ * @ctx: ww mutex context
+ */
+int drm_lock_reservations(struct reservation_object **resvs,
+			unsigned int num_resvs, struct ww_acquire_ctx *ctx);
+
+/**
+ * Release ww_mutex lock on all reservations in the array
+ * @resvs: array of reservations
+ * @num_resvs: number of reservations in the array
+ * @ctx: ww mutex context
+ */
+void drm_unlock_reservations(struct reservation_object **resvs,
+				unsigned int num_resvs,
+				struct ww_acquire_ctx *ctx);
+
+#endif
diff --git a/include/dt-bindings/clock/rk3399-cru.h b/include/dt-bindings/clock/rk3399-cru.h
index 44e0a319f..b541bdce1 100644
--- a/include/dt-bindings/clock/rk3399-cru.h
+++ b/include/dt-bindings/clock/rk3399-cru.h
@@ -7,6 +7,8 @@
 #ifndef _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H
 #define _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H
 
+#define RK3399_TWO_PLL_FOR_VOP
+
 /* core clocks */
 #define PLL_APLLL			1
 #define PLL_APLLB			2
@@ -19,6 +21,7 @@
 #define ARMCLKB				9
 
 /* sclk gates (special clocks) */
+#define SCLK_I2SOUT_SRC			64
 #define SCLK_I2C1			65
 #define SCLK_I2C2			66
 #define SCLK_I2C3			67
@@ -122,9 +125,18 @@
 #define SCLK_DPHY_RX0_CFG		165
 #define SCLK_RMII_SRC			166
 #define SCLK_PCIEPHY_REF100M		167
-#define SCLK_DDRC			168
-#define SCLK_TESTCLKOUT1		169
-#define SCLK_TESTCLKOUT2		170
+#define SCLK_USBPHY0_480M_SRC		168
+#define SCLK_USBPHY1_480M_SRC		169
+#define SCLK_DDRC			170
+#define SCLK_TESTCLKOUT2		171
+#define SCLK_UART0_SRC			172
+#define SCLK_UART_SRC			173
+#define SCLK_I2S0_DIV			174
+#define SCLK_I2S1_DIV			175
+#define SCLK_I2S2_DIV			176
+#define SCLK_SPDIF_DIV			177
+#define SCLK_TESTCLKOUT1		179
+#define SCLK_CIF_OUT_SRC		178
 
 #define DCLK_VOP0			180
 #define DCLK_VOP1			181
@@ -351,6 +363,7 @@
 #define SCLK_I2C0_PMU			9
 #define SCLK_I2C4_PMU			10
 #define SCLK_I2C8_PMU			11
+#define SCLK_UART4_SRC			12
 
 #define PCLK_SRC_PMU			19
 #define PCLK_PMU			20
@@ -421,7 +434,7 @@
 #define SRST_A_ADB400_GIC2COREB		40
 #define SRST_A_ADB400_COREB2GIC		41
 #define SRST_P_DBG_B			42
-#define SRST_L2_B_T			43
+#define SRST_L2_B_T			44
 #define SRST_ADB_B_T			45
 #define SRST_A_RKPERF_B			46
 #define SRST_PVTM_CORE_B		47
@@ -594,13 +607,13 @@
 #define SRST_P_SPI0			214
 #define SRST_P_SPI1			215
 #define SRST_P_SPI2			216
-#define SRST_P_SPI3			217
-#define SRST_P_SPI4			218
+#define SRST_P_SPI4			217
+#define SRST_P_SPI5			218
 #define SRST_SPI0			219
 #define SRST_SPI1			220
 #define SRST_SPI2			221
-#define SRST_SPI3			222
-#define SRST_SPI4			223
+#define SRST_SPI4			222
+#define SRST_SPI5			223
 
 /* cru_softrst_con14 */
 #define SRST_I2S0_8CH			224
@@ -722,8 +735,8 @@
 #define SRST_H_CM0S_NOC			3
 #define SRST_DBG_CM0S			4
 #define SRST_PO_CM0S			5
-#define SRST_P_SPI6			6
-#define SRST_SPI6			7
+#define SRST_P_SPI3			6
+#define SRST_SPI3			7
 #define SRST_P_TIMER_0_1		8
 #define SRST_P_TIMER_0			9
 #define SRST_P_TIMER_1			10
diff --git a/include/dt-bindings/clock/rockchip-ddr.h b/include/dt-bindings/clock/rockchip-ddr.h
new file mode 100644
index 000000000..b065432e7
--- /dev/null
+++ b/include/dt-bindings/clock/rockchip-ddr.h
@@ -0,0 +1,63 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+
+#define DDR2_DEFAULT	(0)
+
+#define DDR3_800D	(0)	/* 5-5-5 */
+#define DDR3_800E	(1)	/* 6-6-6 */
+#define DDR3_1066E	(2)	/* 6-6-6 */
+#define DDR3_1066F	(3)	/* 7-7-7 */
+#define DDR3_1066G	(4)	/* 8-8-8 */
+#define DDR3_1333F	(5)	/* 7-7-7 */
+#define DDR3_1333G	(6)	/* 8-8-8 */
+#define DDR3_1333H	(7)	/* 9-9-9 */
+#define DDR3_1333J	(8)	/* 10-10-10 */
+#define DDR3_1600G	(9)	/* 8-8-8 */
+#define DDR3_1600H	(10)	/* 9-9-9 */
+#define DDR3_1600J	(11)	/* 10-10-10 */
+#define DDR3_1600K	(12)	/* 11-11-11 */
+#define DDR3_1866J	(13)	/* 10-10-10 */
+#define DDR3_1866K	(14)	/* 11-11-11 */
+#define DDR3_1866L	(15)	/* 12-12-12 */
+#define DDR3_1866M	(16)	/* 13-13-13 */
+#define DDR3_2133K	(17)	/* 11-11-11 */
+#define DDR3_2133L	(18)	/* 12-12-12 */
+#define DDR3_2133M	(19)	/* 13-13-13 */
+#define DDR3_2133N	(20)	/* 14-14-14 */
+#define DDR3_DEFAULT	(21)
+#define DDR_DDR2	(22)
+#define DDR_LPDDR	(23)
+#define DDR_LPDDR2	(24)
+
+#define DDR4_1600J	(0)	/* 10-10-10 */
+#define DDR4_1600K	(1)	/* 11-11-11 */
+#define DDR4_1600L	(2)	/* 12-12-12 */
+#define DDR4_1866L	(3)	/* 12-12-12 */
+#define DDR4_1866M	(4)	/* 13-13-13 */
+#define DDR4_1866N	(5)	/* 14-14-14 */
+#define DDR4_2133N	(6)	/* 14-14-14 */
+#define DDR4_2133P	(7)	/* 15-15-15 */
+#define DDR4_2133R	(8)	/* 16-16-16 */
+#define DDR4_2400P	(9)	/* 15-15-15 */
+#define DDR4_2400R	(10)	/* 16-16-16 */
+#define DDR4_2400U	(11)	/* 18-18-18 */
+#define DDR4_DEFAULT	(12)
+
+#define PAUSE_CPU_STACK_SIZE	16
+
+#endif
diff --git a/include/dt-bindings/clock/rockchip.h b/include/dt-bindings/clock/rockchip.h
new file mode 100644
index 000000000..b438f7bd4
--- /dev/null
+++ b/include/dt-bindings/clock/rockchip.h
@@ -0,0 +1,101 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_H
+
+#ifndef BIT
+#define BIT(nr)			(1 << (nr))
+#endif
+
+#define CLK_DIVIDER_PLUS_ONE		(0)
+#define CLK_DIVIDER_ONE_BASED		BIT(0)
+#define CLK_DIVIDER_POWER_OF_TWO	BIT(1)
+#define CLK_DIVIDER_ALLOW_ZERO		BIT(2)
+#define CLK_DIVIDER_HIWORD_MASK		BIT(3)
+
+/* Rockchip special defined */
+//#define CLK_DIVIDER_FIXED		BIT(6)
+#define CLK_DIVIDER_USER_DEFINE		BIT(7)
+
+/*
+ * flags used across common struct clk.  these flags should only affect the
+ * top-level framework.  custom flags for dealing with hardware specifics
+ * belong in struct clk_foo
+ */
+#define CLK_SET_RATE_GATE	BIT(0) /* must be gated across rate change */
+#define CLK_SET_PARENT_GATE	BIT(1) /* must be gated across re-parent */
+#define CLK_SET_RATE_PARENT	BIT(2) /* propagate rate change up one level */
+#define CLK_IGNORE_UNUSED	BIT(3) /* do not gate even if unused */
+#define CLK_IS_ROOT		BIT(4) /* root clk, has no parent */
+#define CLK_IS_BASIC		BIT(5) /* Basic clk, can't do a to_clk_foo() */
+#define CLK_GET_RATE_NOCACHE	BIT(6) /* do not use the cached clk rate */
+#define CLK_SET_RATE_NO_REPARENT BIT(7) /* don't re-parent on rate change */
+#define CLK_SET_RATE_PARENT_IN_ORDER BIT(8) /* consider the order of re-parent
+						and set_div on rate change */
+
+
+
+/* Rockchip pll flags */
+#define CLK_PLL_3188		BIT(0)
+#define CLK_PLL_3188_APLL	BIT(1)
+#define CLK_PLL_3188PLUS	BIT(2)
+#define CLK_PLL_3188PLUS_APLL	BIT(3)
+#define CLK_PLL_3288_APLL	BIT(4)
+#define CLK_PLL_3188PLUS_AUTO	BIT(5)
+#define CLK_PLL_3036_APLL	BIT(6)
+#define CLK_PLL_3036PLUS_AUTO	BIT(7)
+#define CLK_PLL_312XPLUS	BIT(8)
+#define CLK_PLL_3368_APLLB	BIT(9)
+#define CLK_PLL_3368_APLLL	BIT(10)
+#define CLK_PLL_3368_LOW_JITTER	BIT(11)
+
+
+/* rate_ops index */
+#define CLKOPS_RATE_MUX_DIV		1
+#define CLKOPS_RATE_EVENDIV		2
+#define CLKOPS_RATE_MUX_EVENDIV		3
+#define CLKOPS_RATE_I2S_FRAC		4
+#define CLKOPS_RATE_FRAC		5
+#define CLKOPS_RATE_I2S			6
+#define CLKOPS_RATE_CIFOUT		7
+#define CLKOPS_RATE_UART		8
+#define CLKOPS_RATE_HSADC		9
+#define CLKOPS_RATE_MAC_REF		10
+#define CLKOPS_RATE_CORE		11
+#define CLKOPS_RATE_CORE_CHILD		12
+#define CLKOPS_RATE_DDR			13
+#define CLKOPS_RATE_RK3288_I2S		14
+#define CLKOPS_RATE_RK3288_USB480M	15
+#define CLKOPS_RATE_RK3288_DCLK_LCDC0	16
+#define CLKOPS_RATE_RK3288_DCLK_LCDC1	17
+#define CLKOPS_RATE_DDR_DIV2		18
+#define CLKOPS_RATE_DDR_DIV4		19
+#define CLKOPS_RATE_RK3368_MUX_DIV_NPLL 20
+#define CLKOPS_RATE_RK3368_DCLK_LCDC	21
+#define CLKOPS_RATE_RK3368_DDR		22
+
+#define CLKOPS_TABLE_END		(~0)
+
+/* pd id */
+#define CLK_PD_BCPU		0
+#define CLK_PD_BDSP		1
+#define CLK_PD_BUS		2
+#define CLK_PD_CPU_0 		3
+#define CLK_PD_CPU_1 		4
+#define CLK_PD_CPU_2 		5
+#define CLK_PD_CPU_3 		6
+#define CLK_PD_CS 		7
+#define CLK_PD_GPU 		8
+#define CLK_PD_HEVC 		9
+#define CLK_PD_PERI 		10
+#define CLK_PD_SCU 		11
+#define CLK_PD_VIDEO 		12
+#define CLK_PD_VIO		13
+#define CLK_PD_GPU_0		14
+#define CLK_PD_GPU_1		15
+
+#define CLK_PD_VIRT		255
+
+/* reset flag */
+#define ROCKCHIP_RESET_HIWORD_MASK	BIT(0)
+
+#endif /* _DT_BINDINGS_CLOCK_ROCKCHIP_H */
diff --git a/include/dt-bindings/display/drm_mipi_dsi.h b/include/dt-bindings/display/drm_mipi_dsi.h
new file mode 100644
index 000000000..bc24ce4dd
--- /dev/null
+++ b/include/dt-bindings/display/drm_mipi_dsi.h
@@ -0,0 +1,53 @@
+/*
+ * MIPI DSI Bus
+ *
+ * Copyright (c) Fuzhou Rockchip Electronics Co.Ltd
+ * Authors:
+ *       Mark Yao <yzq@rock-chips.com>
+ *
+ * based on include/drm/drm_mipi_dsi.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _DRM_MIPI_DSI_H__
+#define _DRM_MIPI_DSI_H__
+
+/* DSI mode flags */
+
+/* video mode */
+#define MIPI_DSI_MODE_VIDEO		(1 << 0)
+/* video burst mode */
+#define MIPI_DSI_MODE_VIDEO_BURST	(1 << 1)
+/* video pulse mode */
+#define MIPI_DSI_MODE_VIDEO_SYNC_PULSE	(1 << 2)
+/* enable auto vertical count mode */
+#define MIPI_DSI_MODE_VIDEO_AUTO_VERT	(1 << 3)
+/* enable hsync-end packets in vsync-pulse and v-porch area */
+#define MIPI_DSI_MODE_VIDEO_HSE		(1 << 4)
+/* disable hfront-porch area */
+#define MIPI_DSI_MODE_VIDEO_HFP		(1 << 5)
+/* disable hback-porch area */
+#define MIPI_DSI_MODE_VIDEO_HBP		(1 << 6)
+/* disable hsync-active area */
+#define MIPI_DSI_MODE_VIDEO_HSA		(1 << 7)
+/* flush display FIFO on vsync pulse */
+#define MIPI_DSI_MODE_VSYNC_FLUSH	(1 << 8)
+/* disable EoT packets in HS mode */
+#define MIPI_DSI_MODE_EOT_PACKET	(1 << 9)
+/* device supports non-continuous clock behavior (DSI spec 5.6.1) */
+#define MIPI_DSI_CLOCK_NON_CONTINUOUS	(1 << 10)
+/* transmit data in low power */
+#define MIPI_DSI_MODE_LPM		(1 << 11)
+
+#define MIPI_DSI_FMT_RGB888		0
+#define MIPI_DSI_FMT_RGB666		1
+#define MIPI_DSI_FMT_RGB666_PACKED	2
+#define MIPI_DSI_FMT_RGB565		3
+
+#define MIPI_CSI_FMT_RAW8		0x10
+#define MIPI_CSI_FMT_RAW10		0x11
+
+#endif /* __DRM_MIPI_DSI__ */
diff --git a/include/dt-bindings/display/media-bus-format.h b/include/dt-bindings/display/media-bus-format.h
new file mode 100644
index 000000000..b8e9a1bb3
--- /dev/null
+++ b/include/dt-bindings/display/media-bus-format.h
@@ -0,0 +1,152 @@
+/*
+ * Media Bus API header
+ *
+ * Copyright (C) 2009, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MEDIA_BUS_FORMAT_H
+#define __LINUX_MEDIA_BUS_FORMAT_H
+
+/*
+ * These bus formats uniquely identify data formats on the data bus. Format 0
+ * is reserved, MEDIA_BUS_FMT_FIXED shall be used by host-client pairs, where
+ * the data format is fixed. Additionally, "2X8" means that one pixel is
+ * transferred in two 8-bit samples, "BE" or "LE" specify in which order those
+ * samples are transferred over the bus: "LE" means that the least significant
+ * bits are transferred first, "BE" means that the most significant bits are
+ * transferred first, and "PADHI" and "PADLO" define which bits - low or high,
+ * in the incomplete high byte, are filled with padding bits.
+ *
+ * The bus formats are grouped by type, bus_width, bits per component, samples
+ * per pixel and order of subsamples. Numerical values are sorted using generic
+ * numerical sort order (8 thus comes before 10).
+ *
+ * As their value can't change when a new bus format is inserted in the
+ * enumeration, the bus formats are explicitly given a numerical value. The next
+ * free values for each category are listed below, update them when inserting
+ * new pixel codes.
+ */
+
+#define MEDIA_BUS_FMT_FIXED			0x0001
+
+/* RGB - next is	0x1024 */
+#define MEDIA_BUS_FMT_RGB444_1X12		0x1016
+#define MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE	0x1001
+#define MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE	0x1002
+#define MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE	0x1003
+#define MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE	0x1004
+#define MEDIA_BUS_FMT_RGB565_1X16		0x1017
+#define MEDIA_BUS_FMT_BGR565_2X8_BE		0x1005
+#define MEDIA_BUS_FMT_BGR565_2X8_LE		0x1006
+#define MEDIA_BUS_FMT_RGB565_2X8_BE		0x1007
+#define MEDIA_BUS_FMT_RGB565_2X8_LE		0x1008
+#define MEDIA_BUS_FMT_RGB666_1X18		0x1009
+#define MEDIA_BUS_FMT_RBG888_1X24		0x100e
+#define MEDIA_BUS_FMT_RGB666_1X24_CPADHI	0x1015
+#define MEDIA_BUS_FMT_RGB666_1X7X3_SPWG		0x1010
+#define MEDIA_BUS_FMT_BGR888_1X24		0x1013
+#define MEDIA_BUS_FMT_GBR888_1X24		0x1014
+#define MEDIA_BUS_FMT_RGB888_1X24		0x100a
+#define MEDIA_BUS_FMT_RGB888_2X12_BE		0x100b
+#define MEDIA_BUS_FMT_RGB888_2X12_LE		0x100c
+#define MEDIA_BUS_FMT_RGB888_1X7X4_SPWG		0x1011
+#define MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA	0x1012
+#define MEDIA_BUS_FMT_ARGB8888_1X32		0x100d
+#define MEDIA_BUS_FMT_RGB888_1X32_PADHI		0x100f
+#define MEDIA_BUS_FMT_RGB101010_1X30		0x1018
+#define MEDIA_BUS_FMT_RGB121212_1X36		0x1019
+#define MEDIA_BUS_FMT_RGB161616_1X48		0x101a
+#define MEDIA_BUS_FMT_BGR888_3X8		0x101b
+#define MEDIA_BUS_FMT_RGB888_3X8		0x101c
+#define MEDIA_BUS_FMT_RGB888_DUMMY_4X8		0x101f
+#define MEDIA_BUS_FMT_BGR888_DUMMY_4X8		0x1020
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG	0x1022
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA	0x1023
+
+/* YUV (including grey) - next is	0x202c */
+#define MEDIA_BUS_FMT_Y8_1X8			0x2001
+#define MEDIA_BUS_FMT_UV8_1X8			0x2015
+#define MEDIA_BUS_FMT_UYVY8_1_5X8		0x2002
+#define MEDIA_BUS_FMT_VYUY8_1_5X8		0x2003
+#define MEDIA_BUS_FMT_YUYV8_1_5X8		0x2004
+#define MEDIA_BUS_FMT_YVYU8_1_5X8		0x2005
+#define MEDIA_BUS_FMT_UYVY8_2X8			0x2006
+#define MEDIA_BUS_FMT_VYUY8_2X8			0x2007
+#define MEDIA_BUS_FMT_YUYV8_2X8			0x2008
+#define MEDIA_BUS_FMT_YVYU8_2X8			0x2009
+#define MEDIA_BUS_FMT_Y10_1X10			0x200a
+#define MEDIA_BUS_FMT_UYVY10_2X10		0x2018
+#define MEDIA_BUS_FMT_VYUY10_2X10		0x2019
+#define MEDIA_BUS_FMT_YUYV10_2X10		0x200b
+#define MEDIA_BUS_FMT_YVYU10_2X10		0x200c
+#define MEDIA_BUS_FMT_Y12_1X12			0x2013
+#define MEDIA_BUS_FMT_UYVY12_2X12		0x201c
+#define MEDIA_BUS_FMT_VYUY12_2X12		0x201d
+#define MEDIA_BUS_FMT_YUYV12_2X12		0x201e
+#define MEDIA_BUS_FMT_YVYU12_2X12		0x201f
+#define MEDIA_BUS_FMT_UYVY8_1X16		0x200f
+#define MEDIA_BUS_FMT_VYUY8_1X16		0x2010
+#define MEDIA_BUS_FMT_YUYV8_1X16		0x2011
+#define MEDIA_BUS_FMT_YVYU8_1X16		0x2012
+#define MEDIA_BUS_FMT_YDYUYDYV8_1X16		0x2014
+#define MEDIA_BUS_FMT_UYVY10_1X20		0x201a
+#define MEDIA_BUS_FMT_VYUY10_1X20		0x201b
+#define MEDIA_BUS_FMT_YUYV10_1X20		0x200d
+#define MEDIA_BUS_FMT_YVYU10_1X20		0x200e
+#define MEDIA_BUS_FMT_VUY8_1X24			0x2024
+#define MEDIA_BUS_FMT_YUV8_1X24			0x2025
+#define MEDIA_BUS_FMT_UYYVYY8_0_5X24		0x2026
+#define MEDIA_BUS_FMT_UYVY12_1X24		0x2020
+#define MEDIA_BUS_FMT_VYUY12_1X24		0x2021
+#define MEDIA_BUS_FMT_YUYV12_1X24		0x2022
+#define MEDIA_BUS_FMT_YVYU12_1X24		0x2023
+#define MEDIA_BUS_FMT_YUV10_1X30		0x2016
+#define MEDIA_BUS_FMT_UYYVYY10_0_5X30		0x2027
+#define MEDIA_BUS_FMT_AYUV8_1X32		0x2017
+#define MEDIA_BUS_FMT_UYYVYY12_0_5X36		0x2028
+#define MEDIA_BUS_FMT_YUV12_1X36		0x2029
+#define MEDIA_BUS_FMT_YUV16_1X48		0x202a
+#define MEDIA_BUS_FMT_UYYVYY16_0_5X48		0x202b
+
+/* Bayer - next is	0x3019 */
+#define MEDIA_BUS_FMT_SBGGR8_1X8		0x3001
+#define MEDIA_BUS_FMT_SGBRG8_1X8		0x3013
+#define MEDIA_BUS_FMT_SGRBG8_1X8		0x3002
+#define MEDIA_BUS_FMT_SRGGB8_1X8		0x3014
+#define MEDIA_BUS_FMT_SBGGR10_ALAW8_1X8		0x3015
+#define MEDIA_BUS_FMT_SGBRG10_ALAW8_1X8		0x3016
+#define MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8		0x3017
+#define MEDIA_BUS_FMT_SRGGB10_ALAW8_1X8		0x3018
+#define MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8		0x300b
+#define MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8		0x300c
+#define MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8		0x3009
+#define MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8		0x300d
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE	0x3003
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE	0x3004
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE	0x3005
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE	0x3006
+#define MEDIA_BUS_FMT_SBGGR10_1X10		0x3007
+#define MEDIA_BUS_FMT_SGBRG10_1X10		0x300e
+#define MEDIA_BUS_FMT_SGRBG10_1X10		0x300a
+#define MEDIA_BUS_FMT_SRGGB10_1X10		0x300f
+#define MEDIA_BUS_FMT_SBGGR12_1X12		0x3008
+#define MEDIA_BUS_FMT_SGBRG12_1X12		0x3010
+#define MEDIA_BUS_FMT_SGRBG12_1X12		0x3011
+#define MEDIA_BUS_FMT_SRGGB12_1X12		0x3012
+
+/* JPEG compressed formats - next is	0x4002 */
+#define MEDIA_BUS_FMT_JPEG_1X8			0x4001
+
+/* Vendor specific formats - next is	0x5002 */
+
+/* S5C73M3 sensor specific interleaved UYVY and JPEG */
+#define MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8		0x5001
+
+/* HSV - next is	0x6002 */
+#define MEDIA_BUS_FMT_AHSV8888_1X32		0x6001
+
+#endif /* __LINUX_MEDIA_BUS_FORMAT_H */
diff --git a/include/dt-bindings/display/mipi_dsi.h b/include/dt-bindings/display/mipi_dsi.h
new file mode 100644
index 000000000..c79e7f930
--- /dev/null
+++ b/include/dt-bindings/display/mipi_dsi.h
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+drivers/video/rockchip/transmitter/mipi_dsi.h
+*/
+#ifndef MIPI_DSI_H_
+#define MIPI_DSI_H_
+
+#ifdef CONFIG_MIPI_DSI_FT
+#include "..\..\common\config.h"
+#endif
+
+//DSI DATA TYPE
+#define DTYPE_DCS_SWRITE_0P		0x05
+#define DTYPE_DCS_SWRITE_1P		0x15
+#define DTYPE_DCS_LWRITE		0x39
+#define DTYPE_GEN_LWRITE		0x29
+#define DTYPE_GEN_SWRITE_2P		0x23
+#define DTYPE_GEN_SWRITE_1P		0x13
+#define DTYPE_GEN_SWRITE_0P		0x03
+
+//command transmit mode
+#define HSDT			0x00
+#define LPDT			0x01
+
+//DSI DATA TYPE FLAG
+#define DATA_TYPE_DCS			0x00
+#define DATA_TYPE_GEN			0x01
+
+//Video Mode
+#define VM_NBMWSP		0x00  //Non burst mode with sync pulses
+#define VM_NBMWSE		0x01  //Non burst mode with sync events
+#define VM_BM			0x02  //Burst mode
+
+//Video Pixel Format
+#define VPF_16BPP		0x00
+#define VPF_18BPP		0x01	 //packed
+#define VPF_18BPPL		0x02     //loosely packed
+#define VPF_24BPP		0x03
+
+//Display Command Set
+#define dcs_enter_idle_mode 		0x39
+#define dcs_enter_invert_mode 		0x21
+#define dcs_enter_normal_mode 		0x13
+#define dcs_enter_partial_mode  	0x12
+#define dcs_enter_sleep_mode  		0x10
+#define dcs_exit_idle_mode  		0x38
+#define dcs_exit_invert_mode  		0x20
+#define dcs_exit_sleep_mode  		0x11
+#define dcs_get_address_mode  		0x0b
+#define dcs_get_blue_channel  		0x08
+#define dcs_get_diagnostic_result  	0x0f
+#define dcs_get_display_mode  		0x0d
+#define dcs_get_green_channel  		0x07
+#define dcs_get_pixel_format  		0x0c
+#define dcs_get_power_mode  		0x0a
+#define dcs_get_red_channel 		0x06
+#define dcs_get_scanline 	 		0x45
+#define dcs_get_signal_mode  		0x0e
+#define dcs_nop				 		0x00
+#define dcs_read_DDB_continue  		0xa8
+#define dcs_read_DDB_start  		0xa1
+#define dcs_read_memory_continue  	0x3e
+#define dcs_read_memory_start  		0x2e
+#define dcs_set_address_mode  		0x36
+#define dcs_set_column_address  	0x2a
+#define dcs_set_display_off  		0x28
+#define dcs_set_display_on  		0x29
+#define dcs_set_gamma_curve  		0x26
+#define dcs_set_page_address  		0x2b
+#define dcs_set_partial_area  		0x30
+#define dcs_set_pixel_format  		0x3a
+#define dcs_set_scroll_area  		0x33
+#define dcs_set_scroll_start  		0x37
+#define dcs_set_tear_off 	 		0x34
+#define dcs_set_tear_on 	 		0x35
+#define dcs_set_tear_scanline  		0x44
+#define dcs_soft_reset 		 		0x01
+#define dcs_write_LUT 		 		0x2d
+#define dcs_write_memory_continue  	0x3c
+#define dcs_write_memory_start 		0x2c
+
+#ifndef MHz
+#define MHz   1000000
+#endif
+
+
+#if 0
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long s64;
+typedef unsigned long u64;
+#endif
+
+
+//iomux
+#define OLD_RK_IOMUX 0
+
+
+#endif /* end of MIPI_DSI_H_ */
diff --git a/include/dt-bindings/display/rockchip_vop.h b/include/dt-bindings/display/rockchip_vop.h
new file mode 100644
index 000000000..3e14128e7
--- /dev/null
+++ b/include/dt-bindings/display/rockchip_vop.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+
+#ifndef _DT_BINDINGS_ROCKCHIP_VOP_H
+#define _DT_BINDINGS_ROCKCHIP_VOP_H
+
+#define	ROCKCHIP_VOP2_CLUSTER0	0
+#define	ROCKCHIP_VOP2_CLUSTER1	1
+#define	ROCKCHIP_VOP2_ESMART0	2
+#define	ROCKCHIP_VOP2_ESMART1	3
+#define	ROCKCHIP_VOP2_SMART0	4
+#define	ROCKCHIP_VOP2_SMART1	5
+#define	ROCKCHIP_VOP2_CLUSTER2	6
+#define	ROCKCHIP_VOP2_CLUSTER3	7
+#define	ROCKCHIP_VOP2_ESMART2	8
+#define	ROCKCHIP_VOP2_ESMART3	9
+
+#endif
diff --git a/include/dt-bindings/input/rk-input.h b/include/dt-bindings/input/rk-input.h
new file mode 100644
index 000000000..00b412927
--- /dev/null
+++ b/include/dt-bindings/input/rk-input.h
@@ -0,0 +1,814 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Device properties and quirks
+ */
+
+#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
+#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
+#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
+#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
+
+#define INPUT_PROP_MAX			0x1f
+#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
+
+/*
+ * Event types
+ */
+
+#define EV_SYN			0x00
+#define EV_KEY			0x01
+#define EV_REL			0x02
+#define EV_ABS			0x03
+#define EV_MSC			0x04
+#define EV_SW			0x05
+#define EV_LED			0x11
+#define EV_SND			0x12
+#define EV_REP			0x14
+#define EV_FF			0x15
+#define EV_PWR			0x16
+#define EV_FF_STATUS		0x17
+#define EV_MAX			0x1f
+#define EV_CNT			(EV_MAX+1)
+
+/*
+ * Synchronization events.
+ */
+
+#define SYN_REPORT		0
+#define SYN_CONFIG		1
+#define SYN_MT_REPORT		2
+#define SYN_DROPPED		3
+
+/*
+ * Keys and buttons
+ *
+ * Most of the keys/buttons are modeled after USB HUT 1.12
+ * (see http://www.usb.org/developers/hidpage).
+ * Abbreviations in the comments:
+ * AC - Application Control
+ * AL - Application Launch Button
+ * SC - System Control
+ */
+
+#define KEY_RESERVED		0
+#define KEY_ESC			1
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+#define KEY_MINUS		12
+#define KEY_EQUAL		13
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_LEFTBRACE		26
+#define KEY_RIGHTBRACE		27
+#define KEY_ENTER		28
+#define KEY_LEFTCTRL		29
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_SEMICOLON		39
+#define KEY_APOSTROPHE		40
+#define KEY_GRAVE		41
+#define KEY_LEFTSHIFT		42
+#define KEY_BACKSLASH		43
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_DOT			52
+#define KEY_SLASH		53
+#define KEY_RIGHTSHIFT		54
+#define KEY_KPASTERISK		55
+#define KEY_LEFTALT		56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+#define KEY_NUMLOCK		69
+#define KEY_SCROLLLOCK		70
+#define KEY_KP7			71
+#define KEY_KP8			72
+#define KEY_KP9			73
+#define KEY_KPMINUS		74
+#define KEY_KP4			75
+#define KEY_KP5			76
+#define KEY_KP6			77
+#define KEY_KPPLUS		78
+#define KEY_KP1			79
+#define KEY_KP2			80
+#define KEY_KP3			81
+#define KEY_KP0			82
+#define KEY_KPDOT		83
+
+#define KEY_ZENKAKUHANKAKU	85
+#define KEY_102ND		86
+#define KEY_F11			87
+#define KEY_F12			88
+#define KEY_RO			89
+#define KEY_KATAKANA		90
+#define KEY_HIRAGANA		91
+#define KEY_HENKAN		92
+#define KEY_KATAKANAHIRAGANA	93
+#define KEY_MUHENKAN		94
+#define KEY_KPJPCOMMA		95
+#define KEY_KPENTER		96
+#define KEY_RIGHTCTRL		97
+#define KEY_KPSLASH		98
+#define KEY_SYSRQ		99
+#define KEY_RIGHTALT		100
+#define KEY_LINEFEED		101
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PAGEUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PAGEDOWN		109
+#define KEY_INSERT		110
+#define KEY_DELETE		111
+#define KEY_MACRO		112
+#define KEY_MUTE		113
+#define KEY_VOLUMEDOWN		114
+#define KEY_VOLUMEUP		115
+#define KEY_POWER		116	/* SC System Power Down */
+#define KEY_KPEQUAL		117
+#define KEY_KPPLUSMINUS		118
+#define KEY_PAUSE		119
+#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
+
+#define KEY_KPCOMMA		121
+#define KEY_HANGEUL		122
+#define KEY_HANGUEL		KEY_HANGEUL
+#define KEY_HANJA		123
+#define KEY_YEN			124
+#define KEY_LEFTMETA		125
+#define KEY_RIGHTMETA		126
+#define KEY_COMPOSE		127
+
+#define KEY_STOP		128	/* AC Stop */
+#define KEY_AGAIN		129
+#define KEY_PROPS		130	/* AC Properties */
+#define KEY_UNDO		131	/* AC Undo */
+#define KEY_FRONT		132
+#define KEY_COPY		133	/* AC Copy */
+#define KEY_OPEN		134	/* AC Open */
+#define KEY_PASTE		135	/* AC Paste */
+#define KEY_FIND		136	/* AC Search */
+#define KEY_CUT			137	/* AC Cut */
+#define KEY_HELP		138	/* AL Integrated Help Center */
+#define KEY_MENU		139	/* Menu (show menu) */
+#define KEY_CALC		140	/* AL Calculator */
+#define KEY_SETUP		141
+#define KEY_SLEEP		142	/* SC System Sleep */
+#define KEY_WAKEUP		143	/* System Wake Up */
+#define KEY_FILE		144	/* AL Local Machine Browser */
+#define KEY_SENDFILE		145
+#define KEY_DELETEFILE		146
+#define KEY_XFER		147
+#define KEY_PROG1		148
+#define KEY_PROG2		149
+#define KEY_WWW			150	/* AL Internet Browser */
+#define KEY_MSDOS		151
+#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
+#define KEY_SCREENLOCK		KEY_COFFEE
+#define KEY_DIRECTION		153
+#define KEY_CYCLEWINDOWS	154
+#define KEY_MAIL		155
+#define KEY_BOOKMARKS		156	/* AC Bookmarks */
+#define KEY_COMPUTER		157
+#define KEY_BACK		158	/* AC Back */
+#define KEY_FORWARD		159	/* AC Forward */
+#define KEY_CLOSECD		160
+#define KEY_EJECTCD		161
+#define KEY_EJECTCLOSECD	162
+#define KEY_NEXTSONG		163
+#define KEY_PLAYPAUSE		164
+#define KEY_PREVIOUSSONG	165
+#define KEY_STOPCD		166
+#define KEY_RECORD		167
+#define KEY_REWIND		168
+#define KEY_PHONE		169	/* Media Select Telephone */
+#define KEY_ISO			170
+#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
+#define KEY_HOMEPAGE		172	/* AC Home */
+#define KEY_REFRESH		173	/* AC Refresh */
+#define KEY_EXIT		174	/* AC Exit */
+#define KEY_MOVE		175
+#define KEY_EDIT		176
+#define KEY_SCROLLUP		177
+#define KEY_SCROLLDOWN		178
+#define KEY_KPLEFTPAREN		179
+#define KEY_KPRIGHTPAREN	180
+#define KEY_NEW			181	/* AC New */
+#define KEY_REDO		182	/* AC Redo/Repeat */
+
+#define KEY_F13			183
+#define KEY_F14			184
+#define KEY_F15			185
+#define KEY_F16			186
+#define KEY_F17			187
+#define KEY_F18			188
+#define KEY_F19			189
+#define KEY_F20			190
+#define KEY_F21			191
+#define KEY_F22			192
+#define KEY_F23			193
+#define KEY_F24			194
+
+#define KEY_PLAYCD		200
+#define KEY_PAUSECD		201
+#define KEY_PROG3		202
+#define KEY_PROG4		203
+#define KEY_DASHBOARD		204	/* AL Dashboard */
+#define KEY_SUSPEND		205
+#define KEY_CLOSE		206	/* AC Close */
+#define KEY_PLAY		207
+#define KEY_FASTFORWARD		208
+#define KEY_BASSBOOST		209
+#define KEY_PRINT		210	/* AC Print */
+#define KEY_HP			211
+#define KEY_CAMERA		212
+#define KEY_SOUND		213
+#define KEY_QUESTION		214
+#define KEY_EMAIL		215
+#define KEY_CHAT		216
+#define KEY_SEARCH		217
+#define KEY_CONNECT		218
+#define KEY_FINANCE		219	/* AL Checkbook/Finance */
+#define KEY_SPORT		220
+#define KEY_SHOP		221
+#define KEY_ALTERASE		222
+#define KEY_CANCEL		223	/* AC Cancel */
+#define KEY_BRIGHTNESSDOWN	224
+#define KEY_BRIGHTNESSUP	225
+#define KEY_MEDIA		226
+
+#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
+					   outputs (Monitor/LCD/TV-out/etc) */
+#define KEY_KBDILLUMTOGGLE	228
+#define KEY_KBDILLUMDOWN	229
+#define KEY_KBDILLUMUP		230
+
+#define KEY_SEND		231	/* AC Send */
+#define KEY_REPLY		232	/* AC Reply */
+#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
+#define KEY_SAVE		234	/* AC Save */
+#define KEY_DOCUMENTS		235
+
+#define KEY_BATTERY		236
+
+#define KEY_BLUETOOTH		237
+#define KEY_WLAN		238
+#define KEY_UWB			239
+
+#define KEY_UNKNOWN		240
+
+#define KEY_VIDEO_NEXT		241	/* drive next video source */
+#define KEY_VIDEO_PREV		242	/* drive previous video source */
+#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
+#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
+					  brightness control is off,
+					  rely on ambient */
+#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
+#define KEY_DISPLAY_OFF		245	/* display device to off state */
+
+#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
+#define KEY_WIMAX		KEY_WWAN
+#define KEY_RFKILL		247	/* Key that controls all radios */
+
+#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+
+/* Code 255 is reserved for special needs of AT keyboard driver */
+
+#define BTN_MISC		0x100
+#define BTN_0			0x100
+#define BTN_1			0x101
+#define BTN_2			0x102
+#define BTN_3			0x103
+#define BTN_4			0x104
+#define BTN_5			0x105
+#define BTN_6			0x106
+#define BTN_7			0x107
+#define BTN_8			0x108
+#define BTN_9			0x109
+
+#define BTN_MOUSE		0x110
+#define BTN_LEFT		0x110
+#define BTN_RIGHT		0x111
+#define BTN_MIDDLE		0x112
+#define BTN_SIDE		0x113
+#define BTN_EXTRA		0x114
+#define BTN_FORWARD		0x115
+#define BTN_BACK		0x116
+#define BTN_TASK		0x117
+
+#define BTN_JOYSTICK		0x120
+#define BTN_TRIGGER		0x120
+#define BTN_THUMB		0x121
+#define BTN_THUMB2		0x122
+#define BTN_TOP			0x123
+#define BTN_TOP2		0x124
+#define BTN_PINKIE		0x125
+#define BTN_BASE		0x126
+#define BTN_BASE2		0x127
+#define BTN_BASE3		0x128
+#define BTN_BASE4		0x129
+#define BTN_BASE5		0x12a
+#define BTN_BASE6		0x12b
+#define BTN_DEAD		0x12f
+
+#define BTN_GAMEPAD		0x130
+#define BTN_SOUTH		0x130
+#define BTN_A			BTN_SOUTH
+#define BTN_EAST		0x131
+#define BTN_B			BTN_EAST
+#define BTN_C			0x132
+#define BTN_NORTH		0x133
+#define BTN_X			BTN_NORTH
+#define BTN_WEST		0x134
+#define BTN_Y			BTN_WEST
+#define BTN_Z			0x135
+#define BTN_TL			0x136
+#define BTN_TR			0x137
+#define BTN_TL2			0x138
+#define BTN_TR2			0x139
+#define BTN_SELECT		0x13a
+#define BTN_START		0x13b
+#define BTN_MODE		0x13c
+#define BTN_THUMBL		0x13d
+#define BTN_THUMBR		0x13e
+
+#define BTN_DIGI		0x140
+#define BTN_TOOL_PEN		0x140
+#define BTN_TOOL_RUBBER		0x141
+#define BTN_TOOL_BRUSH		0x142
+#define BTN_TOOL_PENCIL		0x143
+#define BTN_TOOL_AIRBRUSH	0x144
+#define BTN_TOOL_FINGER		0x145
+#define BTN_TOOL_MOUSE		0x146
+#define BTN_TOOL_LENS		0x147
+#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
+#define BTN_TOUCH		0x14a
+#define BTN_STYLUS		0x14b
+#define BTN_STYLUS2		0x14c
+#define BTN_TOOL_DOUBLETAP	0x14d
+#define BTN_TOOL_TRIPLETAP	0x14e
+#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
+
+#define BTN_WHEEL		0x150
+#define BTN_GEAR_DOWN		0x150
+#define BTN_GEAR_UP		0x151
+
+#define KEY_OK			0x160
+#define KEY_SELECT		0x161
+#define KEY_GOTO		0x162
+#define KEY_CLEAR		0x163
+#define KEY_POWER2		0x164
+#define KEY_OPTION		0x165
+#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
+#define KEY_TIME		0x167
+#define KEY_VENDOR		0x168
+#define KEY_ARCHIVE		0x169
+#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
+#define KEY_CHANNEL		0x16b
+#define KEY_FAVORITES		0x16c
+#define KEY_EPG			0x16d
+#define KEY_PVR			0x16e	/* Media Select Home */
+#define KEY_MHP			0x16f
+#define KEY_LANGUAGE		0x170
+#define KEY_TITLE		0x171
+#define KEY_SUBTITLE		0x172
+#define KEY_ANGLE		0x173
+#define KEY_ZOOM		0x174
+#define KEY_MODE		0x175
+#define KEY_KEYBOARD		0x176
+#define KEY_SCREEN		0x177
+#define KEY_PC			0x178	/* Media Select Computer */
+#define KEY_TV			0x179	/* Media Select TV */
+#define KEY_TV2			0x17a	/* Media Select Cable */
+#define KEY_VCR			0x17b	/* Media Select VCR */
+#define KEY_VCR2		0x17c	/* VCR Plus */
+#define KEY_SAT			0x17d	/* Media Select Satellite */
+#define KEY_SAT2		0x17e
+#define KEY_CD			0x17f	/* Media Select CD */
+#define KEY_TAPE		0x180	/* Media Select Tape */
+#define KEY_RADIO		0x181
+#define KEY_TUNER		0x182	/* Media Select Tuner */
+#define KEY_PLAYER		0x183
+#define KEY_TEXT		0x184
+#define KEY_DVD			0x185	/* Media Select DVD */
+#define KEY_AUX			0x186
+#define KEY_MP3			0x187
+#define KEY_AUDIO		0x188	/* AL Audio Browser */
+#define KEY_VIDEO		0x189	/* AL Movie Browser */
+#define KEY_DIRECTORY		0x18a
+#define KEY_LIST		0x18b
+#define KEY_MEMO		0x18c	/* Media Select Messages */
+#define KEY_CALENDAR		0x18d
+#define KEY_RED			0x18e
+#define KEY_GREEN		0x18f
+#define KEY_YELLOW		0x190
+#define KEY_BLUE		0x191
+#define KEY_CHANNELUP		0x192	/* Channel Increment */
+#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
+#define KEY_FIRST		0x194
+#define KEY_LAST		0x195	/* Recall Last */
+#define KEY_AB			0x196
+#define KEY_NEXT		0x197
+#define KEY_RESTART		0x198
+#define KEY_SLOW		0x199
+#define KEY_SHUFFLE		0x19a
+#define KEY_BREAK		0x19b
+#define KEY_PREVIOUS		0x19c
+#define KEY_DIGITS		0x19d
+#define KEY_TEEN		0x19e
+#define KEY_TWEN		0x19f
+#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
+#define KEY_GAMES		0x1a1	/* Media Select Games */
+#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
+#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
+#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
+#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
+#define KEY_EDITOR		0x1a6	/* AL Text Editor */
+#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
+#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
+#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
+#define KEY_DATABASE		0x1aa	/* AL Database App */
+#define KEY_NEWS		0x1ab	/* AL Newsreader */
+#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
+#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
+#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
+#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
+#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
+#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
+#define KEY_LOGOFF		0x1b1   /* AL Logoff */
+
+#define KEY_DOLLAR		0x1b2
+#define KEY_EURO		0x1b3
+
+#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define KEY_FRAMEFORWARD	0x1b5
+#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
+#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
+#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
+#define KEY_IMAGES		0x1ba	/* AL Image Browser */
+
+#define KEY_DEL_EOL		0x1c0
+#define KEY_DEL_EOS		0x1c1
+#define KEY_INS_LINE		0x1c2
+#define KEY_DEL_LINE		0x1c3
+
+#define KEY_FN			0x1d0
+#define KEY_FN_ESC		0x1d1
+#define KEY_FN_F1		0x1d2
+#define KEY_FN_F2		0x1d3
+#define KEY_FN_F3		0x1d4
+#define KEY_FN_F4		0x1d5
+#define KEY_FN_F5		0x1d6
+#define KEY_FN_F6		0x1d7
+#define KEY_FN_F7		0x1d8
+#define KEY_FN_F8		0x1d9
+#define KEY_FN_F9		0x1da
+#define KEY_FN_F10		0x1db
+#define KEY_FN_F11		0x1dc
+#define KEY_FN_F12		0x1dd
+#define KEY_FN_1		0x1de
+#define KEY_FN_2		0x1df
+#define KEY_FN_D		0x1e0
+#define KEY_FN_E		0x1e1
+#define KEY_FN_F		0x1e2
+#define KEY_FN_S		0x1e3
+#define KEY_FN_B		0x1e4
+
+#define KEY_BRL_DOT1		0x1f1
+#define KEY_BRL_DOT2		0x1f2
+#define KEY_BRL_DOT3		0x1f3
+#define KEY_BRL_DOT4		0x1f4
+#define KEY_BRL_DOT5		0x1f5
+#define KEY_BRL_DOT6		0x1f6
+#define KEY_BRL_DOT7		0x1f7
+#define KEY_BRL_DOT8		0x1f8
+#define KEY_BRL_DOT9		0x1f9
+#define KEY_BRL_DOT10		0x1fa
+
+#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
+#define KEY_NUMERIC_1		0x201	/* and other keypads */
+#define KEY_NUMERIC_2		0x202
+#define KEY_NUMERIC_3		0x203
+#define KEY_NUMERIC_4		0x204
+#define KEY_NUMERIC_5		0x205
+#define KEY_NUMERIC_6		0x206
+#define KEY_NUMERIC_7		0x207
+#define KEY_NUMERIC_8		0x208
+#define KEY_NUMERIC_9		0x209
+#define KEY_NUMERIC_STAR	0x20a
+#define KEY_NUMERIC_POUND	0x20b
+
+#define KEY_CAMERA_FOCUS	0x210
+#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
+
+#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
+#define KEY_TOUCHPAD_ON		0x213
+#define KEY_TOUCHPAD_OFF	0x214
+
+#define KEY_CAMERA_ZOOMIN	0x215
+#define KEY_CAMERA_ZOOMOUT	0x216
+#define KEY_CAMERA_UP		0x217
+#define KEY_CAMERA_DOWN		0x218
+#define KEY_CAMERA_LEFT		0x219
+#define KEY_CAMERA_RIGHT	0x21a
+
+#define KEY_ATTENDANT_ON	0x21b
+#define KEY_ATTENDANT_OFF	0x21c
+#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
+#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
+
+#define BTN_DPAD_UP		0x220
+#define BTN_DPAD_DOWN		0x221
+#define BTN_DPAD_LEFT		0x222
+#define BTN_DPAD_RIGHT		0x223
+
+#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
+
+#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
+#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
+#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
+#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
+#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
+#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
+#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
+
+#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
+#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
+
+#define BTN_TRIGGER_HAPPY		0x2c0
+#define BTN_TRIGGER_HAPPY1		0x2c0
+#define BTN_TRIGGER_HAPPY2		0x2c1
+#define BTN_TRIGGER_HAPPY3		0x2c2
+#define BTN_TRIGGER_HAPPY4		0x2c3
+#define BTN_TRIGGER_HAPPY5		0x2c4
+#define BTN_TRIGGER_HAPPY6		0x2c5
+#define BTN_TRIGGER_HAPPY7		0x2c6
+#define BTN_TRIGGER_HAPPY8		0x2c7
+#define BTN_TRIGGER_HAPPY9		0x2c8
+#define BTN_TRIGGER_HAPPY10		0x2c9
+#define BTN_TRIGGER_HAPPY11		0x2ca
+#define BTN_TRIGGER_HAPPY12		0x2cb
+#define BTN_TRIGGER_HAPPY13		0x2cc
+#define BTN_TRIGGER_HAPPY14		0x2cd
+#define BTN_TRIGGER_HAPPY15		0x2ce
+#define BTN_TRIGGER_HAPPY16		0x2cf
+#define BTN_TRIGGER_HAPPY17		0x2d0
+#define BTN_TRIGGER_HAPPY18		0x2d1
+#define BTN_TRIGGER_HAPPY19		0x2d2
+#define BTN_TRIGGER_HAPPY20		0x2d3
+#define BTN_TRIGGER_HAPPY21		0x2d4
+#define BTN_TRIGGER_HAPPY22		0x2d5
+#define BTN_TRIGGER_HAPPY23		0x2d6
+#define BTN_TRIGGER_HAPPY24		0x2d7
+#define BTN_TRIGGER_HAPPY25		0x2d8
+#define BTN_TRIGGER_HAPPY26		0x2d9
+#define BTN_TRIGGER_HAPPY27		0x2da
+#define BTN_TRIGGER_HAPPY28		0x2db
+#define BTN_TRIGGER_HAPPY29		0x2dc
+#define BTN_TRIGGER_HAPPY30		0x2dd
+#define BTN_TRIGGER_HAPPY31		0x2de
+#define BTN_TRIGGER_HAPPY32		0x2df
+#define BTN_TRIGGER_HAPPY33		0x2e0
+#define BTN_TRIGGER_HAPPY34		0x2e1
+#define BTN_TRIGGER_HAPPY35		0x2e2
+#define BTN_TRIGGER_HAPPY36		0x2e3
+#define BTN_TRIGGER_HAPPY37		0x2e4
+#define BTN_TRIGGER_HAPPY38		0x2e5
+#define BTN_TRIGGER_HAPPY39		0x2e6
+#define BTN_TRIGGER_HAPPY40		0x2e7
+
+/* We avoid low common keys in module aliases so they don't get huge. */
+#define KEY_MIN_INTERESTING	KEY_MUTE
+#define KEY_MAX			0x2ff
+#define KEY_CNT			(KEY_MAX+1)
+
+/*
+ * Relative axes
+ */
+
+#define REL_X			0x00
+#define REL_Y			0x01
+#define REL_Z			0x02
+#define REL_RX			0x03
+#define REL_RY			0x04
+#define REL_RZ			0x05
+#define REL_HWHEEL		0x06
+#define REL_DIAL		0x07
+#define REL_WHEEL		0x08
+#define REL_MISC		0x09
+#define REL_MAX			0x0f
+#define REL_CNT			(REL_MAX+1)
+
+/*
+ * Absolute axes
+ */
+
+#define ABS_X			0x00
+#define ABS_Y			0x01
+#define ABS_Z			0x02
+#define ABS_RX			0x03
+#define ABS_RY			0x04
+#define ABS_RZ			0x05
+#define ABS_THROTTLE		0x06
+#define ABS_RUDDER		0x07
+#define ABS_WHEEL		0x08
+#define ABS_GAS			0x09
+#define ABS_BRAKE		0x0a
+#define ABS_HAT0X		0x10
+#define ABS_HAT0Y		0x11
+#define ABS_HAT1X		0x12
+#define ABS_HAT1Y		0x13
+#define ABS_HAT2X		0x14
+#define ABS_HAT2Y		0x15
+#define ABS_HAT3X		0x16
+#define ABS_HAT3Y		0x17
+#define ABS_PRESSURE		0x18
+#define ABS_DISTANCE		0x19
+#define ABS_TILT_X		0x1a
+#define ABS_TILT_Y		0x1b
+#define ABS_TOOL_WIDTH		0x1c
+
+#define ABS_VOLUME		0x20
+
+#define ABS_MISC		0x28
+
+#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
+#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
+#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
+#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
+#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
+#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
+#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
+#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
+
+
+#define ABS_MAX			0x3f
+#define ABS_CNT			(ABS_MAX+1)
+
+/*
+ * Switch events
+ */
+
+#define SW_LID			0x00  /* set = lid shut */
+#define SW_TABLET_MODE		0x01  /* set = tablet mode */
+#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
+#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
+					 set = radio enabled */
+#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
+#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
+#define SW_DOCK			0x05  /* set = plugged into dock */
+#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
+#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
+#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
+#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
+#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
+#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
+#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
+#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
+#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
+#define SW_MAX			0x0f
+#define SW_CNT			(SW_MAX+1)
+
+/*
+ * Misc events
+ */
+
+#define MSC_SERIAL		0x00
+#define MSC_PULSELED		0x01
+#define MSC_GESTURE		0x02
+#define MSC_RAW			0x03
+#define MSC_SCAN		0x04
+#define MSC_TIMESTAMP		0x05
+#define MSC_MAX			0x07
+#define MSC_CNT			(MSC_MAX+1)
+
+/*
+ * LEDs
+ */
+
+#define LED_NUML		0x00
+#define LED_CAPSL		0x01
+#define LED_SCROLLL		0x02
+#define LED_COMPOSE		0x03
+#define LED_KANA		0x04
+#define LED_SLEEP		0x05
+#define LED_SUSPEND		0x06
+#define LED_MUTE		0x07
+#define LED_MISC		0x08
+#define LED_MAIL		0x09
+#define LED_CHARGING		0x0a
+#define LED_MAX			0x0f
+#define LED_CNT			(LED_MAX+1)
+
+/*
+ * Autorepeat values
+ */
+
+#define REP_DELAY		0x00
+#define REP_PERIOD		0x01
+#define REP_MAX			0x01
+#define REP_CNT			(REP_MAX+1)
+
+/*
+ * Sounds
+ */
+
+#define SND_CLICK		0x00
+#define SND_BELL		0x01
+#define SND_TONE		0x02
+#define SND_MAX			0x07
+#define SND_CNT			(SND_MAX+1)
+
+/*
+ * IDs.
+ */
+
+#define ID_BUS			0
+#define ID_VENDOR		1
+#define ID_PRODUCT		2
+#define ID_VERSION		3
+
+#define BUS_PCI			0x01
+#define BUS_ISAPNP		0x02
+#define BUS_USB			0x03
+#define BUS_HIL			0x04
+#define BUS_BLUETOOTH		0x05
+#define BUS_VIRTUAL		0x06
+
+#define BUS_ISA			0x10
+#define BUS_I8042		0x11
+#define BUS_XTKBD		0x12
+#define BUS_RS232		0x13
+#define BUS_GAMEPORT		0x14
+#define BUS_PARPORT		0x15
+#define BUS_AMIGA		0x16
+#define BUS_ADB			0x17
+#define BUS_I2C			0x18
+#define BUS_HOST		0x19
+#define BUS_GSC			0x1A
+#define BUS_ATARI		0x1B
+#define BUS_SPI			0x1C
+
+/*
+ * MT_TOOL types
+ */
+#define MT_TOOL_FINGER		0
+#define MT_TOOL_PEN		1
+#define MT_TOOL_MAX		1
+
+/*
+ * Values describing the status of a force-feedback effect
+ */
+#define FF_STATUS_STOPPED	0x00
+#define FF_STATUS_PLAYING	0x01
+#define FF_STATUS_MAX		0x01
diff --git a/include/dt-bindings/memory/rk3399-dram.h b/include/dt-bindings/memory/rk3399-dram.h
new file mode 100644
index 000000000..44abb0aaf
--- /dev/null
+++ b/include/dt-bindings/memory/rk3399-dram.h
@@ -0,0 +1,107 @@
+/* Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3399_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3399_H
+
+#define DDR3_DS_34ohm		(34)
+#define DDR3_DS_40ohm		(40)
+
+#define DDR3_ODT_DIS		(0)
+#define DDR3_ODT_40ohm		(40)
+#define DDR3_ODT_60ohm		(60)
+#define DDR3_ODT_120ohm		(120)
+
+#define LP2_DS_34ohm		(34)
+#define LP2_DS_40ohm		(40)
+#define LP2_DS_48ohm		(48)
+#define LP2_DS_60ohm		(60)
+#define LP2_DS_68_6ohm		(68)	/* optional */
+#define LP2_DS_80ohm		(80)
+#define LP2_DS_120ohm		(120)	/* optional */
+
+#define LP3_DS_34ohm		(34)
+#define LP3_DS_40ohm		(40)
+#define LP3_DS_48ohm		(48)
+#define LP3_DS_60ohm		(60)
+#define LP3_DS_80ohm		(80)
+#define LP3_DS_34D_40U		(3440)
+#define LP3_DS_40D_48U		(4048)
+#define LP3_DS_34D_48U		(3448)
+
+#define LP3_ODT_DIS		(0)
+#define LP3_ODT_60ohm		(60)
+#define LP3_ODT_120ohm		(120)
+#define LP3_ODT_240ohm		(240)
+
+#define LP4_PDDS_40ohm		(40)
+#define LP4_PDDS_48ohm		(48)
+#define LP4_PDDS_60ohm		(60)
+#define LP4_PDDS_80ohm		(80)
+#define LP4_PDDS_120ohm		(120)
+#define LP4_PDDS_240ohm		(240)
+
+#define LP4_DQ_ODT_40ohm	(40)
+#define LP4_DQ_ODT_48ohm	(48)
+#define LP4_DQ_ODT_60ohm	(60)
+#define LP4_DQ_ODT_80ohm	(80)
+#define LP4_DQ_ODT_120ohm	(120)
+#define LP4_DQ_ODT_240ohm	(240)
+#define LP4_DQ_ODT_DIS		(0)
+
+#define LP4_CA_ODT_40ohm	(40)
+#define LP4_CA_ODT_48ohm	(48)
+#define LP4_CA_ODT_60ohm	(60)
+#define LP4_CA_ODT_80ohm	(80)
+#define LP4_CA_ODT_120ohm	(120)
+#define LP4_CA_ODT_240ohm	(240)
+#define LP4_CA_ODT_DIS		(0)
+
+#define PHY_DRV_ODT_Hi_Z	(0)
+#define PHY_DRV_ODT_240		(240)
+#define PHY_DRV_ODT_120		(120)
+#define PHY_DRV_ODT_80		(80)
+#define PHY_DRV_ODT_60		(60)
+#define PHY_DRV_ODT_48		(48)
+#define PHY_DRV_ODT_40		(40)
+#define PHY_DRV_ODT_34_3	(34)
+
+#endif /* _DT_BINDINGS_DRAM_ROCKCHIP_RK3399_H */
diff --git a/include/dt-bindings/memory/rockchip-dram.h b/include/dt-bindings/memory/rockchip-dram.h
new file mode 100644
index 000000000..17e5e34b0
--- /dev/null
+++ b/include/dt-bindings/memory/rockchip-dram.h
@@ -0,0 +1,94 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2020 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_H
+
+#define DDR2_DS_FULL			(0x0)
+#define DDR2_DS_REDUCE			(0x1 << 1)
+#define DDR2_DS_MASK			(0x1 << 1)
+
+#define DDR2_ODT_DIS			(0x0)
+#define DDR2_ODT_75ohm			(0x1 << 2)
+#define DDR2_ODT_150ohm			(0x1 << 6)
+#define DDR2_ODT_50ohm			((0x1 << 6) | (0x1 << 2)) /* optional */
+#define DDR2_ODT_MASK			((0x1 << 2) | (0x1 << 6))
+
+#define DDR3_DS_40ohm			(0x0)
+#define DDR3_DS_34ohm			(0x1 << 1)
+#define DDR3_DS_MASK			((1 << 1) | (1 << 5))
+
+#define DDR3_ODT_DIS			(0x0)
+#define DDR3_ODT_60ohm			(0x1 << 2)
+#define DDR3_ODT_120ohm			(0x1 << 6)
+#define DDR3_ODT_40ohm			((0x1 << 6) | (0x1 << 2))
+#define DDR3_ODT_MASK			((0x1 << 2) | (0x1 << 6) | (0x1 << 9))
+
+#define DDR4_DS_34ohm			(0x0)
+#define DDR4_DS_48ohm			(0x1 << 1)
+#define DDR4_DS_MASK			(0x3 << 1)
+
+#define DDR4_ODT_DIS			(0x0)
+#define DDR4_ODT_60ohm			(0x1 << 8)
+#define DDR4_ODT_120ohm			(0x2 << 8)
+#define DDR4_ODT_40ohm			(0x3 << 8)
+#define DDR4_ODT_240ohm			(0x4 << 8)
+#define DDR4_ODT_48ohm			(0x5 << 8)
+#define DDR4_ODT_80ohm			(0x6 << 8)
+#define DDR4_ODT_34ohm			(0x7 << 8)
+#define DDR4_ODT_MASK			(0x7 << 8)
+
+#define LP2_DS_34ohm			(0x1)
+#define LP2_DS_40ohm			(0x2)
+#define LP2_DS_48ohm			(0x3)
+#define LP2_DS_60ohm			(0x4)
+#define LP2_DS_68_6ohm			(0x5)	/* optional */
+#define LP2_DS_80ohm			(0x6)
+#define LP2_DS_120ohm			(0x7)	/* optional */
+#define LP2_DS_MASK			(0xf)
+
+#define LP3_DS_34ohm			(0x1)
+#define LP3_DS_40ohm			(0x2)
+#define LP3_DS_48ohm			(0x3)
+#define LP3_DS_60ohm			(0x4)
+#define LP3_DS_80ohm			(0x6)
+#define LP3_DS_34D_40U			(0x9)
+#define LP3_DS_40D_48U			(0xa)
+#define LP3_DS_34D_48U			(0xb)
+#define LP3_DS_MASK			(0xf)
+
+#define LP3_ODT_DIS			(0)
+#define LP3_ODT_60ohm			(0x1)
+#define LP3_ODT_120ohm			(0x2)
+#define LP3_ODT_240ohm			(0x3)
+#define LP3_ODT_MASK			(0x3)
+
+#define LP4_PDDS_240ohm			(0x1 << 3)
+#define LP4_PDDS_120ohm			(0x2 << 3)
+#define LP4_PDDS_80ohm			(0x3 << 3)
+#define LP4_PDDS_60ohm			(0x4 << 3)
+#define LP4_PDDS_48ohm			(0x5 << 3)
+#define LP4_PDDS_40ohm			(0x6 << 3)
+#define LP4_PDDS_MASK			(0x7 << 3)
+
+#define LP4_DQ_ODT_DIS			(0x0)
+#define LP4_DQ_ODT_240ohm		(0x1)
+#define LP4_DQ_ODT_120ohm		(0x2)
+#define LP4_DQ_ODT_80ohm		(0x3)
+#define LP4_DQ_ODT_60ohm		(0x4)
+#define LP4_DQ_ODT_48ohm		(0x5)
+#define LP4_DQ_ODT_40ohm		(0x6)
+#define LP4_DQ_ODT_MASK			(0x7)
+
+#define LP4_CA_ODT_DIS			(0x0)
+#define LP4_CA_ODT_240ohm		(0x1 << 4)
+#define LP4_CA_ODT_120ohm		(0x2 << 4)
+#define LP4_CA_ODT_80ohm		(0x3 << 4)
+#define LP4_CA_ODT_60ohm		(0x4 << 4)
+#define LP4_CA_ODT_48ohm		(0x5 << 4)
+#define LP4_CA_ODT_40ohm		(0x6 << 4)
+#define LP4_CA_ODT_MASK			(0x7 << 4)
+
+#endif /* _DT_BINDINGS_DRAM_ROCKCHIP_H */
diff --git a/include/dt-bindings/phy/phy-snps-pcie3.h b/include/dt-bindings/phy/phy-snps-pcie3.h
new file mode 100644
index 000000000..5006947f2
--- /dev/null
+++ b/include/dt-bindings/phy/phy-snps-pcie3.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _DT_BINDINGS_PHY_SNPS_PCIE3
+#define _DT_BINDINGS_PHY_SNPS_PCIE3
+
+/*
+ * pcie30_phy_mode[2:0]
+ * bit2: aggregation
+ * bit1: bifurcation for port 1
+ * bit0: bifurcation for port 0
+ */
+#define PHY_MODE_PCIE_AGGREGATION 4	/* PCIe3x4 */
+#define PHY_MODE_PCIE_NANBNB	0	/* P1:PCIe3x2  +  P0:PCIe3x2 */
+#define PHY_MODE_PCIE_NANBBI	1	/* P1:PCIe3x2  +  P0:PCIe3x1*2 */
+#define PHY_MODE_PCIE_NABINB	2	/* P1:PCIe3x1*2 + P0:PCIe3x2 */
+#define PHY_MODE_PCIE_NABIBI	3	/* P1:PCIe3x1*2 + P0:PCIe3x1*2 */
+
+#endif /* _DT_BINDINGS_PHY_SNPS_PCIE3 */
diff --git a/include/dt-bindings/sensor-dev.h b/include/dt-bindings/sensor-dev.h
new file mode 100644
index 000000000..1c4fb82b1
--- /dev/null
+++ b/include/dt-bindings/sensor-dev.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __DT_BINDINGS_ROCKCHIP_SENSORDEV_H__
+#define __DT_BINDINGS_ROCKCHIP_SENSORDEV_H__
+
+#define	SENSOR_TYPE_NULL  0
+#define	SENSOR_TYPE_ANGLE 1
+#define	SENSOR_TYPE_ACCEL 2
+#define	SENSOR_TYPE_COMPASS 3
+#define	SENSOR_TYPE_GYROSCOPE 4
+#define	SENSOR_TYPE_LIGHT 5
+#define	SENSOR_TYPE_PROXIMITY 6
+#define	SENSOR_TYPE_TEMPERATURE 7
+#define	SENSOR_TYPE_PRESSURE 8
+#define	SENSOR_TYPE_HALL 9
+#define	SENSOR_NUM_TYPES 10
+
+#endif
diff --git a/include/dt-bindings/soc/rockchip,boot-mode.h b/include/dt-bindings/soc/rockchip,boot-mode.h
index 4b0914c09..1436e1d32 100644
--- a/include/dt-bindings/soc/rockchip,boot-mode.h
+++ b/include/dt-bindings/soc/rockchip,boot-mode.h
@@ -10,7 +10,15 @@
 #define BOOT_BL_DOWNLOAD	(REBOOT_FLAG + 1)
 /* enter recovery */
 #define BOOT_RECOVERY		(REBOOT_FLAG + 3)
- /* enter fastboot mode */
+/* reboot by panic */
+#define BOOT_PANIC		(REBOOT_FLAG + 7)
+/* reboot by watchdog */
+#define BOOT_WATCHDOG		(REBOOT_FLAG + 8)
+/* enter fastboot mode */
 #define BOOT_FASTBOOT		(REBOOT_FLAG + 9)
+/* enter charging mode */
+#define BOOT_CHARGING		(REBOOT_FLAG + 11)
+/* enter usb mass storage mode */
+#define BOOT_UMS		(REBOOT_FLAG + 12)
 
 #endif
diff --git a/include/dt-bindings/soc/rockchip-system-status.h b/include/dt-bindings/soc/rockchip-system-status.h
new file mode 100644
index 000000000..837a1a969
--- /dev/null
+++ b/include/dt-bindings/soc/rockchip-system-status.h
@@ -0,0 +1,48 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+#define _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+
+#define SYS_STATUS_NORMAL	(1 << 0)
+#define SYS_STATUS_SUSPEND	(1 << 1)
+#define SYS_STATUS_IDLE		(1 << 2)
+#define SYS_STATUS_REBOOT	(1 << 3)
+#define SYS_STATUS_VIDEO_4K	(1 << 4)
+#define SYS_STATUS_VIDEO_1080P	(1 << 5)
+#define SYS_STATUS_GPU		(1 << 6)
+#define SYS_STATUS_RGA		(1 << 7)
+#define SYS_STATUS_CIF0		(1 << 8)
+#define SYS_STATUS_CIF1		(1 << 9)
+#define SYS_STATUS_LCDC0	(1 << 10)
+#define SYS_STATUS_LCDC1	(1 << 11)
+#define SYS_STATUS_BOOST	(1 << 12)
+#define SYS_STATUS_PERFORMANCE	(1 << 13)
+#define SYS_STATUS_ISP		(1 << 14)
+#define SYS_STATUS_HDMI		(1 << 15)
+#define SYS_STATUS_VIDEO_4K_10B	(1 << 16)
+#define SYS_STATUS_LOW_POWER	(1 << 17)
+
+#define SYS_STATUS_VIDEO	(SYS_STATUS_VIDEO_4K | \
+				 SYS_STATUS_VIDEO_1080P | \
+				 SYS_STATUS_VIDEO_4K_10B)
+#define SYS_STATUS_DUALVIEW	(SYS_STATUS_LCDC0 | SYS_STATUS_LCDC1)
+
+#define DMC_FREQ_LEVEL_LOW	(0x1 << 0)
+#define DMC_FREQ_LEVEL_MID_LOW	(0x1 << 1)
+#define DMC_FREQ_LEVEL_MID_HIGH	(0x1 << 2)
+#define DMC_FREQ_LEVEL_HIGH	(0x1 << 3)
+
+#endif
diff --git a/include/dt-bindings/suspend/rockchip-rk3399.h b/include/dt-bindings/suspend/rockchip-rk3399.h
new file mode 100644
index 000000000..176c7cfcd
--- /dev/null
+++ b/include/dt-bindings/suspend/rockchip-rk3399.h
@@ -0,0 +1,61 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Tony.Xie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3399_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3399_H__
+
+/* the suspend mode */
+#define RKPM_SLP_WFI				(1 << 0)
+#define RKPM_SLP_ARMPD				(1 << 1)
+#define RKPM_SLP_PERILPPD			(1 << 2)
+#define RKPM_SLP_DDR_RET			(1 << 3)
+#define RKPM_SLP_PLLPD				(1 << 4)
+#define RKPM_SLP_OSC_DIS			(1 << 5)
+#define RKPM_SLP_CENTER_PD			(1 << 6)
+#define RKPM_SLP_AP_PWROFF			(1 << 7)
+
+/* the wake up source */
+#define RKPM_CLUSTER_L_WKUP_EN			(1 << 0)
+#define RKPM_CLUSTER_B_WKUPB_EN			(1 << 1)
+#define RKPM_GPIO_WKUP_EN			(1 << 2)
+#define RKPM_SDIO_WKUP_EN			(1 << 3)
+#define RKPM_SDMMC_WKUP_EN			(1 << 4)
+#define RKPM_TIMER_WKUP_EN			(1 << 6)
+#define RKPM_USB_WKUP_EN			(1 << 7)
+#define RKPM_SFT_WKUP_EN			(1 << 8)
+#define RKPM_WDT_M0_WKUP_EN			(1 << 9)
+#define RKPM_TIME_OUT_WKUP_EN			(1 << 10)
+#define RKPM_PWM_WKUP_EN			(1 << 11)
+#define RKPM_PCIE_WKUP_EN			(1 << 13)
+#define RKPM_USB_LINESTATE_WKUP_EN		(1 << 14)
+
+/* the pwm regulator */
+#define PWM0_REGULATOR_EN			(1 << 0)
+#define PWM1_REGULATOR_EN			(1 << 1)
+#define PWM2_REGULATOR_EN			(1 << 2)
+#define PWM3A_REGULATOR_EN			(1 << 3)
+#define PWM3B_REGULATOR_EN			(1 << 4)
+
+/* the APIO voltage domain */
+#define RKPM_APIO0_SUSPEND			(1 << 0)
+#define RKPM_APIO1_SUSPEND			(1 << 1)
+#define RKPM_APIO2_SUSPEND			(1 << 2)
+#define RKPM_APIO3_SUSPEND			(1 << 3)
+#define RKPM_APIO4_SUSPEND			(1 << 4)
+#define RKPM_APIO5_SUSPEND			(1 << 5)
+
+#endif
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index d9b69bbde..ebfb4e7c1 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -46,6 +46,7 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
+	struct super_block	*bd_fsfreeze_sb;
 } __randomize_layout;
 
 /*
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 3a383a485..f83f5fa0a 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -173,7 +173,7 @@ struct bpf_map {
 	atomic64_t usercnt;
 	struct work_struct work;
 	struct mutex freeze_mutex;
-	atomic64_t writecnt;
+	u64 writecnt; /* writable mmap cnt; protected by freeze_mutex */
 };
 
 static inline bool map_value_has_spin_lock(const struct bpf_map *map)
@@ -1332,7 +1332,6 @@ void bpf_map_charge_move(struct bpf_map_memory *dst,
 void *bpf_map_area_alloc(u64 size, int numa_node);
 void *bpf_map_area_mmapable_alloc(u64 size, int numa_node);
 void bpf_map_area_free(void *base);
-bool bpf_map_write_active(const struct bpf_map *map);
 void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr);
 int  generic_map_lookup_batch(struct bpf_map *map,
 			      const union bpf_attr *attr,
diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h
index 97ce0a123..8c1930336 100644
--- a/include/linux/cgroup-defs.h
+++ b/include/linux/cgroup-defs.h
@@ -110,6 +110,7 @@ enum {
 	CFTYPE_NO_PREFIX	= (1 << 3),	/* (DON'T USE FOR NEW FILES) no subsys prefix */
 	CFTYPE_WORLD_WRITABLE	= (1 << 4),	/* (DON'T USE FOR NEW FILES) S_IWUGO */
 	CFTYPE_DEBUG		= (1 << 5),	/* create when cgroup_debug */
+	CFTYPE_PRESSURE		= (1 << 6),	/* only if pressure feature is enabled */
 
 	/* internal flags, do not use outside cgroup core proper */
 	__CFTYPE_ONLY_ON_DFL	= (1 << 16),	/* only on default hierarchy */
@@ -509,9 +510,6 @@ struct cgroup_root {
 	/* Number of cgroups in the hierarchy, used only for /proc/cgroups */
 	atomic_t nr_cgrps;
 
-	/* Wait while cgroups are being destroyed */
-	wait_queue_head_t wait;
-
 	/* A list running through the active hierarchies */
 	struct list_head root_list;
 
@@ -766,54 +764,107 @@ static inline void cgroup_threadgroup_change_end(struct task_struct *tsk) {}
  * sock_cgroup_data is embedded at sock->sk_cgrp_data and contains
  * per-socket cgroup information except for memcg association.
  *
- * On legacy hierarchies, net_prio and net_cls controllers directly
- * set attributes on each sock which can then be tested by the network
- * layer. On the default hierarchy, each sock is associated with the
- * cgroup it was created in and the networking layer can match the
- * cgroup directly.
+ * On legacy hierarchies, net_prio and net_cls controllers directly set
+ * attributes on each sock which can then be tested by the network layer.
+ * On the default hierarchy, each sock is associated with the cgroup it was
+ * created in and the networking layer can match the cgroup directly.
+ *
+ * To avoid carrying all three cgroup related fields separately in sock,
+ * sock_cgroup_data overloads (prioidx, classid) and the cgroup pointer.
+ * On boot, sock_cgroup_data records the cgroup that the sock was created
+ * in so that cgroup2 matches can be made; however, once either net_prio or
+ * net_cls starts being used, the area is overriden to carry prioidx and/or
+ * classid.  The two modes are distinguished by whether the lowest bit is
+ * set.  Clear bit indicates cgroup pointer while set bit prioidx and
+ * classid.
+ *
+ * While userland may start using net_prio or net_cls at any time, once
+ * either is used, cgroup2 matching no longer works.  There is no reason to
+ * mix the two and this is in line with how legacy and v2 compatibility is
+ * handled.  On mode switch, cgroup references which are already being
+ * pointed to by socks may be leaked.  While this can be remedied by adding
+ * synchronization around sock_cgroup_data, given that the number of leaked
+ * cgroups is bound and highly unlikely to be high, this seems to be the
+ * better trade-off.
  */
 struct sock_cgroup_data {
-	struct cgroup	*cgroup; /* v2 */
-#ifdef CONFIG_CGROUP_NET_CLASSID
-	u32		classid; /* v1 */
-#endif
-#ifdef CONFIG_CGROUP_NET_PRIO
-	u16		prioidx; /* v1 */
+	union {
+#ifdef __LITTLE_ENDIAN
+		struct {
+			u8	is_data : 1;
+			u8	no_refcnt : 1;
+			u8	unused : 6;
+			u8	padding;
+			u16	prioidx;
+			u32	classid;
+		} __packed;
+#else
+		struct {
+			u32	classid;
+			u16	prioidx;
+			u8	padding;
+			u8	unused : 6;
+			u8	no_refcnt : 1;
+			u8	is_data : 1;
+		} __packed;
 #endif
+		u64		val;
+	};
 };
 
+/*
+ * There's a theoretical window where the following accessors race with
+ * updaters and return part of the previous pointer as the prioidx or
+ * classid.  Such races are short-lived and the result isn't critical.
+ */
 static inline u16 sock_cgroup_prioidx(const struct sock_cgroup_data *skcd)
 {
-#ifdef CONFIG_CGROUP_NET_PRIO
-	return READ_ONCE(skcd->prioidx);
-#else
-	return 1;
-#endif
+	/* fallback to 1 which is always the ID of the root cgroup */
+	return (skcd->is_data & 1) ? skcd->prioidx : 1;
 }
 
 static inline u32 sock_cgroup_classid(const struct sock_cgroup_data *skcd)
 {
-#ifdef CONFIG_CGROUP_NET_CLASSID
-	return READ_ONCE(skcd->classid);
-#else
-	return 0;
-#endif
+	/* fallback to 0 which is the unconfigured default classid */
+	return (skcd->is_data & 1) ? skcd->classid : 0;
 }
 
+/*
+ * If invoked concurrently, the updaters may clobber each other.  The
+ * caller is responsible for synchronization.
+ */
 static inline void sock_cgroup_set_prioidx(struct sock_cgroup_data *skcd,
 					   u16 prioidx)
 {
-#ifdef CONFIG_CGROUP_NET_PRIO
-	WRITE_ONCE(skcd->prioidx, prioidx);
-#endif
+	struct sock_cgroup_data skcd_buf = {{ .val = READ_ONCE(skcd->val) }};
+
+	if (sock_cgroup_prioidx(&skcd_buf) == prioidx)
+		return;
+
+	if (!(skcd_buf.is_data & 1)) {
+		skcd_buf.val = 0;
+		skcd_buf.is_data = 1;
+	}
+
+	skcd_buf.prioidx = prioidx;
+	WRITE_ONCE(skcd->val, skcd_buf.val);	/* see sock_cgroup_ptr() */
 }
 
 static inline void sock_cgroup_set_classid(struct sock_cgroup_data *skcd,
 					   u32 classid)
 {
-#ifdef CONFIG_CGROUP_NET_CLASSID
-	WRITE_ONCE(skcd->classid, classid);
-#endif
+	struct sock_cgroup_data skcd_buf = {{ .val = READ_ONCE(skcd->val) }};
+
+	if (sock_cgroup_classid(&skcd_buf) == classid)
+		return;
+
+	if (!(skcd_buf.is_data & 1)) {
+		skcd_buf.val = 0;
+		skcd_buf.is_data = 1;
+	}
+
+	skcd_buf.classid = classid;
+	WRITE_ONCE(skcd->val, skcd_buf.val);	/* see sock_cgroup_ptr() */
 }
 
 #else	/* CONFIG_SOCK_CGROUP_DATA */
diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index 9c88b7da3..14b808b02 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -676,6 +676,8 @@ static inline struct psi_group *cgroup_psi(struct cgroup *cgrp)
 	return &cgrp->psi;
 }
 
+bool cgroup_psi_enabled(void);
+
 static inline void cgroup_init_kthreadd(void)
 {
 	/*
@@ -735,6 +737,11 @@ static inline struct psi_group *cgroup_psi(struct cgroup *cgrp)
 	return NULL;
 }
 
+static inline bool cgroup_psi_enabled(void)
+{
+	return false;
+}
+
 static inline bool task_under_cgroup_hierarchy(struct task_struct *task,
 					       struct cgroup *ancestor)
 {
@@ -816,13 +823,33 @@ static inline void cgroup_account_cputime_field(struct task_struct *task,
  */
 #ifdef CONFIG_SOCK_CGROUP_DATA
 
+#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)
+extern spinlock_t cgroup_sk_update_lock;
+#endif
+
+void cgroup_sk_alloc_disable(void);
 void cgroup_sk_alloc(struct sock_cgroup_data *skcd);
 void cgroup_sk_clone(struct sock_cgroup_data *skcd);
 void cgroup_sk_free(struct sock_cgroup_data *skcd);
 
 static inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)
 {
-	return skcd->cgroup;
+#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)
+	unsigned long v;
+
+	/*
+	 * @skcd->val is 64bit but the following is safe on 32bit too as we
+	 * just need the lower ulong to be written and read atomically.
+	 */
+	v = READ_ONCE(skcd->val);
+
+	if (v & 3)
+		return &cgrp_dfl_root.cgrp;
+
+	return (struct cgroup *)(unsigned long)v ?: &cgrp_dfl_root.cgrp;
+#else
+	return (struct cgroup *)(unsigned long)skcd->val;
+#endif
 }
 
 #else	/* CONFIG_CGROUP_DATA */
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 03a5de5f9..d9897d0b1 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -599,6 +599,7 @@ struct clk_divider {
 	u8		shift;
 	u8		width;
 	u8		flags;
+	unsigned long	max_prate;
 	const struct clk_div_table	*table;
 	spinlock_t	*lock;
 };
@@ -936,6 +937,8 @@ void clk_hw_unregister_fixed_factor(struct clk_hw *hw);
  * CLK_FRAC_DIVIDER_BIG_ENDIAN - By default little endian register accesses are
  *	used for the divider register.  Setting this flag makes the register
  *	accesses big endian.
+ * CLK_FRAC_DIVIDER_NO_LIMIT - not need to follow the 20 times limit on
+ *	fractional divider
  */
 struct clk_fractional_divider {
 	struct clk_hw	hw;
@@ -947,6 +950,7 @@ struct clk_fractional_divider {
 	u8		nwidth;
 	u32		nmask;
 	u8		flags;
+	unsigned long	max_prate;
 	void		(*approximation)(struct clk_hw *hw,
 				unsigned long rate, unsigned long *parent_rate,
 				unsigned long *m, unsigned long *n);
@@ -957,6 +961,7 @@ struct clk_fractional_divider {
 
 #define CLK_FRAC_DIVIDER_ZERO_BASED		BIT(0)
 #define CLK_FRAC_DIVIDER_BIG_ENDIAN		BIT(1)
+#define CLK_FRAC_DIVIDER_NO_LIMIT		BIT(2)
 
 extern const struct clk_ops clk_fractional_divider_ops;
 struct clk *clk_register_fractional_divider(struct device *dev,
@@ -1017,6 +1022,9 @@ extern const struct clk_ops clk_multiplier_ops;
  * @mux_hw:	handle between composite and hardware-specific mux clock
  * @rate_hw:	handle between composite and hardware-specific rate clock
  * @gate_hw:	handle between composite and hardware-specific gate clock
+ * @brother_hw: a member of clk_composite who has the common parent clocks
+ *              with another clk_composite, and it's also a handle between
+ *              common and hardware-specific interfaces
  * @mux_ops:	clock ops for mux
  * @rate_ops:	clock ops for rate
  * @gate_ops:	clock ops for gate
@@ -1028,6 +1036,7 @@ struct clk_composite {
 	struct clk_hw	*mux_hw;
 	struct clk_hw	*rate_hw;
 	struct clk_hw	*gate_hw;
+	struct clk_hw	*brother_hw;
 
 	const struct clk_ops	*mux_ops;
 	const struct clk_ops	*rate_ops;
diff --git a/include/linux/clk/rockchip.h b/include/linux/clk/rockchip.h
new file mode 100644
index 000000000..07c563a42
--- /dev/null
+++ b/include/linux/clk/rockchip.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ */
+
+#ifndef __LINUX_CLK_ROCKCHIP_H_
+#define __LINUX_CLK_ROCKCHIP_H_
+
+#ifdef CONFIG_ROCKCHIP_CLK_COMPENSATION
+int rockchip_pll_clk_compensation(struct clk *clk, int ppm);
+#else
+static inline int rockchip_pll_clk_compensation(struct clk *clk, int ppm)
+{
+	return -ENOSYS;
+}
+#endif
+
+#endif /* __LINUX_CLK_ROCKCHIP_H_ */
diff --git a/include/linux/cpufreq_times.h b/include/linux/cpufreq_times.h
new file mode 100644
index 000000000..38272a5f3
--- /dev/null
+++ b/include/linux/cpufreq_times.h
@@ -0,0 +1,42 @@
+/* drivers/cpufreq/cpufreq_times.c
+ *
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_CPUFREQ_TIMES_H
+#define _LINUX_CPUFREQ_TIMES_H
+
+#include <linux/cpufreq.h>
+#include <linux/pid.h>
+
+#ifdef CONFIG_CPU_FREQ_TIMES
+void cpufreq_task_times_init(struct task_struct *p);
+void cpufreq_task_times_alloc(struct task_struct *p);
+void cpufreq_task_times_exit(struct task_struct *p);
+int proc_time_in_state_show(struct seq_file *m, struct pid_namespace *ns,
+			    struct pid *pid, struct task_struct *p);
+void cpufreq_acct_update_power(struct task_struct *p, u64 cputime);
+void cpufreq_times_create_policy(struct cpufreq_policy *policy);
+void cpufreq_times_record_transition(struct cpufreq_policy *policy,
+                                     unsigned int new_freq);
+#else
+static inline void cpufreq_task_times_init(struct task_struct *p) {}
+static inline void cpufreq_task_times_alloc(struct task_struct *p) {}
+static inline void cpufreq_task_times_exit(struct task_struct *p) {}
+static inline void cpufreq_acct_update_power(struct task_struct *p,
+					     u64 cputime) {}
+static inline void cpufreq_times_create_policy(struct cpufreq_policy *policy) {}
+static inline void cpufreq_times_record_transition(
+	struct cpufreq_policy *policy, unsigned int new_freq) {}
+#endif /* CONFIG_CPU_FREQ_TIMES */
+#endif /* _LINUX_CPUFREQ_TIMES_H */
diff --git a/include/linux/cpuset.h b/include/linux/cpuset.h
index 04c20de66..047f449d3 100644
--- a/include/linux/cpuset.h
+++ b/include/linux/cpuset.h
@@ -15,6 +15,7 @@
 #include <linux/cpumask.h>
 #include <linux/nodemask.h>
 #include <linux/mm.h>
+#include <linux/mmu_context.h>
 #include <linux/jump_label.h>
 
 #ifdef CONFIG_CPUSETS
@@ -162,6 +163,8 @@ static inline void set_mems_allowed(nodemask_t nodemask)
 	task_unlock(current);
 }
 
+extern void cpuset_hotplug_workfn(struct work_struct *work);
+
 #else /* !CONFIG_CPUSETS */
 
 static inline bool cpusets_enabled(void) { return false; }
@@ -184,7 +187,7 @@ static inline void cpuset_read_unlock(void) { }
 static inline void cpuset_cpus_allowed(struct task_struct *p,
 				       struct cpumask *mask)
 {
-	cpumask_copy(mask, cpu_possible_mask);
+	cpumask_copy(mask, task_cpu_possible_mask(p));
 }
 
 static inline void cpuset_cpus_allowed_fallback(struct task_struct *p)
@@ -280,6 +283,8 @@ static inline bool read_mems_allowed_retry(unsigned int seq)
 	return false;
 }
 
+static inline void cpuset_hotplug_workfn(struct work_struct *work) {}
+
 #endif /* !CONFIG_CPUSETS */
 
 #endif /* _LINUX_CPUSET_H */
diff --git a/include/linux/dma-buf-cache.h b/include/linux/dma-buf-cache.h
new file mode 100644
index 000000000..d97545560
--- /dev/null
+++ b/include/linux/dma-buf-cache.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co. Ltd.
+ */
+#ifndef _LINUX_DMA_BUF_CACHE_H
+#define _LINUX_DMA_BUF_CACHE_H
+
+#include <linux/dma-buf.h>
+
+extern void dma_buf_cache_detach(struct dma_buf *dmabuf,
+				 struct dma_buf_attachment *attach);
+
+extern void dma_buf_cache_unmap_attachment(struct dma_buf_attachment *attach,
+					   struct sg_table *sg_table,
+					   enum dma_data_direction direction);
+
+extern struct dma_buf_attachment *
+dma_buf_cache_attach(struct dma_buf *dmabuf, struct device *dev);
+
+extern struct sg_table *
+dma_buf_cache_map_attachment(struct dma_buf_attachment *attach,
+			     enum dma_data_direction direction);
+
+#ifdef CONFIG_DMABUF_CACHE
+/* Replace dma-buf apis to cached apis */
+#define dma_buf_attach dma_buf_cache_attach
+#define dma_buf_detach dma_buf_cache_detach
+#define dma_buf_map_attachment dma_buf_cache_map_attachment
+#define dma_buf_unmap_attachment dma_buf_cache_unmap_attachment
+#endif
+
+#endif /* _LINUX_DMA_BUF_CACHE_H */
diff --git a/include/linux/dma-buf.h b/include/linux/dma-buf.h
index 0c5706abb..fc3c3f21f 100644
--- a/include/linux/dma-buf.h
+++ b/include/linux/dma-buf.h
@@ -209,6 +209,41 @@ struct dma_buf_ops {
 	 */
 	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
 
+	/**
+	 * @begin_cpu_access_partial:
+	 *
+	 * This is called from dma_buf_begin_cpu_access_partial() and allows the
+	 * exporter to ensure that the memory specified in the range is
+	 * available for cpu access - the exporter might need to allocate or
+	 * swap-in and pin the backing storage.
+	 * The exporter also needs to ensure that cpu access is
+	 * coherent for the access direction. The direction can be used by the
+	 * exporter to optimize the cache flushing, i.e. access with a different
+	 * direction (read instead of write) might return stale or even bogus
+	 * data (e.g. when the exporter needs to copy the data to temporary
+	 * storage).
+	 *
+	 * This callback is optional.
+	 *
+	 * FIXME: This is both called through the DMA_BUF_IOCTL_SYNC command
+	 * from userspace (where storage shouldn't be pinned to avoid handing
+	 * de-factor mlock rights to userspace) and for the kernel-internal
+	 * users of the various kmap interfaces, where the backing storage must
+	 * be pinned to guarantee that the atomic kmap calls can succeed. Since
+	 * there's no in-kernel users of the kmap interfaces yet this isn't a
+	 * real problem.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. This can for
+	 * example fail when the backing storage can't be allocated. Can also
+	 * return -ERESTARTSYS or -EINTR when the call has been interrupted and
+	 * needs to be restarted.
+	 */
+	int (*begin_cpu_access_partial)(struct dma_buf *dmabuf,
+					enum dma_data_direction,
+					unsigned int offset, unsigned int len);
+
 	/**
 	 * @end_cpu_access:
 	 *
@@ -228,6 +263,28 @@ struct dma_buf_ops {
 	 */
 	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
 
+	/**
+	 * @end_cpu_access_partial:
+	 *
+	 * This is called from dma_buf_end_cpu_access_partial() when the
+	 * importer is done accessing the CPU. The exporter can use to limit
+	 * cache flushing to only the range specefied and to unpin any
+	 * resources pinned in @begin_cpu_access_umapped.
+	 * The result of any dma_buf kmap calls after end_cpu_access_partial is
+	 * undefined.
+	 *
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. Can return
+	 * -ERESTARTSYS or -EINTR when the call has been interrupted and needs
+	 * to be restarted.
+	 */
+	int (*end_cpu_access_partial)(struct dma_buf *dmabuf,
+				      enum dma_data_direction,
+				      unsigned int offset, unsigned int len);
+
 	/**
 	 * @mmap:
 	 *
@@ -267,6 +324,35 @@ struct dma_buf_ops {
 
 	void *(*vmap)(struct dma_buf *);
 	void (*vunmap)(struct dma_buf *, void *vaddr);
+
+	/**
+	 * @get_uuid
+	 *
+	 * This is called by dma_buf_get_uuid to get the UUID which identifies
+	 * the buffer to virtio devices.
+	 *
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. On success uuid
+	 * will be populated with the buffer's UUID.
+	 */
+	int (*get_uuid)(struct dma_buf *dmabuf, uuid_t *uuid);
+
+	/**
+	 * @get_flags:
+	 *
+	 * This is called by dma_buf_get_flags and is used to get the buffer's
+	 * flags.
+	 * This callback is optional.
+	 *
+	 * Returns:
+	 *
+	 * 0 on success or a negative error code on failure. On success flags
+	 * will be populated with the buffer's flags.
+	 */
+	int (*get_flags)(struct dma_buf *dmabuf, unsigned long *flags);
 };
 
 /**
@@ -297,6 +383,9 @@ struct dma_buf_ops {
  * @sysfs_entry: for exposing information about this buffer in sysfs.
  * The attachment_uid member of @sysfs_entry is protected by dma_resv lock
  * and is incremented on each attach.
+ * @mmap_count: number of times buffer has been mmapped.
+ * @exp_vm_ops: the vm ops provided by the buffer exporter.
+ * @vm_ops: the overridden vm_ops used to track mmap_count of the buffer.
  *
  * This represents a shared buffer, created by calling dma_buf_export(). The
  * userspace representation is a normal file descriptor, which can be created by
@@ -341,7 +430,12 @@ struct dma_buf {
 	struct dma_buf_sysfs_entry {
 		struct kobject kobj;
 		struct dma_buf *dmabuf;
+		unsigned int attachment_uid;
+		struct kset *attach_stats_kset;
 	} *sysfs_entry;
+	int mmap_count;
+	const struct vm_operations_struct *exp_vm_ops;
+	struct vm_operations_struct vm_ops;
 #endif
 };
 
@@ -392,6 +486,9 @@ struct dma_buf_attach_ops {
  * @importer_ops: importer operations for this attachment, if provided
  * dma_buf_map/unmap_attachment() must be called with the dma_resv lock held.
  * @importer_priv: importer specific attachment data.
+ * @dma_map_attrs: DMA attributes to be used when the exporter maps the buffer
+ * through dma_buf_map_attachment.
+ * @sysfs_entry: For exposing information about this attachment in sysfs.
  *
  * This structure holds the attachment information between the dma_buf buffer
  * and its user device(s). The list contains one attachment struct per device
@@ -412,6 +509,14 @@ struct dma_buf_attachment {
 	const struct dma_buf_attach_ops *importer_ops;
 	void *importer_priv;
 	void *priv;
+	unsigned long dma_map_attrs;
+#ifdef CONFIG_DMABUF_SYSFS_STATS
+	/* for sysfs stats */
+	struct dma_buf_attach_sysfs_entry {
+		struct kobject kobj;
+		unsigned int map_counter;
+	} *sysfs_entry;
+#endif
 };
 
 /**
@@ -489,6 +594,9 @@ dma_buf_attachment_is_dynamic(struct dma_buf_attachment *attach)
 	return !!attach->importer_ops;
 }
 
+int get_each_dmabuf(int (*callback)(const struct dma_buf *dmabuf,
+		    void *private), void *private);
+int is_dma_buf_file(struct file *file);
 struct dma_buf_attachment *dma_buf_attach(struct dma_buf *dmabuf,
 					  struct device *dev);
 struct dma_buf_attachment *
@@ -513,13 +621,21 @@ void dma_buf_unmap_attachment(struct dma_buf_attachment *, struct sg_table *,
 void dma_buf_move_notify(struct dma_buf *dma_buf);
 int dma_buf_begin_cpu_access(struct dma_buf *dma_buf,
 			     enum dma_data_direction dir);
+int dma_buf_begin_cpu_access_partial(struct dma_buf *dma_buf,
+				     enum dma_data_direction dir,
+				     unsigned int offset, unsigned int len);
 int dma_buf_end_cpu_access(struct dma_buf *dma_buf,
 			   enum dma_data_direction dir);
+int dma_buf_end_cpu_access_partial(struct dma_buf *dma_buf,
+				     enum dma_data_direction dir,
+				     unsigned int offset, unsigned int len);
 
 int dma_buf_mmap(struct dma_buf *, struct vm_area_struct *,
 		 unsigned long);
 void *dma_buf_vmap(struct dma_buf *);
 void dma_buf_vunmap(struct dma_buf *, void *vaddr);
+int dma_buf_get_flags(struct dma_buf *dmabuf, unsigned long *flags);
+int dma_buf_get_uuid(struct dma_buf *dmabuf, uuid_t *uuid);
 
 #ifdef CONFIG_DMABUF_PROCESS_INFO
 /**
diff --git a/include/linux/dma-fence.h b/include/linux/dma-fence.h
index 09e23adb3..9f12efaaa 100644
--- a/include/linux/dma-fence.h
+++ b/include/linux/dma-fence.h
@@ -372,6 +372,9 @@ static inline void __dma_fence_might_wait(void) {}
 
 int dma_fence_signal(struct dma_fence *fence);
 int dma_fence_signal_locked(struct dma_fence *fence);
+int dma_fence_signal_timestamp(struct dma_fence *fence, ktime_t timestamp);
+int dma_fence_signal_timestamp_locked(struct dma_fence *fence,
+				      ktime_t timestamp);
 signed long dma_fence_default_wait(struct dma_fence *fence,
 				   bool intr, signed long timeout);
 int dma_fence_add_callback(struct dma_fence *fence,
diff --git a/include/linux/dma-heap.h b/include/linux/dma-heap.h
index 83b8cfb2d..e8f0e92c2 100644
--- a/include/linux/dma-heap.h
+++ b/include/linux/dma-heap.h
@@ -16,15 +16,17 @@ struct dma_heap;
 
 /**
  * struct dma_heap_ops - ops to operate on a given heap
- * @allocate:		allocate dmabuf and return fd
+ * @allocate:		allocate dmabuf and return struct dma_buf ptr
+ * @get_pool_size:	if heap maintains memory pools, get pool size in bytes
  *
- * allocate returns dmabuf fd  on success, -errno on error.
+ * allocate returns dmabuf on success, ERR_PTR(-errno) on error.
  */
 struct dma_heap_ops {
-	int (*allocate)(struct dma_heap *heap,
+	struct dma_buf *(*allocate)(struct dma_heap *heap,
 			unsigned long len,
 			unsigned long fd_flags,
 			unsigned long heap_flags);
+	long (*get_pool_size)(struct dma_heap *heap);
 };
 
 /**
@@ -50,6 +52,15 @@ struct dma_heap_export_info {
  */
 void *dma_heap_get_drvdata(struct dma_heap *heap);
 
+/**
+ * dma_heap_get_dev() - get device struct for the heap
+ * @heap: DMA-Heap to retrieve device struct from
+ *
+ * Returns:
+ * The device struct for the heap.
+ */
+struct device *dma_heap_get_dev(struct dma_heap *heap);
+
 /**
  * dma_heap_get_name() - get heap name
  * @heap: DMA-Heap to retrieve private data for
@@ -65,4 +76,49 @@ const char *dma_heap_get_name(struct dma_heap *heap);
  */
 struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info);
 
+/**
+ * dma_heap_put - drops a reference to a dmabuf heaps, potentially freeing it
+ * @heap:		heap pointer
+ */
+void dma_heap_put(struct dma_heap *heap);
+
+/**
+ * dma_heap_find - Returns the registered dma_heap with the specified name
+ * @name: Name of the heap to find
+ *
+ * NOTE: dma_heaps returned from this function MUST be released
+ * using dma_heap_put() when the user is done.
+ */
+struct dma_heap *dma_heap_find(const char *name);
+
+/**
+ * dma_heap_buffer_alloc - Allocate dma-buf from a dma_heap
+ * @heap:	dma_heap to allocate from
+ * @len:	size to allocate
+ * @fd_flags:	flags to set on returned dma-buf fd
+ * @heap_flags:	flags to pass to the dma heap
+ *
+ * This is for internal dma-buf allocations only.
+ */
+struct dma_buf *dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
+				      unsigned int fd_flags,
+				      unsigned int heap_flags);
+
+/** dma_heap_buffer_free - Free dma_buf allocated by dma_heap_buffer_alloc
+ * @dma_buf:	dma_buf to free
+ *
+ * This is really only a simple wrapper to dma_buf_put()
+ */
+void dma_heap_buffer_free(struct dma_buf *);
+
+/**
+ * dma_heap_bufferfd_alloc - Allocate dma-buf fd from a dma_heap
+ * @heap:	dma_heap to allocate from
+ * @len:	size to allocate
+ * @fd_flags:	flags to set on returned dma-buf fd
+ * @heap_flags:	flags to pass to the dma heap
+ */
+int dma_heap_bufferfd_alloc(struct dma_heap *heap, size_t len,
+			    unsigned int fd_flags,
+			    unsigned int heap_flags);
 #endif /* _DMA_HEAPS_H */
diff --git a/include/linux/dma-iommu.h b/include/linux/dma-iommu.h
index 2112f21f7..f51561eda 100644
--- a/include/linux/dma-iommu.h
+++ b/include/linux/dma-iommu.h
@@ -37,6 +37,11 @@ void iommu_dma_compose_msi_msg(struct msi_desc *desc,
 
 void iommu_dma_get_resv_regions(struct device *dev, struct list_head *list);
 
+int iommu_dma_reserve_iova(struct device *dev, dma_addr_t base,
+			   u64 size);
+
+int iommu_dma_enable_best_fit_algo(struct device *dev);
+
 #else /* CONFIG_IOMMU_DMA */
 
 struct iommu_domain;
@@ -78,5 +83,16 @@ static inline void iommu_dma_get_resv_regions(struct device *dev, struct list_he
 {
 }
 
+static inline int iommu_dma_reserve_iova(struct device *dev, dma_addr_t base,
+					 u64 size)
+{
+	return -ENODEV;
+}
+
+static inline int iommu_dma_enable_best_fit_algo(struct device *dev)
+{
+	return -ENODEV;
+}
+
 #endif	/* CONFIG_IOMMU_DMA */
 #endif	/* __DMA_IOMMU_H */
diff --git a/include/linux/dma-map-ops.h b/include/linux/dma-map-ops.h
index a5f89fc4d..a3ff9280f 100644
--- a/include/linux/dma-map-ops.h
+++ b/include/linux/dma-map-ops.h
@@ -258,6 +258,14 @@ void arch_dma_free(struct device *dev, size_t size, void *cpu_addr,
 #define pgprot_dmacoherent(prot)	pgprot_noncached(prot)
 #endif
 
+/*
+ * If there is no system cache pgprot, then fallback to dmacoherent
+ * pgprot, as the expectation is that the device is not coherent.
+ */
+#ifndef pgprot_syscached
+#define pgprot_syscached(prot)		pgprot_dmacoherent(prot)
+#endif
+
 pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs);
 #else
 static inline pgprot_t dma_pgprot(struct device *dev, pgprot_t prot,
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index a7d70cdee..7270f12e2 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -61,6 +61,23 @@
  */
 #define DMA_ATTR_PRIVILEGED		(1UL << 9)
 
+/*
+ * DMA_ATTR_SYS_CACHE_ONLY: used to indicate that the buffer should be mapped
+ * with the correct memory attributes so that it can be cached in the system
+ * or last level cache. This is useful for buffers that are being mapped for
+ * devices that are non-coherent, but can use the system cache.
+ */
+#define DMA_ATTR_SYS_CACHE_ONLY		(1UL << 10)
+
+/*
+ * DMA_ATTR_SYS_CACHE_ONLY_NWA: used to indicate that the buffer should be
+ * mapped with the correct memory attributes so that it can be cached in the
+ * system or last level cache, with a no write allocate cache policy. This is
+ * useful for buffers that are being mapped for devices that are non-coherent,
+ * but can use the system cache.
+ */
+#define DMA_ATTR_SYS_CACHE_ONLY_NWA	(1UL << 11)
+
 /*
  * A dma_addr_t can hold any valid DMA or bus address for the platform.  It can
  * be given to a device to use as a DMA source or target.  It is specific to a
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index dd357a747..493a047ed 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -418,6 +418,9 @@ enum dma_slave_buswidth {
  * @slave_id: Slave requester id. Only valid for slave channels. The dma
  * slave peripheral will have unique id as dma requester which need to be
  * pass as slave config.
+ * @peripheral_config: peripheral configuration for programming peripheral
+ * for dmaengine transfer
+ * @peripheral_size: peripheral configuration buffer size
  *
  * This struct is passed in as configuration data to a DMA engine
  * in order to set up a certain channel for DMA transport at runtime.
@@ -443,6 +446,8 @@ struct dma_slave_config {
 	u32 dst_port_window_size;
 	bool device_fc;
 	unsigned int slave_id;
+	void *peripheral_config;
+	size_t peripheral_size;
 };
 
 /**
diff --git a/include/linux/energy_model.h b/include/linux/energy_model.h
index 5f04a2b35..9ca1ea02f 100644
--- a/include/linux/energy_model.h
+++ b/include/linux/energy_model.h
@@ -29,6 +29,8 @@ struct em_perf_state {
  * em_perf_domain - Performance domain
  * @table:		List of performance states, in ascending order
  * @nr_perf_states:	Number of performance states
+ * @milliwatts:		Flag indicating the power values are in milli-Watts
+ *			or some other scale.
  * @cpus:		Cpumask covering the CPUs of the domain. It's here
  *			for performance reasons to avoid potential cache
  *			misses during energy calculations in the scheduler
@@ -43,6 +45,7 @@ struct em_perf_state {
 struct em_perf_domain {
 	struct em_perf_state *table;
 	int nr_perf_states;
+	int milliwatts;
 	unsigned long cpus[];
 };
 
@@ -95,7 +98,8 @@ struct em_data_callback {
 struct em_perf_domain *em_cpu_get(int cpu);
 struct em_perf_domain *em_pd_get(struct device *dev);
 int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,
-				struct em_data_callback *cb, cpumask_t *span);
+				struct em_data_callback *cb, cpumask_t *span,
+				bool milliwatts);
 void em_dev_unregister_perf_domain(struct device *dev);
 
 /**
@@ -119,6 +123,9 @@ static inline unsigned long em_cpu_energy(struct em_perf_domain *pd,
 	struct em_perf_state *ps;
 	int i, cpu;
 
+	if (!sum_util)
+		return 0;
+
 	/*
 	 * In order to predict the performance state, map the utilization of
 	 * the most utilized CPU of the performance domain to a requested
@@ -202,7 +209,8 @@ struct em_data_callback {};
 
 static inline
 int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,
-				struct em_data_callback *cb, cpumask_t *span)
+				struct em_data_callback *cb, cpumask_t *span,
+				bool milliwatts)
 {
 	return -EINVAL;
 }
diff --git a/include/linux/extcon.h b/include/linux/extcon.h
index 0c19010da..9c4ff7f7d 100644
--- a/include/linux/extcon.h
+++ b/include/linux/extcon.h
@@ -37,6 +37,7 @@
 /* USB external connector */
 #define EXTCON_USB		1
 #define EXTCON_USB_HOST		2
+#define EXTCON_USB_VBUS_EN	3
 
 /*
  * Charging external connector
diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 27828145c..f753c307b 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -27,6 +27,11 @@ static inline bool frozen(struct task_struct *p)
 	return p->flags & PF_FROZEN;
 }
 
+static inline bool frozen_or_skipped(struct task_struct *p)
+{
+	return p->flags & (PF_FROZEN | PF_FREEZER_SKIP);
+}
+
 extern bool freezing_slow_path(struct task_struct *p);
 
 /*
@@ -270,6 +275,7 @@ static inline int freezable_schedule_hrtimeout_range(ktime_t *expires,
 
 #else /* !CONFIG_FREEZER */
 static inline bool frozen(struct task_struct *p) { return false; }
+static inline bool frozen_or_skipped(struct task_struct *p) { return false; }
 static inline bool freezing(struct task_struct *p) { return false; }
 static inline void __thaw_task(struct task_struct *t) {}
 
diff --git a/include/linux/initramfs.h b/include/linux/initramfs.h
new file mode 100644
index 000000000..269531716
--- /dev/null
+++ b/include/linux/initramfs.h
@@ -0,0 +1,40 @@
+/*
+ * include/linux/initramfs.h
+ *
+ * Copyright (C) 2015, Google
+ * Rom Lemarchand <romlem@android.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _LINUX_INITRAMFS_H
+#define _LINUX_INITRAMFS_H
+
+#include <linux/kconfig.h>
+
+#if IS_BUILTIN(CONFIG_BLK_DEV_INITRD)
+
+int __init default_rootfs(void);
+
+#endif
+
+#if defined(CONFIG_ROCKCHIP_HW_DECOMPRESS)
+void __init wait_initrd_hw_decom_done(void);
+#endif
+
+#if defined(CONFIG_ROCKCHIP_THUNDER_BOOT_CRYPTO)
+int __init rk_tb_crypto_sha256_wait_compare_done(void);
+#endif
+
+#endif /* _LINUX_INITRAMFS_H */
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index e90c267e7..f94cfde78 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -31,6 +31,26 @@
  * if the IOMMU page table format is equivalent.
  */
 #define IOMMU_PRIV	(1 << 5)
+/*
+ * Non-coherent masters can use this page protection flag to set cacheable
+ * memory attributes for only a transparent outer level of cache, also known as
+ * the last-level or system cache.
+ */
+#define IOMMU_SYS_CACHE_ONLY	(1 << 6)
+/*
+ * Non-coherent masters can use this page protection flag to set cacheable
+ * memory attributes with a no write allocation cache policy for only a
+ * transparent outer level of cache, also known as the last-level or system
+ * cache.
+ */
+#define IOMMU_SYS_CACHE_ONLY_NWA (1 << 7)
+
+#ifdef CONFIG_NO_GKI
+
+/* For shoting entire IOMMU tlb once */
+#define IOMMU_TLB_SHOT_ENTIRE	(1 << 8)
+
+#endif
 
 struct iommu_ops;
 struct iommu_group;
@@ -190,7 +210,12 @@ struct iommu_iotlb_gather {
  * @attach_dev: attach device to an iommu domain
  * @detach_dev: detach device from an iommu domain
  * @map: map a physically contiguous memory region to an iommu domain
+ * @map_pages: map a physically contiguous set of pages of the same size to
+ *             an iommu domain.
+ * @map_sg: map a scatter-gather list of physically contiguous chunks to
+ *          an iommu domain.
  * @unmap: unmap a physically contiguous memory region from an iommu domain
+ * @unmap_pages: unmap a number of pages of the same size from an iommu domain
  * @flush_iotlb_all: Synchronously flush all hardware TLBs for this domain
  * @iotlb_sync_map: Sync mappings created recently using @map to the hardware
  * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
@@ -241,10 +266,20 @@ struct iommu_ops {
 	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
 	int (*map)(struct iommu_domain *domain, unsigned long iova,
 		   phys_addr_t paddr, size_t size, int prot, gfp_t gfp);
+	int (*map_pages)(struct iommu_domain *domain, unsigned long iova,
+			 phys_addr_t paddr, size_t pgsize, size_t pgcount,
+			 int prot, gfp_t gfp, size_t *mapped);
+	int (*map_sg)(struct iommu_domain *domain, unsigned long iova,
+		      struct scatterlist *sg, unsigned int nents, int prot,
+		      gfp_t gfp, size_t *mapped);
 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
 		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
+	size_t (*unmap_pages)(struct iommu_domain *domain, unsigned long iova,
+			      size_t pgsize, size_t pgcount,
+			      struct iommu_iotlb_gather *iotlb_gather);
 	void (*flush_iotlb_all)(struct iommu_domain *domain);
-	void (*iotlb_sync_map)(struct iommu_domain *domain);
+	void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,
+			       size_t size);
 	void (*iotlb_sync)(struct iommu_domain *domain,
 			   struct iommu_iotlb_gather *iotlb_gather);
 	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
@@ -561,6 +596,8 @@ static inline void iommu_iotlb_gather_add_page(struct iommu_domain *domain,
 extern struct iommu_group *pci_device_group(struct device *dev);
 /* Generic device grouping function */
 extern struct iommu_group *generic_device_group(struct device *dev);
+extern void rk_iommu_mask_irq(struct device *dev);
+extern void rk_iommu_unmask_irq(struct device *dev);
 /* FSL-MC device grouping function */
 struct iommu_group *fsl_mc_device_group(struct device *dev);
 
@@ -1069,6 +1106,14 @@ static inline struct iommu_fwspec *dev_iommu_fwspec_get(struct device *dev)
 {
 	return NULL;
 }
+
+static inline void rk_iommu_mask_irq(struct device *dev)
+{
+}
+
+static inline void rk_iommu_unmask_irq(struct device *dev)
+{
+}
 #endif /* CONFIG_IOMMU_API */
 
 /**
diff --git a/include/linux/iova.h b/include/linux/iova.h
index a0637abff..58713bb72 100644
--- a/include/linux/iova.h
+++ b/include/linux/iova.h
@@ -95,6 +95,7 @@ struct iova_domain {
 						   flush-queues */
 	atomic_t fq_timer_on;			/* 1 when timer is active, 0
 						   when not */
+	bool best_fit;
 };
 
 static inline unsigned long iova_size(struct iova *iova)
diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h
index f6d092fdb..ffb0a8705 100644
--- a/include/linux/irqchip/arm-gic-v3.h
+++ b/include/linux/irqchip/arm-gic-v3.h
@@ -708,6 +708,8 @@ static inline bool gic_enable_sre(void)
 	return !!(val & ICC_SRE_EL1_SRE);
 }
 
+void gic_resume(void);
+
 #endif
 
 #endif
diff --git a/include/linux/irqchip/arm-gic-v4.h b/include/linux/irqchip/arm-gic-v4.h
index 6976b8331..943c3411c 100644
--- a/include/linux/irqchip/arm-gic-v4.h
+++ b/include/linux/irqchip/arm-gic-v4.h
@@ -39,6 +39,8 @@ struct its_vpe {
 	irq_hw_number_t		vpe_db_lpi;
 	/* VPE resident */
 	bool			resident;
+	/* VPT parse complete */
+	bool			ready;
 	union {
 		/* GICv4.0 implementations */
 		struct {
@@ -104,6 +106,7 @@ enum its_vcpu_info_cmd_type {
 	PROP_UPDATE_AND_INV_VLPI,
 	SCHEDULE_VPE,
 	DESCHEDULE_VPE,
+	COMMIT_VPE,
 	INVALL_VPE,
 	PROP_UPDATE_VSGI,
 };
@@ -129,6 +132,7 @@ int its_alloc_vcpu_irqs(struct its_vm *vm);
 void its_free_vcpu_irqs(struct its_vm *vm);
 int its_make_vpe_resident(struct its_vpe *vpe, bool g0en, bool g1en);
 int its_make_vpe_non_resident(struct its_vpe *vpe, bool db);
+int its_commit_vpe(struct its_vpe *vpe);
 int its_invall_vpe(struct its_vpe *vpe);
 int its_map_vlpi(int irq, struct its_vlpi_map *map);
 int its_get_vlpi(int irq, struct its_vlpi_map *map);
diff --git a/include/linux/memblock.h b/include/linux/memblock.h
index 1a8d25f2e..de15a4d15 100644
--- a/include/linux/memblock.h
+++ b/include/linux/memblock.h
@@ -25,6 +25,10 @@ extern unsigned long max_pfn;
  */
 extern unsigned long long max_possible_pfn;
 
+#ifdef CONFIG_ROCKCHIP_THUNDER_BOOT
+extern int defer_free_memblock(void *unused);
+#endif
+
 /**
  * enum memblock_flags - definition of memory region attributes
  * @MEMBLOCK_NONE: no special request
@@ -404,13 +408,13 @@ void *memblock_alloc_try_nid(phys_addr_t size, phys_addr_t align,
 			     phys_addr_t min_addr, phys_addr_t max_addr,
 			     int nid);
 
-static inline void * __init memblock_alloc(phys_addr_t size,  phys_addr_t align)
+static __always_inline void *memblock_alloc(phys_addr_t size, phys_addr_t align)
 {
 	return memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,
 				      MEMBLOCK_ALLOC_ACCESSIBLE, NUMA_NO_NODE);
 }
 
-static inline void * __init memblock_alloc_raw(phys_addr_t size,
+static inline void *memblock_alloc_raw(phys_addr_t size,
 					       phys_addr_t align)
 {
 	return memblock_alloc_try_nid_raw(size, align, MEMBLOCK_LOW_LIMIT,
@@ -418,7 +422,7 @@ static inline void * __init memblock_alloc_raw(phys_addr_t size,
 					  NUMA_NO_NODE);
 }
 
-static inline void * __init memblock_alloc_from(phys_addr_t size,
+static inline void *memblock_alloc_from(phys_addr_t size,
 						phys_addr_t align,
 						phys_addr_t min_addr)
 {
@@ -426,33 +430,33 @@ static inline void * __init memblock_alloc_from(phys_addr_t size,
 				      MEMBLOCK_ALLOC_ACCESSIBLE, NUMA_NO_NODE);
 }
 
-static inline void * __init memblock_alloc_low(phys_addr_t size,
+static inline void *memblock_alloc_low(phys_addr_t size,
 					       phys_addr_t align)
 {
 	return memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,
 				      ARCH_LOW_ADDRESS_LIMIT, NUMA_NO_NODE);
 }
 
-static inline void * __init memblock_alloc_node(phys_addr_t size,
+static inline void *memblock_alloc_node(phys_addr_t size,
 						phys_addr_t align, int nid)
 {
 	return memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,
 				      MEMBLOCK_ALLOC_ACCESSIBLE, nid);
 }
 
-static inline void __init memblock_free_early(phys_addr_t base,
+static inline void memblock_free_early(phys_addr_t base,
 					      phys_addr_t size)
 {
 	memblock_free(base, size);
 }
 
-static inline void __init memblock_free_early_nid(phys_addr_t base,
+static inline void memblock_free_early_nid(phys_addr_t base,
 						  phys_addr_t size, int nid)
 {
 	memblock_free(base, size);
 }
 
-static inline void __init memblock_free_late(phys_addr_t base, phys_addr_t size)
+static inline void memblock_free_late(phys_addr_t base, phys_addr_t size)
 {
 	__memblock_free_late(base, size);
 }
@@ -460,7 +464,7 @@ static inline void __init memblock_free_late(phys_addr_t base, phys_addr_t size)
 /*
  * Set the allocation direction to bottom-up or top-down.
  */
-static inline void __init memblock_set_bottom_up(bool enable)
+static inline __init void memblock_set_bottom_up(bool enable)
 {
 	memblock.bottom_up = enable;
 }
@@ -470,7 +474,7 @@ static inline void __init memblock_set_bottom_up(bool enable)
  * if this is true, that said, memblock will allocate memory
  * in bottom-up direction.
  */
-static inline bool memblock_bottom_up(void)
+static inline __init bool memblock_bottom_up(void)
 {
 	return memblock.bottom_up;
 }
diff --git a/include/linux/memory_group_manager.h b/include/linux/memory_group_manager.h
new file mode 100644
index 000000000..b1ac253d9
--- /dev/null
+++ b/include/linux/memory_group_manager.h
@@ -0,0 +1,198 @@
+/*
+ *
+ * (C) COPYRIGHT 2019 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+#ifndef _MEMORY_GROUP_MANAGER_H_
+#define _MEMORY_GROUP_MANAGER_H_
+
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/version.h>
+
+#if (KERNEL_VERSION(4, 17, 0) > LINUX_VERSION_CODE)
+typedef int vm_fault_t;
+#endif
+
+#define MEMORY_GROUP_MANAGER_NR_GROUPS (16)
+
+struct memory_group_manager_device;
+struct memory_group_manager_import_data;
+
+/**
+ * struct memory_group_manager_ops - Callbacks for memory group manager
+ *                                   operations
+ *
+ * @mgm_alloc_page:           Callback to allocate physical memory in a group
+ * @mgm_free_page:            Callback to free physical memory in a group
+ * @mgm_get_import_memory_id: Callback to get the group ID for imported memory
+ * @mgm_update_gpu_pte:       Callback to modify a GPU page table entry
+ * @mgm_vmf_insert_pfn_prot:  Callback to map a physical memory page for the CPU
+ */
+struct memory_group_manager_ops {
+	/**
+	 * mgm_alloc_page - Allocate a physical memory page in a group
+	 *
+	 * @mgm_dev:  The memory group manager through which the request is
+	 *            being made.
+	 * @group_id: A physical memory group ID. The meaning of this is defined
+	 *            by the systems integrator. Its valid range is
+	 *            0 .. MEMORY_GROUP_MANAGER_NR_GROUPS-1.
+	 * @gfp_mask: Bitmask of Get Free Page flags affecting allocator
+	 *            behavior.
+	 * @order:    Page order for physical page size (order=0 means 4 KiB,
+	 *            order=9 means 2 MiB).
+	 *
+	 * Return: Pointer to allocated page, or NULL if allocation failed.
+	 */
+	struct page *(*mgm_alloc_page)(
+		struct memory_group_manager_device *mgm_dev, int group_id,
+		gfp_t gfp_mask, unsigned int order);
+
+	/**
+	 * mgm_free_page - Free a physical memory page in a group
+	 *
+	 * @mgm_dev:  The memory group manager through which the request
+	 *            is being made.
+	 * @group_id: A physical memory group ID. The meaning of this is
+	 *            defined by the systems integrator. Its valid range is
+	 *            0 .. MEMORY_GROUP_MANAGER_NR_GROUPS-1.
+	 * @page:     Address of the struct associated with a page of physical
+	 *            memory that was allocated by calling the mgm_alloc_page
+	 *            method of the same memory pool with the same values of
+	 *            @group_id and @order.
+	 * @order:    Page order for physical page size (order=0 means 4 KiB,
+	 *            order=9 means 2 MiB).
+	 */
+	void (*mgm_free_page)(
+		struct memory_group_manager_device *mgm_dev, int group_id,
+		struct page *page, unsigned int order);
+
+	/**
+	 * mgm_get_import_memory_id - Get the physical memory group ID for the
+	 *                            imported memory
+	 *
+	 * @mgm_dev:     The memory group manager through which the request
+	 *               is being made.
+	 * @import_data: Pointer to the data which describes imported memory.
+	 *
+	 * Note that provision of this call back is optional, where it is not
+	 * provided this call back pointer must be set to NULL to indicate it
+	 * is not in use.
+	 *
+	 * Return: The memory group ID to use when mapping pages from this
+	 *         imported memory.
+	 */
+	int (*mgm_get_import_memory_id)(
+		struct memory_group_manager_device *mgm_dev,
+		struct memory_group_manager_import_data *import_data);
+
+	/**
+	 * mgm_update_gpu_pte - Modify a GPU page table entry for a memory group
+	 *
+	 * @mgm_dev:   The memory group manager through which the request
+	 *             is being made.
+	 * @group_id:  A physical memory group ID. The meaning of this is
+	 *             defined by the systems integrator. Its valid range is
+	 *             0 .. MEMORY_GROUP_MANAGER_NR_GROUPS-1.
+	 * @mmu_level: The level of the page table entry in @ate.
+	 * @pte:       The page table entry to modify, in LPAE or AArch64 format
+	 *             (depending on the driver's configuration). This should be
+	 *             decoded to determine the physical address and any other
+	 *             properties of the mapping the manager requires.
+	 *
+	 * This function allows the memory group manager to modify a GPU page
+	 * table entry before it is stored by the kbase module (controller
+	 * driver). It may set certain bits in the page table entry attributes
+	 * or in the physical address, based on the physical memory group ID.
+	 *
+	 * Return: A modified GPU page table entry to be stored in a page table.
+	 */
+	u64 (*mgm_update_gpu_pte)(struct memory_group_manager_device *mgm_dev,
+			int group_id, int mmu_level, u64 pte);
+
+	/**
+	 * mgm_vmf_insert_pfn_prot - Map a physical page in a group for the CPU
+	 *
+	 * @mgm_dev:   The memory group manager through which the request
+	 *             is being made.
+	 * @group_id:  A physical memory group ID. The meaning of this is
+	 *             defined by the systems integrator. Its valid range is
+	 *             0 .. MEMORY_GROUP_MANAGER_NR_GROUPS-1.
+	 * @vma:       The virtual memory area to insert the page into.
+	 * @addr:      A virtual address (in @vma) to assign to the page.
+	 * @pfn:       The kernel Page Frame Number to insert at @addr in @vma.
+	 * @pgprot:    Protection flags for the inserted page.
+	 *
+	 * Called from a CPU virtual memory page fault handler. This function
+	 * creates a page table entry from the given parameter values and stores
+	 * it at the appropriate location (unlike mgm_update_gpu_pte, which
+	 * returns a modified entry).
+	 *
+	 * Return: Type of fault that occurred or VM_FAULT_NOPAGE if the page
+	 *         table entry was successfully installed.
+	 */
+	vm_fault_t (*mgm_vmf_insert_pfn_prot)(
+		struct memory_group_manager_device *mgm_dev, int group_id,
+		struct vm_area_struct *vma, unsigned long addr,
+		unsigned long pfn, pgprot_t pgprot);
+};
+
+/**
+ * struct memory_group_manager_device - Device structure for a memory group
+ *                                      manager
+ *
+ * @ops  - Callbacks associated with this device
+ * @data - Pointer to device private data
+ *
+ * In order for a systems integrator to provide custom behaviors for memory
+ * operations performed by the kbase module (controller driver), they must
+ * provide a platform-specific driver module which implements this interface.
+ *
+ * This structure should be registered with the platform device using
+ * platform_set_drvdata().
+ */
+struct memory_group_manager_device {
+	struct memory_group_manager_ops ops;
+	void *data;
+	struct module *owner;
+};
+
+
+enum memory_group_manager_import_type {
+	MEMORY_GROUP_MANAGER_IMPORT_TYPE_DMA_BUF
+};
+
+/**
+ * struct memory_group_manager_import_data - Structure describing the imported
+ *                                           memory
+ *
+ * @type  - type of imported memory
+ * @u     - Union describing the imported memory
+ *
+ */
+struct memory_group_manager_import_data {
+	enum memory_group_manager_import_type type;
+	union {
+		struct dma_buf *dma_buf;
+	} u;
+};
+
+#endif /* _MEMORY_GROUP_MANAGER_H_ */
diff --git a/include/linux/mfd/rk808.h b/include/linux/mfd/rk808.h
index e07f6e61c..7cdc5dfa4 100644
--- a/include/linux/mfd/rk808.h
+++ b/include/linux/mfd/rk808.h
@@ -113,6 +113,235 @@ enum rk808_reg {
 #define RK808_INT_STS_MSK_REG2	0x4f
 #define RK808_IO_POL_REG	0x50
 
+/* RK816 */
+enum rk816_reg {
+	RK816_ID_DCDC1,
+	RK816_ID_DCDC2,
+	RK816_ID_DCDC3,
+	RK816_ID_DCDC4,
+	RK816_ID_LDO1,
+	RK816_ID_LDO2,
+	RK816_ID_LDO3,
+	RK816_ID_LDO4,
+	RK816_ID_LDO5,
+	RK816_ID_LDO6,
+};
+
+/*VERSION REGISTER*/
+#define RK816_CHIP_NAME_REG			0x17
+#define RK816_CHIP_VER_REG			0x18
+#define RK816_OTP_VER_REG			0x19
+#define RK816_NUM_REGULATORS			10
+
+/*POWER ON/OFF REGISTER*/
+#define RK816_VB_MON_REG			0x21
+#define RK816_THERMAL_REG			0x22
+#define RK816_PWRON_LP_INT_TIME_REG		0x47
+#define RK816_PWRON_DB_REG			0x48
+#define RK816_DEV_CTRL_REG			0x4B
+#define RK816_ON_SOURCE_REG			0xAE
+#define RK816_OFF_SOURCE_REG			0xAF
+
+/*POWER CHANNELS ENABLE REGISTER*/
+#define RK816_DCDC_EN_REG1			0x23
+#define RK816_DCDC_EN_REG2			0x24
+#define RK816_SLP_DCDC_EN_REG			0x25
+#define RK816_SLP_LDO_EN_REG			0x26
+#define RK816_LDO_EN_REG1			0x27
+#define RK816_LDO_EN_REG2			0x28
+
+/*BUCK AND LDO CONFIG REGISTER*/
+#define RK816_BUCK1_CONFIG_REG			0x2E
+#define RK816_BUCK1_ON_VSEL_REG			0x2F
+#define RK816_BUCK1_SLP_VSEL_REG		0x30
+#define RK816_BUCK2_CONFIG_REG			0x32
+#define RK816_BUCK2_ON_VSEL_REG			0x33
+#define RK816_BUCK2_SLP_VSEL_REG		0x34
+#define RK816_BUCK3_CONFIG_REG			0x36
+#define RK816_BUCK4_CONFIG_REG			0x37
+#define RK816_BUCK4_ON_VSEL_REG			0x38
+#define RK816_BUCK4_SLP_VSEL_REG		0x39
+#define RK816_LDO1_ON_VSEL_REG			0x3B
+#define RK816_LDO1_SLP_VSEL_REG			0x3C
+#define RK816_LDO2_ON_VSEL_REG			0x3D
+#define RK816_LDO2_SLP_VSEL_REG			0x3E
+#define RK816_LDO3_ON_VSEL_REG			0x3F
+#define RK816_LDO3_SLP_VSEL_REG			0x40
+#define RK816_LDO4_ON_VSEL_REG			0x41
+#define RK816_LDO4_SLP_VSEL_REG			0x42
+#define RK816_LDO5_ON_VSEL_REG			0x43
+#define RK816_LDO5_SLP_VSEL_REG			0x44
+#define RK816_LDO6_ON_VSEL_REG			0x45
+#define RK816_LDO6_SLP_VSEL_REG			0x46
+#define RK816_GPIO_IO_POL_REG			0x50
+
+/*CHARGER BOOST AND OTG REGISTER*/
+#define RK816_OTG_BUCK_LDO_CONFIG_REG           0x2A
+#define RK816_CHRG_CONFIG_REG                   0x2B
+#define RK816_BOOST_ON_VESL_REG                 0x54
+#define RK816_BOOST_SLP_VSEL_REG                0x55
+#define RK816_CHRG_BOOST_CONFIG_REG             0x9A
+#define RK816_SUP_STS_REG                       0xA0
+#define RK816_USB_CTRL_REG                      0xA1
+#define RK816_CHRG_CTRL_REG1                    0xA3
+#define RK816_CHRG_CTRL_REG2                    0xA4
+#define RK816_CHRG_CTRL_REG3                    0xA5
+#define RK816_BAT_CTRL_REG                      0xA6
+#define RK816_BAT_HTS_TS_REG                    0xA8
+#define RK816_BAT_LTS_TS_REG                    0xA9
+
+#define RK816_TS_CTRL_REG			0xAC
+#define RK816_ADC_CTRL_REG			0xAD
+#define RK816_GGCON_REG				0xB0
+#define RK816_GGSTS_REG				0xB1
+#define RK816_ZERO_CUR_ADC_REGH			0xB2
+#define RK816_ZERO_CUR_ADC_REGL			0xB3
+#define RK816_GASCNT_CAL_REG3			0xB4
+#define RK816_GASCNT_CAL_REG2			0xB5
+#define RK816_GASCNT_CAL_REG1			0xB6
+#define RK816_GASCNT_CAL_REG0			0xB7
+#define RK816_GASCNT_REG3			0xB8
+#define RK816_GASCNT_REG2			0xB9
+#define RK816_GASCNT_REG1			0xBA
+#define RK816_GASCNT_REG0			0xBB
+#define RK816_BAT_CUR_AVG_REGH			0xBC
+#define RK816_BAT_CUR_AVG_REGL			0xBD
+#define RK816_TS_ADC_REGH			0xBE
+#define RK816_TS_ADC_REGL			0xBF
+#define RK816_USB_ADC_REGH			0xC0
+#define RK816_USB_ADC_REGL			0xC1
+#define RK816_BAT_OCV_REGH			0xC2
+#define RK816_BAT_OCV_REGL			0xC3
+#define RK816_BAT_VOL_REGH			0xC4
+#define RK816_BAT_VOL_REGL			0xC5
+#define RK816_RELAX_ENTRY_THRES_REGH		0xC6
+#define RK816_RELAX_ENTRY_THRES_REGL		0xC7
+#define RK816_RELAX_EXIT_THRES_REGH		0xC8
+#define RK816_RELAX_EXIT_THRES_REGL		0xC9
+#define RK816_RELAX_VOL1_REGH			0xCA
+#define RK816_RELAX_VOL1_REGL			0xCB
+#define RK816_RELAX_VOL2_REGH			0xCC
+#define RK816_RELAX_VOL2_REGL			0xCD
+#define RK816_RELAX_CUR1_REGH			0xCE
+#define RK816_RELAX_CUR1_REGL			0xCF
+#define RK816_RELAX_CUR2_REGH			0xD0
+#define RK816_RELAX_CUR2_REGL			0xD1
+#define RK816_CAL_OFFSET_REGH			0xD2
+#define RK816_CAL_OFFSET_REGL			0xD3
+#define RK816_NON_ACT_TIMER_CNT_REG		0xD4
+#define RK816_VCALIB0_REGH			0xD5
+#define RK816_VCALIB0_REGL			0xD6
+#define RK816_VCALIB1_REGH			0xD7
+#define RK816_VCALIB1_REGL			0xD8
+#define RK816_FCC_GASCNT_REG3			0xD9
+#define RK816_FCC_GASCNT_REG2			0xDA
+#define RK816_FCC_GASCNT_REG1			0xDB
+#define RK816_FCC_GASCNT_REG0			0xDC
+#define RK816_IOFFSET_REGH			0xDD
+#define RK816_IOFFSET_REGL			0xDE
+#define RK816_SLEEP_CON_SAMP_CUR_REG		0xDF
+
+/*DATA REGISTER*/
+#define RK816_SOC_REG				0xE0
+#define RK816_REMAIN_CAP_REG3			0xE1
+#define RK816_REMAIN_CAP_REG2			0xE2
+#define RK816_REMAIN_CAP_REG1			0xE3
+#define RK816_REMAIN_CAP_REG0			0xE4
+#define RK816_UPDATE_LEVE_REG			0xE5
+#define RK816_NEW_FCC_REG3			0xE6
+#define RK816_NEW_FCC_REG2			0xE7
+#define RK816_NEW_FCC_REG1			0xE8
+#define RK816_NEW_FCC_REG0			0xE9
+#define RK816_NON_ACT_TIMER_CNT_REG_SAVE	0xEA
+#define RK816_OCV_VOL_VALID_REG			0xEB
+#define RK816_REBOOT_CNT_REG			0xEC
+#define RK816_PCB_IOFFSET_REG			0xED
+#define RK816_MISC_MARK_REG			0xEE
+#define RK816_HALT_CNT_REG			0xEF
+#define RK816_CALC_REST_REGH			0xF0
+#define RK816_CALC_REST_REGL			0xF1
+#define DATA18_REG				0xF2
+
+/*INTERRUPT REGISTER*/
+#define RK816_INT_STS_REG1			0x49
+#define RK816_INT_STS_MSK_REG1			0x4A
+#define RK816_INT_STS_REG2			0x4C
+#define RK816_INT_STS_MSK_REG2			0x4D
+#define RK816_INT_STS_REG3			0x4E
+#define RK816_INT_STS_MSK_REG3			0x4F
+#define RK816_GPIO_IO_POL_REG			0x50
+
+#define RK816_DATA18_REG			0xF2
+
+/* IRQ Definitions */
+#define RK816_IRQ_PWRON_FALL			0
+#define RK816_IRQ_PWRON_RISE			1
+#define RK816_IRQ_VB_LOW			2
+#define RK816_IRQ_PWRON				3
+#define RK816_IRQ_PWRON_LP			4
+#define RK816_IRQ_HOTDIE			5
+#define RK816_IRQ_RTC_ALARM			6
+#define RK816_IRQ_RTC_PERIOD			7
+#define RK816_IRQ_USB_OV			8
+#define RK816_IRQ_PLUG_IN			9
+#define RK816_IRQ_PLUG_OUT			10
+#define RK816_IRQ_CHG_OK			11
+#define RK816_IRQ_CHG_TE			12
+#define RK816_IRQ_CHG_TS			13
+#define RK816_IRQ_CHG_CVTLIM			14
+#define RK816_IRQ_DISCHG_ILIM			15
+
+#define RK816_IRQ_PWRON_FALL_MSK		BIT(5)
+#define RK816_IRQ_PWRON_RISE_MSK		BIT(6)
+#define RK816_IRQ_VB_LOW_MSK			BIT(1)
+#define RK816_IRQ_PWRON_MSK			BIT(2)
+#define RK816_IRQ_PWRON_LP_MSK			BIT(3)
+#define RK816_IRQ_HOTDIE_MSK			BIT(4)
+#define RK816_IRQ_RTC_ALARM_MSK			BIT(5)
+#define RK816_IRQ_RTC_PERIOD_MSK		BIT(6)
+#define RK816_IRQ_USB_OV_MSK			BIT(7)
+#define RK816_IRQ_PLUG_IN_MSK			BIT(0)
+#define RK816_IRQ_PLUG_OUT_MSK			BIT(1)
+#define RK816_IRQ_CHG_OK_MSK			BIT(2)
+#define RK816_IRQ_CHG_TE_MSK			BIT(3)
+#define RK816_IRQ_CHG_TS_MSK			BIT(4)
+#define RK816_IRQ_CHG_CVTLIM_MSK		BIT(6)
+#define RK816_IRQ_DISCHG_ILIM_MSK		BIT(7)
+
+#define RK816_VBAT_LOW_2V8			0x00
+#define RK816_VBAT_LOW_2V9			0x01
+#define RK816_VBAT_LOW_3V0			0x02
+#define RK816_VBAT_LOW_3V1			0x03
+#define RK816_VBAT_LOW_3V2			0x04
+#define RK816_VBAT_LOW_3V3			0x05
+#define RK816_VBAT_LOW_3V4			0x06
+#define RK816_VBAT_LOW_3V5			0x07
+#define RK816_PWR_FALL_INT_STATUS		(0x1 << 5)
+#define RK816_PWR_RISE_INT_STATUS		(0x1 << 6)
+#define RK816_ALARM_INT_STATUS			(0x1 << 5)
+#define EN_VBAT_LOW_IRQ				(0x1 << 4)
+#define VBAT_LOW_ACT_MASK			(0x1 << 4)
+#define RTC_TIMER_ALARM_INT_MSK			(0x3 << 2)
+#define RTC_TIMER_ALARM_INT_DIS			(0x0 << 2)
+#define RTC_PERIOD_ALARM_INT_MSK		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_ST			(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_DIS		(0x3 << 5)
+#define RTC_PERIOD_ALARM_INT_EN			(0x9f)
+#define REG_WRITE_MSK				0xff
+#define BUCK4_MAX_ILIMIT			0x2c
+#define BUCK_RATE_MSK				(0x3 << 3)
+#define BUCK_RATE_12_5MV_US			(0x2 << 3)
+#define ALL_INT_FLAGS_ST			0xff
+#define PLUGIN_OUT_INT_EN			0xfc
+#define RK816_PWRON_FALL_RISE_INT_EN		0x9f
+#define BUCK1_2_IMAX_MAX			(0x3 << 6)
+#define BUCK3_4_IMAX_MAX			(0x3 << 3)
+#define BOOST_DISABLE				((0x1 << 5) | (0x0 << 1))
+#define BUCK4_VRP_3PERCENT			0xc0
+#define RK816_BUCK_DVS_CONFIRM			(0x1 << 7)
+#define RK816_TYPE_ES2				0x05
+#define RK816_CHIP_VERSION_MASK			0x0f
+
 /* RK818 */
 #define RK818_DCDC1			0
 #define RK818_LDO1			4
@@ -138,6 +367,8 @@ enum rk818_reg {
 	RK818_ID_OTG_SWITCH,
 };
 
+#define RK818_VB_MON_REG		0x21
+#define RK818_THERMAL_REG		0x22
 #define RK818_DCDC_EN_REG		0x23
 #define RK818_LDO_EN_REG		0x24
 #define RK818_SLEEP_SET_OFF_REG1	0x25
@@ -190,7 +421,84 @@ enum rk818_reg {
 #define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_BOOST_CTRL_REG		0x56
 #define RK818_DCDC_ILMAX		0x90
+#define RK818_CHRG_COMP_REG		0x9a
+#define RK818_SUP_STS_REG		0xa0
 #define RK818_USB_CTRL_REG		0xa1
+#define RK818_CHRG_CTRL_REG1		0xa3
+#define RK818_CHRG_CTRL_REG2		0xa4
+#define RK818_CHRG_CTRL_REG3		0xa5
+#define RK818_BAT_CTRL_REG		0xa6
+#define RK818_BAT_HTS_TS1_REG		0xa8
+#define RK818_BAT_LTS_TS1_REG		0xa9
+#define RK818_BAT_HTS_TS2_REG		0xaa
+#define RK818_BAT_LTS_TS2_REG		0xab
+#define RK818_TS_CTRL_REG		0xac
+#define RK818_ADC_CTRL_REG		0xad
+#define RK818_ON_SOURCE_REG		0xae
+#define RK818_OFF_SOURCE_REG		0xaf
+#define RK818_GGCON_REG			0xb0
+#define RK818_GGSTS_REG			0xb1
+#define RK818_FRAME_SMP_INTERV_REG	0xb2
+#define RK818_AUTO_SLP_CUR_THR_REG	0xb3
+#define RK818_GASCNT_CAL_REG3		0xb4
+#define RK818_GASCNT_CAL_REG2		0xb5
+#define RK818_GASCNT_CAL_REG1		0xb6
+#define RK818_GASCNT_CAL_REG0		0xb7
+#define RK818_GASCNT3_REG		0xb8
+#define RK818_GASCNT2_REG		0xb9
+#define RK818_GASCNT1_REG		0xba
+#define RK818_GASCNT0_REG		0xbb
+#define RK818_BAT_CUR_AVG_REGH		0xbc
+#define RK818_BAT_CUR_AVG_REGL		0xbd
+#define RK818_TS1_ADC_REGH		0xbe
+#define RK818_TS1_ADC_REGL		0xbf
+#define RK818_TS2_ADC_REGH		0xc0
+#define RK818_TS2_ADC_REGL		0xc1
+#define RK818_BAT_OCV_REGH		0xc2
+#define RK818_BAT_OCV_REGL		0xc3
+#define RK818_BAT_VOL_REGH		0xc4
+#define RK818_BAT_VOL_REGL		0xc5
+#define RK818_RELAX_ENTRY_THRES_REGH	0xc6
+#define RK818_RELAX_ENTRY_THRES_REGL	0xc7
+#define RK818_RELAX_EXIT_THRES_REGH	0xc8
+#define RK818_RELAX_EXIT_THRES_REGL	0xc9
+#define RK818_RELAX_VOL1_REGH		0xca
+#define RK818_RELAX_VOL1_REGL		0xcb
+#define RK818_RELAX_VOL2_REGH		0xcc
+#define RK818_RELAX_VOL2_REGL		0xcd
+#define RK818_BAT_CUR_R_CALC_REGH	0xce
+#define RK818_BAT_CUR_R_CALC_REGL	0xcf
+#define RK818_BAT_VOL_R_CALC_REGH	0xd0
+#define RK818_BAT_VOL_R_CALC_REGL	0xd1
+#define RK818_CAL_OFFSET_REGH		0xd2
+#define RK818_CAL_OFFSET_REGL		0xd3
+#define RK818_NON_ACT_TIMER_CNT_REG	0xd4
+#define RK818_VCALIB0_REGH		0xd5
+#define RK818_VCALIB0_REGL		0xd6
+#define RK818_VCALIB1_REGH		0xd7
+#define RK818_VCALIB1_REGL		0xd8
+#define RK818_IOFFSET_REGH		0xdd
+#define RK818_IOFFSET_REGL		0xde
+#define RK818_SOC_REG			0xe0
+#define RK818_REMAIN_CAP_REG3		0xe1
+#define RK818_REMAIN_CAP_REG2		0xe2
+#define RK818_REMAIN_CAP_REG1		0xe3
+#define RK818_REMAIN_CAP_REG0		0xe4
+#define RK818_UPDAT_LEVE_REG		0xe5
+#define RK818_NEW_FCC_REG3		0xe6
+#define RK818_NEW_FCC_REG2		0xe7
+#define RK818_NEW_FCC_REG1		0xe8
+#define RK818_NEW_FCC_REG0		0xe9
+#define RK818_NON_ACT_TIMER_CNT_SAVE_REG	0xea
+#define RK818_OCV_VOL_VALID_REG		0xeb
+#define RK818_REBOOT_CNT_REG		0xec
+#define RK818_POFFSET_REG		0xed
+#define RK818_MISC_MARK_REG		0xee
+#define RK818_HALT_CNT_REG		0xef
+#define RK818_CALC_REST_REGH		0xf0
+#define RK818_CALC_REST_REGL		0xf1
+#define RK818_SAVE_DATA19		0xf2
+#define RK818_NUM_REGULATOR		17
 
 #define RK818_H5V_EN			BIT(0)
 #define RK818_REF_RDY_CTRL		BIT(1)
@@ -255,14 +563,22 @@ enum rk805_reg {
 #define RK805_PWRON_FALL_RISE_INT_MSK	0x81
 
 /* RK805 IRQ Definitions */
-#define RK805_IRQ_PWRON_RISE		0
 #define RK805_IRQ_VB_LOW		1
 #define RK805_IRQ_PWRON			2
 #define RK805_IRQ_PWRON_LP		3
 #define RK805_IRQ_HOTDIE		4
 #define RK805_IRQ_RTC_ALARM		5
 #define RK805_IRQ_RTC_PERIOD		6
-#define RK805_IRQ_PWRON_FALL		7
+
+/*
+ * When PMIC irq occurs, regmap-irq.c will traverse all PMIC child
+ * interrupts from low index 0 to high index, we give fall interrupt
+ * high priority to be called earlier than rise, so that it can be
+ * override by late rise event. This can helps to solve key release
+ * glitch which make a wrongly fall event immediately after rise.
+ */
+#define RK805_IRQ_PWRON_FALL		0
+#define RK805_IRQ_PWRON_RISE		7
 
 #define RK805_IRQ_PWRON_RISE_MSK	BIT(0)
 #define RK805_IRQ_VB_LOW_MSK		BIT(1)
@@ -289,6 +605,16 @@ enum rk805_reg {
 #define RK805_INT_ALARM_EN		(1 << 3)
 #define RK805_INT_TIMER_EN		(1 << 2)
 
+#define RK805_SLP_LDO_EN_OFFSET		-1
+#define RK805_SLP_DCDC_EN_OFFSET	2
+
+#define RK805_RAMP_RATE_OFFSET		3
+#define RK805_RAMP_RATE_MASK		(3 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_3MV_PER_US	(0 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_6MV_PER_US	(1 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_12_5MV_PER_US	(2 << RK805_RAMP_RATE_OFFSET)
+#define RK805_RAMP_RATE_25MV_PER_US	(3 << RK805_RAMP_RATE_OFFSET)
+
 /* RK808 IRQ Definitions */
 #define RK808_IRQ_VOUT_LO	0
 #define RK808_IRQ_VB_LO		1
@@ -348,6 +674,107 @@ enum rk805_reg {
 
 #define RK818_NUM_IRQ		16
 
+/*RK818_DCDC_EN_REG*/
+#define BUCK1_EN_MASK		BIT(0)
+#define BUCK2_EN_MASK		BIT(1)
+#define BUCK3_EN_MASK		BIT(2)
+#define BUCK4_EN_MASK		BIT(3)
+#define BOOST_EN_MASK		BIT(4)
+#define LDO9_EN_MASK		BIT(5)
+#define SWITCH_EN_MASK		BIT(6)
+#define OTG_EN_MASK		BIT(7)
+
+#define BUCK1_EN_ENABLE		BIT(0)
+#define BUCK2_EN_ENABLE		BIT(1)
+#define BUCK3_EN_ENABLE		BIT(2)
+#define BUCK4_EN_ENABLE		BIT(3)
+#define BOOST_EN_ENABLE		BIT(4)
+#define LDO9_EN_ENABLE		BIT(5)
+#define SWITCH_EN_ENABLE	BIT(6)
+#define OTG_EN_ENABLE		BIT(7)
+
+#define BUCK1_SLP_SET_MASK	BIT(0)
+#define BUCK2_SLP_SET_MASK	BIT(1)
+#define BUCK3_SLP_SET_MASK	BIT(2)
+#define BUCK4_SLP_SET_MASK	BIT(3)
+#define BOOST_SLP_SET_MASK	BIT(4)
+#define LDO9_SLP_SET_MASK	BIT(5)
+#define SWITCH_SLP_SET_MASK	BIT(6)
+#define OTG_SLP_SET_MASK	BIT(7)
+
+#define BUCK1_SLP_SET_OFF	BIT(0)
+#define BUCK2_SLP_SET_OFF	BIT(1)
+#define BUCK3_SLP_SET_OFF	BIT(2)
+#define BUCK4_SLP_SET_OFF	BIT(3)
+#define BOOST_SLP_SET_OFF	BIT(4)
+#define LDO9_SLP_SET_OFF	BIT(5)
+#define SWITCH_SLP_SET_OFF	BIT(6)
+#define OTG_SLP_SET_OFF		BIT(7)
+#define OTG_BOOST_SLP_OFF	(BOOST_SLP_SET_OFF | OTG_SLP_SET_OFF)
+
+#define BUCK1_SLP_SET_ON	BIT(0)
+#define BUCK2_SLP_SET_ON	BIT(1)
+#define BUCK3_SLP_SET_ON	BIT(2)
+#define BUCK4_SLP_SET_ON	BIT(3)
+#define BOOST_SLP_SET_ON	BIT(4)
+#define LDO9_SLP_SET_ON		BIT(5)
+#define SWITCH_SLP_SET_ON	BIT(6)
+#define OTG_SLP_SET_ON		BIT(7)
+
+#define VOUT_LO_MASK		BIT(0)
+#define VB_LO_MASK		BIT(1)
+#define PWRON_MASK		BIT(2)
+#define PWRON_LP_MASK		BIT(3)
+#define HOTDIE_MASK		BIT(4)
+#define RTC_ALARM_MASK		BIT(5)
+#define RTC_PERIOD_MASK		BIT(6)
+#define USB_OV_MASK		BIT(7)
+
+#define VOUT_LO_DISABLE		BIT(0)
+#define VB_LO_DISABLE		BIT(1)
+#define PWRON_DISABLE		BIT(2)
+#define PWRON_LP_DISABLE	BIT(3)
+#define HOTDIE_DISABLE		BIT(4)
+#define RTC_ALARM_DISABLE	BIT(5)
+#define RTC_PERIOD_DISABLE	BIT(6)
+#define USB_OV_INT_DISABLE	BIT(7)
+
+#define VOUT_LO_ENABLE		(0 << 0)
+#define VB_LO_ENABLE		(0 << 1)
+#define PWRON_ENABLE		(0 << 2)
+#define PWRON_LP_ENABLE		(0 << 3)
+#define HOTDIE_ENABLE		(0 << 4)
+#define RTC_ALARM_ENABLE	(0 << 5)
+#define RTC_PERIOD_ENABLE	(0 << 6)
+#define USB_OV_INT_ENABLE	(0 << 7)
+
+#define PLUG_IN_MASK		BIT(0)
+#define PLUG_OUT_MASK		BIT(1)
+#define CHGOK_MASK		BIT(2)
+#define CHGTE_MASK		BIT(3)
+#define CHGTS1_MASK		BIT(4)
+#define TS2_MASK		BIT(5)
+#define CHG_CVTLIM_MASK		BIT(6)
+#define DISCHG_ILIM_MASK	BIT(7)
+
+#define PLUG_IN_DISABLE		BIT(0)
+#define PLUG_OUT_DISABLE	BIT(1)
+#define CHGOK_DISABLE		BIT(2)
+#define CHGTE_DISABLE		BIT(3)
+#define CHGTS1_DISABLE		BIT(4)
+#define TS2_DISABLE		BIT(5)
+#define CHG_CVTLIM_DISABLE	BIT(6)
+#define DISCHG_ILIM_DISABLE	BIT(7)
+
+#define PLUG_IN_ENABLE		BIT(0)
+#define PLUG_OUT_ENABLE		BIT(1)
+#define CHGOK_ENABLE		BIT(2)
+#define CHGTE_ENABLE		BIT(3)
+#define CHGTS1_ENABLE		BIT(4)
+#define TS2_ENABLE		BIT(5)
+#define CHG_CVTLIM_ENABLE	BIT(6)
+#define DISCHG_ILIM_ENABLE	BIT(7)
+
 #define RK808_VBAT_LOW_2V8	0x00
 #define RK808_VBAT_LOW_2V9	0x01
 #define RK808_VBAT_LOW_3V0	0x02
@@ -381,7 +808,10 @@ enum rk805_reg {
 
 #define VOUT_LO_INT	BIT(0)
 #define CLK32KOUT2_EN	BIT(0)
+#define CLK32KOUT2_FUNC		(0 << 1)
+#define CLK32KOUT2_FUNC_MASK	BIT(1)
 
+#define TEMP105C			0x08
 #define TEMP115C			0x0c
 #define TEMP_HOTDIE_MSK			0x0c
 #define SLP_SD_MSK			(0x3 << 2)
@@ -391,6 +821,7 @@ enum rk805_reg {
 #define PWM_MODE_MSK			BIT(7)
 #define FPWM_MODE			BIT(7)
 #define AUTO_PWM_MODE			0
+#define REGS_WMSK			0xf0
 
 enum rk817_reg_id {
 	RK817_ID_DCDC1 = 0,
@@ -436,6 +867,10 @@ enum rk809_reg_id {
 #define RK817_RTC_INT_REG		0xf
 #define RK817_RTC_COMP_LSB_REG		0x10
 #define RK817_RTC_COMP_MSB_REG		0x11
+#define RK817_ADC_CONFIG0		0x50
+#define RK817_CURE_ADC_K0		0xb0
+#define RK817_POWER_EN_SAVE0            0x99
+#define RK817_POWER_EN_SAVE1            0xa4
 
 #define RK817_POWER_EN_REG(i)		(0xb1 + (i))
 #define RK817_POWER_SLP_EN_REG(i)	(0xb5 + (i))
@@ -462,6 +897,9 @@ enum rk809_reg_id {
 #define RK817_LDO_ON_VSEL_REG(idx)	(0xcc + (idx) * 2)
 #define RK817_BOOST_OTG_CFG		(0xde)
 
+#define RK817_CHRG_OUT			0xe4
+#define RK817_CHRG_IN			0xe5
+#define RK817_CHRG_STS			0xeb
 #define RK817_ID_MSB			0xed
 #define RK817_ID_LSB			0xee
 
@@ -609,16 +1047,27 @@ enum {
 	RK805_ID = 0x8050,
 	RK808_ID = 0x0000,
 	RK809_ID = 0x8090,
+	RK816_ID = 0x8160,
 	RK817_ID = 0x8170,
 	RK818_ID = 0x8180,
 };
 
+struct rk808_pin_info {
+	struct pinctrl *p;
+	struct pinctrl_state *reset;
+	struct pinctrl_state *power_off;
+	struct pinctrl_state *sleep;
+};
+
 struct rk808 {
 	struct i2c_client		*i2c;
 	struct regmap_irq_chip_data	*irq_data;
+	struct regmap_irq_chip_data	*battery_irq_data;
 	struct regmap			*regmap;
 	long				variant;
 	const struct regmap_config	*regmap_cfg;
 	const struct regmap_irq_chip	*regmap_irq_chip;
+	void				(*pm_pwroff_prep_fn)(void);
+	struct rk808_pin_info *pins;
 };
 #endif /* __LINUX_REGULATOR_RK808_H */
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 40d7e98fc..819f6119d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -141,6 +141,7 @@ struct mmc_host_ops {
 
 	/* Check if the card is pulling dat[0:3] low */
 	int	(*card_busy)(struct mmc_host *host);
+	int     (*set_sdio_status)(struct mmc_host *host, int val);
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
@@ -483,6 +484,9 @@ void mmc_free_host(struct mmc_host *);
 int mmc_of_parse(struct mmc_host *host);
 int mmc_of_parse_voltage(struct device_node *np, u32 *mask);
 
+extern struct mmc_host *primary_sdio_host;
+int mmc_host_rescan(struct mmc_host *host, int val, int is_cap_sdio_irq);
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
diff --git a/include/linux/mmu_context.h b/include/linux/mmu_context.h
index 03dee12d2..bc4ac3c52 100644
--- a/include/linux/mmu_context.h
+++ b/include/linux/mmu_context.h
@@ -14,4 +14,12 @@
 static inline void leave_mm(int cpu) { }
 #endif
 
+/*
+ * CPUs that are capable of running task @p. By default, we assume a sane,
+ * homogeneous system. Must contain at least one active CPU.
+ */
+#ifndef task_cpu_possible_mask
+# define task_cpu_possible_mask(p)	cpu_possible_mask
+#endif
+
 #endif
diff --git a/include/linux/phy/pcie.h b/include/linux/phy/pcie.h
new file mode 100644
index 000000000..93c997f52
--- /dev/null
+++ b/include/linux/phy/pcie.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+#ifndef __PHY_PCIE_H
+#define __PHY_PCIE_H
+
+#define PHY_MODE_PCIE_RC 20
+#define PHY_MODE_PCIE_EP 21
+#define PHY_MODE_PCIE_BIFURCATION 22
+
+#endif
diff --git a/include/linux/phy/phy-rockchip-typec.h b/include/linux/phy/phy-rockchip-typec.h
new file mode 100644
index 000000000..1d6af83d3
--- /dev/null
+++ b/include/linux/phy/phy-rockchip-typec.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#ifndef __PHY_ROCKCHIP_TYPEC_H
+#define __PHY_ROCKCHIP_TYPEC_H
+
+#if IS_ENABLED(CONFIG_PHY_ROCKCHIP_TYPEC)
+int tcphy_dp_set_phy_config(struct phy *phy, int link_rate, int lanes,
+			    u8 swing, u8 pre_emp);
+int tcphy_dp_set_lane_count(struct phy *phy, u8 lane_count);
+int tcphy_dp_set_link_rate(struct phy *phy, int link_rate, bool ssc_on);
+#else
+static inline int tcphy_dp_set_phy_config(struct phy *phy, int link_rate,
+					  int lanes, u8 swing, u8 pre_emp)
+{
+	return -ENODEV;
+}
+
+static inline int tcphy_dp_set_lane_count(struct phy *phy, u8 lane_count)
+{
+	return -ENODEV;
+}
+
+static inline int tcphy_dp_set_link_rate(struct phy *phy, int link_rate,
+					 bool ssc_on)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif
diff --git a/include/linux/phy/phy-rockchip-usbdp.h b/include/linux/phy/phy-rockchip-usbdp.h
new file mode 100644
index 000000000..6a65a1596
--- /dev/null
+++ b/include/linux/phy/phy-rockchip-usbdp.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip USBDP Combo PHY with Samsung IP block driver
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __PHY_ROCKCHIP_USBDP_H_
+#define __PHY_ROCKCHIP_USBDP_H_
+
+#include <linux/bits.h>
+
+/* RK3588 USBDP PHY Register Definitions */
+
+#define UDPHY_PCS				0x4000
+#define UDPHY_PMA				0x8000
+
+/* VO0 GRF Registers */
+#define RK3588_GRF_VO0_CON0			0x0000
+#define RK3588_GRF_VO0_CON2			0x0008
+#define DP_SINK_HPD_CFG				BIT(11)
+#define DP_SINK_HPD_SEL				BIT(10)
+#define DP_AUX_DIN_SEL				BIT(9)
+#define DP_AUX_DOUT_SEL				BIT(8)
+#define DP_LANE_SEL_N(n)			GENMASK(2 * (n) + 1, 2 * (n))
+#define DP_LANE_SEL_ALL				GENMASK(7, 0)
+#define PHY_AUX_DP_DATA_POL_NORMAL		0
+#define PHY_AUX_DP_DATA_POL_INVERT		1
+
+/* PMA CMN Registers */
+#define CMN_LANE_MUX_AND_EN_OFFSET		0x0288	/* cmn_reg00A2 */
+#define CMN_DP_LANE_MUX_N(n)			BIT((n) + 4)
+#define CMN_DP_LANE_EN_N(n)			BIT(n)
+#define CMN_DP_LANE_MUX_ALL			GENMASK(7, 4)
+#define CMN_DP_LANE_EN_ALL			GENMASK(3, 0)
+#define PHY_LANE_MUX_USB			0
+#define PHY_LANE_MUX_DP				1
+
+#define CMN_DP_LINK_OFFSET			0x28c	/*cmn_reg00A3 */
+#define CMN_DP_TX_LINK_BW			GENMASK(6, 5)
+#define CMN_DP_TX_LANE_SWAP_EN			BIT(2)
+
+#define CMN_SSC_EN_OFFSET			0x2d0	/* cmn_reg00B4 */
+#define CMN_ROPLL_SSC_EN			BIT(1)
+#define CMN_LCPLL_SSC_EN			BIT(0)
+
+#define CMN_ANA_LCPLL_DONE_OFFSET		0x0350	/* cmn_reg00D4 */
+#define CMN_ANA_LCPLL_LOCK_DONE			BIT(7)
+#define CMN_ANA_LCPLL_AFC_DONE			BIT(6)
+
+#define CMN_ANA_ROPLL_DONE_OFFSET		0x0354	/* cmn_reg00D5 */
+#define CMN_ANA_ROPLL_LOCK_DONE			BIT(1)
+#define CMN_ANA_ROPLL_AFC_DONE			BIT(0)
+
+#define CMN_DP_RSTN_OFFSET			0x038c	/* cmn_reg00E3 */
+#define CMN_DP_INIT_RSTN			BIT(3)
+#define CMN_DP_CMN_RSTN				BIT(2)
+#define CMN_CDR_WTCHDG_EN			BIT(1)
+#define CMN_CDR_WTCHDG_MSK_CDR_EN		BIT(0)
+
+#define TRSV_ANA_TX_CLK_OFFSET_N(n)		(0x854 + (n) * 0x800)	/* trsv_reg0215 */
+#define LN_ANA_TX_SER_TXCLK_INV			BIT(1)
+
+#define TRSV_LN0_MON_RX_CDR_DONE_OFFSET		0x0b84	/* trsv_reg02E1 */
+#define TRSV_LN0_MON_RX_CDR_LOCK_DONE		BIT(0)
+
+#define TRSV_LN2_MON_RX_CDR_DONE_OFFSET		0x1b84	/* trsv_reg06E1 */
+#define TRSV_LN2_MON_RX_CDR_LOCK_DONE		BIT(0)
+
+#endif
diff --git a/include/linux/power/bq25700-charge.h b/include/linux/power/bq25700-charge.h
new file mode 100644
index 000000000..5e7d3e40d
--- /dev/null
+++ b/include/linux/power/bq25700-charge.h
@@ -0,0 +1,20 @@
+/*
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CHARGER_BQ25700_H_
+#define __CHARGER_BQ25700_H_
+
+#define CHARGER_CURRENT_EVENT	0x01
+#define INPUT_CURRENT_EVENT	0x02
+
+void bq25700_charger_set_current(unsigned long event, int current_value);
+
+#endif /* __CHARGER_BQ25700_H_ */
diff --git a/include/linux/power/cw2015_battery.h b/include/linux/power/cw2015_battery.h
new file mode 100644
index 000000000..8e6b1fc7e
--- /dev/null
+++ b/include/linux/power/cw2015_battery.h
@@ -0,0 +1,119 @@
+/*
+ * Fuel gauge driver for CellWise 2013 / 2015
+ *
+ * Copyright (C) 2012, RockChip
+ *
+ * Authors: xuhuicong <xhc@rock-chips.com>
+ *
+ * Based on rk30_adc_battery.c
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CW2015_BATTERY_H
+#define CW2015_BATTERY_H
+
+#define SIZE_BATINFO    64
+
+#define CW2015_GPIO_HIGH  1
+#define CW2015_GPIO_LOW   0
+
+#define REG_VERSION             0x0
+#define REG_VCELL               0x2
+#define REG_SOC                 0x4
+#define REG_RRT_ALERT           0x6
+#define REG_CONFIG              0x8
+#define REG_MODE                0xA
+#define REG_BATINFO             0x10
+
+#define MODE_SLEEP_MASK         (0x3<<6)
+#define MODE_SLEEP              (0x3<<6)
+#define MODE_NORMAL             (0x0<<6)
+#define MODE_QUICK_START        (0x3<<4)
+#define MODE_RESTART            (0xf<<0)
+
+#define CONFIG_UPDATE_FLG       (0x1<<1)
+#define ATHD                    (0x0<<3)
+
+#define CW_I2C_SPEED			100000
+#define BATTERY_UP_MAX_CHANGE		(420 * 1000)
+#define BATTERY_DOWN_MAX_CHANGE		(120 * 1000)
+#define BATTERY_DOWN_CHANGE		60
+#define BATTERY_DOWN_MIN_CHANGE_RUN	30
+#define BATTERY_DOWN_MIN_CHANGE_SLEEP	1800
+#define BATTERY_JUMP_TO_ZERO		(30 * 1000)
+#define BATTERY_CAPACITY_ERROR		(40 * 1000)
+#define BATTERY_CHARGING_ZERO		(1800 * 1000)
+
+#define DOUBLE_SERIES_BATTERY	0
+
+#define CHARGING_ON		1
+#define NO_CHARGING		0
+
+#define BATTERY_DOWN_MAX_CHANGE_RUN_AC_ONLINE 3600
+
+#define NO_STANDARD_AC_BIG_CHARGE_MODE 1
+/* #define SYSTEM_SHUTDOWN_VOLTAGE  3400000 */
+#define BAT_LOW_INTERRUPT    1
+
+#define USB_CHARGER_MODE        1
+#define AC_CHARGER_MODE         2
+#define   CW_QUICKSTART         0
+
+#define TIMER_MS_COUNTS			1000
+#define DEFAULT_MONITOR_SEC		8
+
+/* virtual params */
+#define VIRTUAL_CURRENT			1000
+#define VIRTUAL_VOLTAGE			3888
+#define VIRTUAL_SOC			66
+#define VIRTUAL_PRESET			1
+#define VIRTUAL_TEMPERATURE		188
+#define VIRTUAL_TIME2EMPTY		60
+#define VIRTUAL_STATUS			POWER_SUPPLY_STATUS_CHARGING
+
+enum bat_mode {
+	MODE_BATTARY = 0,
+	MODE_VIRTUAL,
+};
+
+struct cw_bat_platform_data {
+	int divider_res1;
+	int divider_res2;
+	u32 *cw_bat_config_info;
+	int design_capacity;
+};
+
+struct cw_battery {
+	struct i2c_client *client;
+	struct workqueue_struct *battery_workqueue;
+	struct delayed_work battery_delay_work;
+	struct cw_bat_platform_data plat_data;
+
+	struct power_supply *rk_bat;
+
+	struct power_supply *chrg_usb_psy;
+	struct power_supply *chrg_ac_psy;
+
+#ifdef CONFIG_PM
+	struct timespec suspend_time_before;
+	struct timespec after;
+	int suspend_resume_mark;
+#endif
+	int charger_mode;
+	int capacity;
+	int voltage;
+	int status;
+	int time_to_empty;
+	int alt;
+	u32 monitor_sec;
+	u32 bat_mode;
+	int bat_change;
+	bool dual_battery;
+	int charge_count;
+};
+
+#endif
diff --git a/include/linux/power/rk_usbbc.h b/include/linux/power/rk_usbbc.h
new file mode 100644
index 000000000..45f7128b3
--- /dev/null
+++ b/include/linux/power/rk_usbbc.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK_USBBC_H
+#define __RK_USBBC_H
+
+/* USB Charger Types */
+enum bc_port_type{
+	USB_BC_TYPE_DISCNT = 0,
+	USB_BC_TYPE_SDP,
+	USB_BC_TYPE_DCP,
+	USB_BC_TYPE_CDP,
+	USB_BC_TYPE_UNKNOW,
+	USB_OTG_POWER_ON,
+	USB_OTG_POWER_OFF,
+	USB_BC_TYPE_MAX,
+};
+
+/***********************************
+ * USB Port Type
+ * 0 : Disconnect
+ * 1 : SDP - pc
+ * 2 : DCP - charger
+ * 3 : CDP - pc with big currect charge
+ ************************************/
+#ifdef CONFIG_DWC_OTG_310
+extern int dwc_otg_check_dpdm(bool wait);
+extern int rk_bc_detect_notifier_register(struct notifier_block *nb,
+					  enum bc_port_type *type);
+extern int rk_bc_detect_notifier_unregister(struct notifier_block *nb);
+#else
+static inline int dwc_otg_check_dpdm(bool wait) { return USB_BC_TYPE_DISCNT; }
+
+static inline int rk_bc_detect_notifier_register(struct notifier_block *nb,
+						 enum bc_port_type *type)
+{
+	return -EINVAL;
+}
+
+static inline int rk_bc_detect_notifier_unregister(struct notifier_block *nb)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index 81a55e974..aefa0b0bc 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -49,6 +49,12 @@ enum {
 	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE,	/* dynamically adjusted speed */
 	POWER_SUPPLY_CHARGE_TYPE_CUSTOM,	/* use CHARGE_CONTROL_* props */
 	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE,	/* slow speed, longer life */
+
+	/*
+	 * force to 50 to minimize the chances of userspace binary
+	 * incompatibility on newer upstream kernels
+	 */
+	POWER_SUPPLY_CHARGE_TYPE_TAPER = 50,	/* charging in CV phase */
 };
 
 enum {
@@ -386,12 +392,22 @@ extern void power_supply_put(struct power_supply *psy);
 #ifdef CONFIG_OF
 extern struct power_supply *power_supply_get_by_phandle(struct device_node *np,
 							const char *property);
+extern int power_supply_get_by_phandle_array(struct device_node *np,
+					     const char *property,
+					     struct power_supply **psy,
+					     ssize_t size);
 extern struct power_supply *devm_power_supply_get_by_phandle(
 				    struct device *dev, const char *property);
 #else /* !CONFIG_OF */
 static inline struct power_supply *
 power_supply_get_by_phandle(struct device_node *np, const char *property)
 { return NULL; }
+static inline int
+power_supply_get_by_phandle_array(struct device_node *np,
+				  const char *property,
+				  struct power_supply **psy,
+				  int size)
+{ return 0; }
 static inline struct power_supply *
 devm_power_supply_get_by_phandle(struct device *dev, const char *property)
 { return NULL; }
@@ -426,9 +442,16 @@ static inline int power_supply_is_system_supplied(void) { return -ENOSYS; }
 extern int power_supply_get_property(struct power_supply *psy,
 			    enum power_supply_property psp,
 			    union power_supply_propval *val);
+#if IS_ENABLED(CONFIG_POWER_SUPPLY)
 extern int power_supply_set_property(struct power_supply *psy,
 			    enum power_supply_property psp,
 			    const union power_supply_propval *val);
+#else
+static inline int power_supply_set_property(struct power_supply *psy,
+			    enum power_supply_property psp,
+			    const union power_supply_propval *val)
+{ return 0; }
+#endif
 extern int power_supply_property_is_writeable(struct power_supply *psy,
 					enum power_supply_property psp);
 extern void power_supply_external_power_changed(struct power_supply *psy);
diff --git a/include/linux/psi_types.h b/include/linux/psi_types.h
index b95f32115..4b73f0f19 100644
--- a/include/linux/psi_types.h
+++ b/include/linux/psi_types.h
@@ -157,6 +157,7 @@ struct psi_group {
 	struct timer_list poll_timer;
 	wait_queue_head_t poll_wait;
 	atomic_t poll_wakeup;
+	atomic_t poll_scheduled;
 
 	/* Protects data used by the monitor */
 	struct mutex trigger_lock;
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index a13ff383f..6b2a7fb80 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -59,6 +59,9 @@ struct pwm_state {
 	u64 period;
 	u64 duty_cycle;
 	enum pwm_polarity polarity;
+#ifdef CONFIG_PWM_ROCKCHIP_ONESHOT
+	u64 oneshot_count;
+#endif /* CONFIG_PWM_ROCKCHIP_ONESHOT */
 	bool enabled;
 };
 
diff --git a/include/linux/reboot.h b/include/linux/reboot.h
index 3734cd8f3..1c8d7856c 100644
--- a/include/linux/reboot.h
+++ b/include/linux/reboot.h
@@ -49,6 +49,26 @@ extern int register_restart_handler(struct notifier_block *);
 extern int unregister_restart_handler(struct notifier_block *);
 extern void do_kernel_restart(char *cmd);
 
+#ifdef CONFIG_NO_GKI
+extern int register_pre_restart_handler(struct notifier_block *nb);
+extern int unregister_pre_restart_handler(struct notifier_block *nb);
+extern void do_kernel_pre_restart(char *cmd);
+#else
+static inline int register_pre_restart_handler(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline int unregister_pre_restart_handler(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline void do_kernel_pre_restart(char *cmd)
+{
+}
+#endif
+
 /*
  * Architecture-specific implementations of sys_reboot commands.
  */
diff --git a/include/linux/regulator/driver.h b/include/linux/regulator/driver.h
index 11cade737..d7c77ee37 100644
--- a/include/linux/regulator/driver.h
+++ b/include/linux/regulator/driver.h
@@ -223,6 +223,8 @@ enum regulator_type {
  * @name: Identifying name for the regulator.
  * @supply_name: Identifying the regulator supply
  * @of_match: Name used to identify regulator in DT.
+ * @of_match_full_name: A flag to indicate that the of_match string, if
+ *			present, should be matched against the node full_name.
  * @regulators_node: Name of node containing regulator definitions in DT.
  * @of_parse_cb: Optional callback called only if of_match is present.
  *               Will be called for each regulator parsed from DT, during
@@ -314,6 +316,7 @@ struct regulator_desc {
 	const char *name;
 	const char *supply_name;
 	const char *of_match;
+	bool of_match_full_name;
 	const char *regulators_node;
 	int (*of_parse_cb)(struct device_node *,
 			    const struct regulator_desc *,
diff --git a/include/linux/regulator/fan53555.h b/include/linux/regulator/fan53555.h
index ce8df2186..e8703b6fc 100644
--- a/include/linux/regulator/fan53555.h
+++ b/include/linux/regulator/fan53555.h
@@ -52,6 +52,8 @@ struct fan53555_platform_data {
 	unsigned int slew_rate;
 	/* Sleep VSEL ID */
 	unsigned int sleep_vsel_id;
+	int limit_volt;
+	struct gpio_desc *vsel_gpio;
 };
 
 #endif /* __FAN53555_H__ */
diff --git a/include/linux/rfkill-bt.h b/include/linux/rfkill-bt.h
new file mode 100644
index 000000000..f3f5c5918
--- /dev/null
+++ b/include/linux/rfkill-bt.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2011, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+#ifndef __RFKILL_GPIO_H
+#define __RFKILL_GPIO_H
+
+#include <linux/types.h>
+#include <linux/rfkill.h>
+#include <linux/clk.h>
+
+#define RFKILL_RK_GPIO_NAME_SIZE   64
+
+//struct rfkill_rk_iomux {
+//    char    *name;
+//    int     fgpio;
+//    int     fmux;
+//};
+
+struct rfkill_rk_gpio {
+    int     io;
+    char    name[RFKILL_RK_GPIO_NAME_SIZE];
+    int     enable; // disable = !enable
+    struct  pinctrl_state    *gpio_state;
+    struct  pinctrl_state    *default_state;
+};
+
+struct rfkill_rk_irq {
+    char                    name[RFKILL_RK_GPIO_NAME_SIZE];
+    struct rfkill_rk_gpio   gpio;
+    int                     irq;
+};
+
+/**
+ * struct rfkill_rk_platform_data - platform data for rfkill gpio device.
+ * for unused gpio's, the expected value is -1.
+ * @name:               name for the gpio rf kill instance
+ * @reset_gpio:         GPIO which is used for reseting rfkill switch
+ * @shutdown_gpio:      GPIO which is used for shutdown of rfkill switch
+ */
+
+struct rfkill_rk_platform_data {
+    char                    *name;
+    enum rfkill_type        type;
+    bool                    power_toggle;
+    struct pinctrl          *pinctrl;
+    struct rfkill_rk_gpio   poweron_gpio;
+    struct rfkill_rk_gpio   reset_gpio;
+    struct rfkill_rk_gpio   wake_gpio;      // Host wake or sleep BT
+    struct rfkill_rk_irq    wake_host_irq;  // BT wakeup host
+    struct rfkill_rk_gpio   rts_gpio;
+    struct clk              *ext_clk;
+};
+
+int rfkill_get_bt_power_state(int *power, bool *toggle);
+
+#endif /* __RFKILL_GPIO_H */
diff --git a/include/linux/rfkill-wlan.h b/include/linux/rfkill-wlan.h
new file mode 100644
index 000000000..ff1503969
--- /dev/null
+++ b/include/linux/rfkill-wlan.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PLAT_BOARD_H
+#define __PLAT_BOARD_H
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+
+struct rksdmmc_iomux {
+    char    *name;  //set the MACRO of gpio
+    int     fgpio;
+    int     fmux;
+};
+
+struct rksdmmc_gpio {
+    int     io;                             //set the address of gpio
+    char    name[64];   //
+    int     enable;  // disable = !enable   //set the default value,i.e,GPIO_HIGH or GPIO_LOW
+    struct rksdmmc_iomux  iomux;
+};
+
+struct rksdmmc_pmu {
+    bool power_ctrl_by_pmu;
+    char pmu_regulator[20];
+    int  enable;
+};
+
+struct rksdmmc_gpio_wifi_moudle {
+    int sdio_vol;    //sdio reference voltage
+    bool vref_ctrl_enble;
+    bool wifi_power_remain;
+    struct rksdmmc_pmu    mregulator;
+    struct rksdmmc_pmu    ioregulator;
+    struct rksdmmc_gpio   vbat_n;
+    struct rksdmmc_gpio   power_n;  //PMU_EN
+    struct rksdmmc_gpio   reset_n;  //SYSRET_B, DAIRST
+    struct rksdmmc_gpio   vddio;
+    struct rksdmmc_gpio   bgf_int_b;
+    struct rksdmmc_gpio   wifi_int_b;
+    struct rksdmmc_gpio   gps_sync;
+    struct rksdmmc_gpio   ANTSEL2;  //pin5--ANTSEL2
+    struct rksdmmc_gpio   ANTSEL3;  //pin6--ANTSEL3
+    struct rksdmmc_gpio   GPS_LAN;  //pin33--GPS_LAN
+    struct regmap *grf;
+	struct clk *ext_clk;
+};
+
+int rfkill_get_wifi_power_state(int *power);
+void *rockchip_mem_prealloc(int section, unsigned long size);
+int rfkill_set_wifi_bt_power(int on);
+int rockchip_wifi_power(int on);
+int rockchip_wifi_set_carddetect(int val);
+int rockchip_wifi_get_oob_irq(void);
+int rockchip_wifi_get_oob_irq_flag(void);
+int rockchip_wifi_reset(int on);
+int rockchip_wifi_mac_addr(unsigned char *buf);
+void *rockchip_wifi_country_code(char *ccode);
+int rfkill_wlan_init(void);
+void rfkill_wlan_exit(void);
+
+#endif
diff --git a/include/linux/rk_keys.h b/include/linux/rk_keys.h
new file mode 100644
index 000000000..aee656daf
--- /dev/null
+++ b/include/linux/rk_keys.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _RK_KEYS_H
+#define _RK_KEYS_H
+
+#ifdef CONFIG_KEYBOARD_ROCKCHIP
+void rk_send_power_key(int state);
+void rk_send_wakeup_key(void);
+#else
+static inline void rk_send_power_key(int state) { }
+static inline void rk_send_wakeup_key(void) { }
+#endif
+
+#endif
diff --git a/include/linux/rockchip-iovmm.h b/include/linux/rockchip-iovmm.h
new file mode 100644
index 000000000..3005c745e
--- /dev/null
+++ b/include/linux/rockchip-iovmm.h
@@ -0,0 +1,91 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_PLAT_IOVMM_H
+#define __ASM_PLAT_IOVMM_H
+
+#include <linux/list.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+
+#define IEP_IOMMU_COMPATIBLE_NAME "rockchip,iep_mmu"
+#define VIP_IOMMU_COMPATIBLE_NAME "rockchip,vip_mmu"
+#define ISP_IOMMU_COMPATIBLE_NAME "rockchip,isp_mmu"
+#define ISP0_IOMMU_COMPATIBLE_NAME "rockchip,isp0_mmu"
+#define ISP1_IOMMU_COMPATIBLE_NAME "rockchip,isp1_mmu"
+#define VOPB_IOMMU_COMPATIBLE_NAME "rockchip,vopb_mmu"
+#define VOPL_IOMMU_COMPATIBLE_NAME "rockchip,vopl_mmu"
+#define VOP_IOMMU_COMPATIBLE_NAME	"rockchip,vop_mmu"
+#define HEVC_IOMMU_COMPATIBLE_NAME "rockchip,hevc_mmu"
+#define VPU_IOMMU_COMPATIBLE_NAME "rockchip,vpu_mmu"
+#define VDEC_IOMMU_COMPATIBLE_NAME "rockchip,vdec_mmu"
+
+enum rk_iommu_inttype {
+	IOMMU_PAGEFAULT,
+	IOMMU_BUSERROR,
+	IOMMU_FAULT_UNKNOWN,
+	IOMMU_FAULTS_NUM
+};
+
+struct iommu_drvdata;
+
+/*
+ * @itype: type of fault.
+ * @pgtable_base: the physical address of page table base. This is 0 if @itype
+ *				  is IOMMU_BUSERROR.
+ * @fault_addr: the device (virtual) address that the System MMU tried to
+ *			   translated. This is 0 if @itype is IOMMU_BUSERROR.
+ */
+typedef int (*rockchip_iommu_fault_handler_t)(struct device *dev,
+					  enum rk_iommu_inttype itype,
+					  unsigned long pgtable_base,
+					  unsigned long fault_addr,
+					  unsigned int statu
+					  );
+
+
+struct scatterlist;
+struct device;
+
+static inline int rockchip_iovmm_activate(struct device *dev)
+{
+	return -ENOSYS;
+}
+
+static inline void rockchip_iovmm_deactivate(struct device *dev)
+{
+}
+
+static inline dma_addr_t rockchip_iovmm_map(struct device *dev,
+			struct scatterlist *sg, off_t offset, size_t size)
+{
+	return -ENOSYS;
+}
+
+static inline void rockchip_iovmm_unmap(struct device *dev, dma_addr_t iova)
+{
+}
+
+static inline int rockchip_iovmm_map_oto(struct device *dev, phys_addr_t phys,
+				size_t size)
+{
+	return -ENOSYS;
+}
+
+static inline void rockchip_iovmm_unmap_oto(struct device *dev, phys_addr_t phys)
+{
+}
+
+static inline void rockchip_iovmm_set_fault_handler(struct device *dev,
+				       rockchip_iommu_fault_handler_t handler)
+{
+}
+static inline int rockchip_iovmm_invalidate_tlb(struct device *dev)
+{
+	return -ENOSYS;
+}
+
+#endif /*__ASM_PLAT_IOVMM_H*/
diff --git a/include/linux/rockchip/cpu.h b/include/linux/rockchip/cpu.h
new file mode 100644
index 000000000..726e86edf
--- /dev/null
+++ b/include/linux/rockchip/cpu.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __LINUX_ROCKCHIP_CPU_H
+#define __LINUX_ROCKCHIP_CPU_H
+
+#include <linux/of.h>
+#define ROCKCHIP_CPU_MASK		0xffff0000
+#define ROCKCHIP_CPU_SHIFT		16
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_CPUINFO)
+
+extern unsigned long rockchip_soc_id;
+
+#define ROCKCHIP_CPU_VERION_MASK	0x0000f000
+#define ROCKCHIP_CPU_VERION_SHIFT	12
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return (rockchip_soc_id & ROCKCHIP_CPU_VERION_MASK)
+		>> ROCKCHIP_CPU_VERION_SHIFT;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+	rockchip_soc_id &= ~ROCKCHIP_CPU_VERION_MASK;
+	rockchip_soc_id |=
+		(ver << ROCKCHIP_CPU_VERION_SHIFT) & ROCKCHIP_CPU_VERION_MASK;
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+	if (!code)
+		return;
+
+	rockchip_soc_id &= ~ROCKCHIP_CPU_MASK;
+	rockchip_soc_id |= (code << ROCKCHIP_CPU_SHIFT) & ROCKCHIP_CPU_MASK;
+}
+#else
+
+#define rockchip_soc_id 0
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return 0;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+}
+#endif
+
+#define ROCKCHIP_SOC(id, ID) \
+static inline bool soc_is_##id(void) \
+{ \
+	if (rockchip_soc_id) \
+		return ((rockchip_soc_id & ROCKCHIP_SOC_MASK) == ROCKCHIP_SOC_ ##ID); \
+	return of_machine_is_compatible("rockchip,"#id); \
+}
+
+#endif
diff --git a/include/linux/rockchip/psci.h b/include/linux/rockchip/psci.h
new file mode 100644
index 000000000..870da27ed
--- /dev/null
+++ b/include/linux/rockchip/psci.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_PSCI_H
+#define __ROCKCHIP_PSCI_H
+
+#define SEC_REG_RD (0x0)
+#define SEC_REG_WR (0x1)
+
+/*
+ * trust firmware verison
+ */
+#define RKTF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define RKTF_VER_MINOR(ver)		((ver) & 0xffff)
+
+/*
+ * pcsi smc funciton id
+ */
+#define PSCI_SIP_RKTF_VER		(0x82000001)
+#define PSCI_SIP_ACCESS_REG		(0x82000002)
+#define PSCI_SIP_ACCESS_REG64		(0xc2000002)
+#define PSCI_SIP_SUSPEND_WR_CTRBITS	(0x82000003)
+#define PSCI_SIP_PENDING_CPUS		(0x82000004)
+#define PSCI_SIP_UARTDBG_CFG		(0x82000005)
+#define PSCI_SIP_UARTDBG_CFG64		(0xc2000005)
+#define PSCI_SIP_EL3FIQ_CFG		(0x82000006)
+#define PSCI_SIP_SMEM_CONFIG		(0x82000007)
+
+/*
+ * pcsi smc funciton err code
+ */
+#define PSCI_SMC_FUNC_UNK		0xffffffff
+
+/*
+ * define PSCI_SIP_UARTDBG_CFG call type
+ */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+
+/*
+ * rockchip psci function call interface
+ */
+
+u32 rockchip_psci_smc_read(u32 function_id, u32 arg0, u32 arg1, u32 arg2,
+			   u32 *val);
+u32 rockchip_psci_smc_write(u32 function_id, u32 arg0, u32 arg1, u32 arg2);
+
+u32 rockchip_psci_smc_get_tf_ver(void);
+u32 rockchip_secure_reg_read(u32 addr_phy);
+u32 rockchip_secure_reg_write(u32 addr_phy, u32 val);
+
+#ifdef CONFIG_ARM64
+u32 rockchip_psci_smc_write64(u64 function_id, u64 arg0, u64 arg1, u64 arg2);
+u32 rockchip_psci_smc_read64(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
+			     u64 *val);
+u64 rockchip_secure_reg_read64(u64 addr_phy);
+u32 rockchip_secure_reg_write64(u64 addr_phy, u64 val);
+
+void psci_fiq_debugger_uart_irq_tf_cb(u64 sp_el1, u64 offset);
+#endif
+
+u32 psci_fiq_debugger_switch_cpu(u32 cpu);
+void psci_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback);
+void psci_fiq_debugger_enable_debug(bool val);
+
+#if defined(CONFIG_ARM_PSCI) || defined(CONFIG_ARM64)
+u32 psci_set_memory_secure(bool val);
+#else
+static inline u32 psci_set_memory_secure(bool val)
+{
+	return 0;
+}
+#endif
+
+#endif /* __ROCKCHIP_PSCI_H */
diff --git a/include/linux/rockchip/rockchip_sip.h b/include/linux/rockchip/rockchip_sip.h
new file mode 100644
index 000000000..104f42754
--- /dev/null
+++ b/include/linux/rockchip/rockchip_sip.h
@@ -0,0 +1,363 @@
+/* Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __ROCKCHIP_SIP_H
+#define __ROCKCHIP_SIP_H
+
+#include <linux/arm-smccc.h>
+#include <linux/io.h>
+
+/* SMC function IDs for SiP Service queries, compatible with kernel-3.10 */
+#define SIP_ATF_VERSION			0x82000001
+#define SIP_ACCESS_REG			0x82000002
+#define SIP_SUSPEND_MODE		0x82000003
+#define SIP_PENDING_CPUS		0x82000004
+#define SIP_UARTDBG_CFG			0x82000005
+#define SIP_UARTDBG_CFG64		0xc2000005
+#define SIP_MCU_EL3FIQ_CFG		0x82000006
+#define SIP_ACCESS_CHIP_STATE64		0xc2000006
+#define SIP_SECURE_MEM_CONFIG		0x82000007
+#define SIP_ACCESS_CHIP_EXTRA_STATE64	0xc2000007
+#define SIP_DRAM_CONFIG			0x82000008
+#define SIP_SHARE_MEM			0x82000009
+#define SIP_SIP_VERSION			0x8200000a
+#define SIP_REMOTECTL_CFG		0x8200000b
+#define PSCI_SIP_VPU_RESET		0x8200000c
+#define SIP_BUS_CFG			0x8200000d
+#define SIP_LAST_LOG			0x8200000e
+#define SIP_SCMI_AGENT0			0x82000010
+#define SIP_SCMI_AGENT1			0x82000011
+#define SIP_SCMI_AGENT2			0x82000012
+#define SIP_SCMI_AGENT3			0x82000013
+#define SIP_SCMI_AGENT4			0x82000014
+#define SIP_SCMI_AGENT5			0x82000015
+#define SIP_SCMI_AGENT6			0x82000016
+#define SIP_SCMI_AGENT7			0x82000017
+#define SIP_SCMI_AGENT8			0x82000018
+#define SIP_SCMI_AGENT9			0x82000019
+#define SIP_SCMI_AGENT10		0x8200001a
+#define SIP_SCMI_AGENT11		0x8200001b
+#define SIP_SCMI_AGENT12		0x8200001c
+#define SIP_SCMI_AGENT13		0x8200001d
+#define SIP_SCMI_AGENT14		0x8200001e
+#define SIP_SCMI_AGENT15		0x8200001f
+#define SIP_SDEI_FIQ_DBG_SWITCH_CPU	0x82000020
+#define SIP_SDEI_FIQ_DBG_GET_EVENT_ID	0x82000021
+#define RK_SIP_FIQ_CTRL			0x82000024
+
+/* Rockchip Sip version */
+#define SIP_IMPLEMENT_V1                (1)
+#define SIP_IMPLEMENT_V2                (2)
+
+/* Trust firmware version */
+#define ATF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define ATF_VER_MINOR(ver)		(((ver) >> 0) & 0xffff)
+
+/* SIP_ACCESS_REG: read or write */
+#define SECURE_REG_RD			0x0
+#define SECURE_REG_WR			0x1
+
+/* Fiq debugger share memory: 8KB enough */
+#define FIQ_UARTDBG_PAGE_NUMS		2
+#define FIQ_UARTDBG_SHARE_MEM_SIZE	((FIQ_UARTDBG_PAGE_NUMS) * 4096)
+
+/* Error return code */
+#define IS_SIP_ERROR(x)			(!!(x))
+
+#define SIP_RET_SUCCESS			0
+#define SIP_RET_SMC_UNKNOWN		-1
+#define SIP_RET_NOT_SUPPORTED		-2
+#define SIP_RET_INVALID_PARAMS		-3
+#define SIP_RET_INVALID_ADDRESS		-4
+#define SIP_RET_DENIED			-5
+#define SIP_RET_SET_RATE_TIMEOUT	-6
+
+/* SIP_UARTDBG_CFG64 call types */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+#define UARTDBG_CFG_PRINT_PORT		0xf7
+#define UARTDBG_CFG_FIQ_ENABEL		0xf8
+#define UARTDBG_CFG_FIQ_DISABEL		0xf9
+
+/* SIP_SUSPEND_MODE32 call types */
+#define SUSPEND_MODE_CONFIG		0x01
+#define WKUP_SOURCE_CONFIG		0x02
+#define PWM_REGULATOR_CONFIG		0x03
+#define GPIO_POWER_CONFIG		0x04
+#define SUSPEND_DEBUG_ENABLE		0x05
+#define APIOS_SUSPEND_CONFIG		0x06
+#define VIRTUAL_POWEROFF		0x07
+#define SUSPEND_WFI_TIME_MS		0x08
+#define LINUX_PM_STATE			0x09
+
+/* SIP_REMOTECTL_CFG call types */
+#define	REMOTECTL_SET_IRQ		0xf0
+#define REMOTECTL_SET_PWM_CH		0xf1
+#define REMOTECTL_SET_PWRKEY		0xf2
+#define REMOTECTL_GET_WAKEUP_STATE	0xf3
+#define REMOTECTL_ENABLE		0xf4
+/* wakeup state */
+#define REMOTECTL_PWRKEY_WAKEUP		0xdeadbeaf
+
+struct dram_addrmap_info {
+	u64 ch_mask[2];
+	u64 bk_mask[4];
+	u64 bg_mask[2];
+	u64 cs_mask[2];
+	u32 reserved[20];
+	u32 bank_bit_first;
+	u32 bank_bit_mask;
+};
+
+enum {
+	FIRMWARE_NONE,
+	FIRMWARE_TEE_32BIT,
+	FIRMWARE_ATF_32BIT,
+	FIRMWARE_ATF_64BIT,
+	FIRMWARE_END,
+};
+
+/* Share mem page types */
+typedef enum {
+	SHARE_PAGE_TYPE_INVALID = 0,
+	SHARE_PAGE_TYPE_UARTDBG,
+	SHARE_PAGE_TYPE_DDR,
+	SHARE_PAGE_TYPE_DDRDBG,
+	SHARE_PAGE_TYPE_DDRECC,
+	SHARE_PAGE_TYPE_DDRFSP,
+	SHARE_PAGE_TYPE_DDR_ADDRMAP,
+	SHARE_PAGE_TYPE_LAST_LOG,
+	SHARE_PAGE_TYPE_MAX,
+} share_page_type_t;
+
+/* fiq control sub func */
+enum {
+	RK_SIP_FIQ_CTRL_FIQ_EN = 1,
+	RK_SIP_FIQ_CTRL_FIQ_DIS,
+	RK_SIP_FIQ_CTRL_SET_AFF
+};
+
+/*
+ * Rules: struct arm_smccc_res contains result and data, details:
+ *
+ * a0: error code(0: success, !0: error);
+ * a1~a3: data
+ */
+#if IS_ENABLED(CONFIG_ROCKCHIP_SIP)
+struct arm_smccc_res sip_smc_get_atf_version(void);
+struct arm_smccc_res sip_smc_get_sip_version(void);
+struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_request_share_mem(u32 page_num,
+					       share_page_type_t page_type);
+struct arm_smccc_res sip_smc_mcu_el3fiq(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_get_suspend_info(u32 info);
+struct arm_smccc_res sip_smc_lastlog_request(void);
+
+int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2);
+int sip_smc_virtual_poweroff(void);
+int sip_smc_remotectl_config(u32 func, u32 data);
+
+int sip_smc_secure_reg_write(u32 addr_phy, u32 val);
+u32 sip_smc_secure_reg_read(u32 addr_phy);
+struct arm_smccc_res sip_smc_bus_config(u32 arg0, u32 arg1, u32 arg2);
+struct dram_addrmap_info *sip_smc_get_dram_map(void);
+
+/***************************fiq debugger **************************************/
+void sip_fiq_debugger_enable_fiq(bool enable, uint32_t tgt_cpu);
+void sip_fiq_debugger_enable_debug(bool enable);
+int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback_fn);
+int sip_fiq_debugger_set_print_port(u32 port_phyaddr, u32 baudrate);
+int sip_fiq_debugger_request_share_memory(void);
+int sip_fiq_debugger_get_target_cpu(void);
+int sip_fiq_debugger_switch_cpu(u32 cpu);
+int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu, u32 flag);
+int sip_fiq_debugger_is_enabled(void);
+int sip_fiq_debugger_sdei_get_event_id(u32 *fiq, u32 *sw_cpu, u32 *flag);
+int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data);
+#else
+static inline struct arm_smccc_res sip_smc_get_atf_version(void)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_get_sip_version(void)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_request_share_mem
+			(u32 page_num, share_page_type_t page_type)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_mcu_el3fiq
+			(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res
+sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_lastlog_request(void)
+{
+	struct arm_smccc_res tmp = {0};
+	return tmp;
+}
+
+static inline int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2)
+{
+	return 0;
+}
+
+static inline int sip_smc_get_suspend_info(u32 info)
+{
+	return 0;
+}
+
+static inline int sip_smc_virtual_poweroff(void) { return 0; }
+static inline int sip_smc_remotectl_config(u32 func, u32 data) { return 0; }
+static inline u32 sip_smc_secure_reg_read(u32 addr_phy) { return 0; }
+static inline int sip_smc_secure_reg_write(u32 addr_phy, u32 val) { return 0; }
+static inline int sip_smc_soc_bus_div(u32 arg0, u32 arg1, u32 arg2)
+{
+	return 0;
+}
+static inline struct dram_addrmap_info *sip_smc_get_dram_map(void)
+{
+	return NULL;
+}
+
+/***************************fiq debugger **************************************/
+static inline void sip_fiq_debugger_enable_fiq
+			(bool enable, uint32_t tgt_cpu) { return; }
+
+static inline void sip_fiq_debugger_enable_debug(bool enable) { return; }
+static inline int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id,
+						    void *callback_fn)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_set_print_port(u32 port_phyaddr,
+						  u32 baudrate)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_request_share_memory(void) { return 0; }
+static inline int sip_fiq_debugger_get_target_cpu(void) { return 0; }
+static inline int sip_fiq_debugger_switch_cpu(u32 cpu) { return 0; }
+static inline int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu,
+						   u32 flag) { return 0; }
+static inline int sip_fiq_debugger_is_enabled(void) { return 0; }
+static inline int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data)
+{
+	return 0;
+}
+#endif
+
+/* 32-bit OP-TEE context, never change order of members! */
+struct sm_nsec_ctx {
+	u32 usr_sp;
+	u32 usr_lr;
+	u32 irq_spsr;
+	u32 irq_sp;
+	u32 irq_lr;
+	u32 fiq_spsr;
+	u32 fiq_sp;
+	u32 fiq_lr;
+	u32 svc_spsr;
+	u32 svc_sp;
+	u32 svc_lr;
+	u32 abt_spsr;
+	u32 abt_sp;
+	u32 abt_lr;
+	u32 und_spsr;
+	u32 und_sp;
+	u32 und_lr;
+	u32 mon_lr;
+	u32 mon_spsr;
+	u32 r4;
+	u32 r5;
+	u32 r6;
+	u32 r7;
+	u32 r8;
+	u32 r9;
+	u32 r10;
+	u32 r11;
+	u32 r12;
+	u32 r0;
+	u32 r1;
+	u32 r2;
+	u32 r3;
+};
+
+/* 64-bit ATF context, never change order of members! */
+struct gp_regs_ctx {
+	u64 x0;
+	u64 x1;
+	u64 x2;
+	u64 x3;
+	u64 x4;
+	u64 x5;
+	u64 x6;
+	u64 x7;
+	u64 x8;
+	u64 x9;
+	u64 x10;
+	u64 x11;
+	u64 x12;
+	u64 x13;
+	u64 x14;
+	u64 x15;
+	u64 x16;
+	u64 x17;
+	u64 x18;
+	u64 x19;
+	u64 x20;
+	u64 x21;
+	u64 x22;
+	u64 x23;
+	u64 x24;
+	u64 x25;
+	u64 x26;
+	u64 x27;
+	u64 x28;
+	u64 x29;
+	u64 lr;
+	u64 sp_el0;
+	u64 scr_el3;
+	u64 runtime_sp;
+	u64 spsr_el3;
+	u64 elr_el3;
+};
+
+#endif
diff --git a/include/linux/rockchip_ion.h b/include/linux/rockchip_ion.h
new file mode 100644
index 000000000..39c497774
--- /dev/null
+++ b/include/linux/rockchip_ion.h
@@ -0,0 +1,41 @@
+/*
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ROCKCHIP_ION_H
+#define _LINUX_ROCKCHIP_ION_H
+
+#ifdef __KERNEL__
+#include "../../drivers/staging/android/ion/ion.h"
+#else
+#include <linux/ion.h>
+#endif
+
+struct ion_phys_data {
+	ion_user_handle_t handle;
+	unsigned long phys;
+	unsigned long size;
+};
+
+#define ION_IOC_ROCKCHIP_MAGIC 'R'
+
+/* Get phys addr of the handle specified. */
+#define ION_IOC_GET_PHYS	_IOWR(ION_IOC_ROCKCHIP_MAGIC, 0, \
+						struct ion_phys_data)
+
+extern struct ion_device *rockchip_ion_dev;
+
+struct ion_client *rockchip_ion_client_create(const char *name);
+
+#endif
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 6ae4d7ae5..433f2bd90 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -34,14 +34,12 @@
 #include <linux/rseq.h>
 #include <linux/seqlock.h>
 #include <linux/kcsan.h>
-#include <linux/sched/rtg.h>
 
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
 struct backing_dev_info;
 struct bio_list;
 struct blk_plug;
-struct bpf_run_ctx;
 struct capture_control;
 struct cfs_rq;
 struct fs_struct;
@@ -217,56 +215,6 @@ struct io_uring_task;
 /* Task command name length: */
 #define TASK_COMM_LEN			16
 
-enum task_event {
-	PUT_PREV_TASK   = 0,
-	PICK_NEXT_TASK  = 1,
-	TASK_WAKE       = 2,
-	TASK_MIGRATE    = 3,
-	TASK_UPDATE     = 4,
-	IRQ_UPDATE      = 5,
-};
-
-/* Note: this need to be in sync with migrate_type_names array */
-enum migrate_types {
-	GROUP_TO_RQ,
-	RQ_TO_GROUP,
-};
-
-#ifdef CONFIG_CPU_ISOLATION_OPT
-extern int sched_isolate_count(const cpumask_t *mask, bool include_offline);
-extern int sched_isolate_cpu(int cpu);
-extern int sched_unisolate_cpu(int cpu);
-extern int sched_unisolate_cpu_unlocked(int cpu);
-#else
-static inline int sched_isolate_count(const cpumask_t *mask,
-				      bool include_offline)
-{
-	cpumask_t count_mask;
-
-	if (include_offline)
-		cpumask_andnot(&count_mask, mask, cpu_online_mask);
-	else
-		return 0;
-
-	return cpumask_weight(&count_mask);
-}
-
-static inline int sched_isolate_cpu(int cpu)
-{
-	return 0;
-}
-
-static inline int sched_unisolate_cpu(int cpu)
-{
-	return 0;
-}
-
-static inline int sched_unisolate_cpu_unlocked(int cpu)
-{
-	return 0;
-}
-#endif
-
 extern void scheduler_tick(void);
 
 #define	MAX_SCHEDULE_TIMEOUT		LONG_MAX
@@ -549,53 +497,6 @@ struct sched_entity {
 #endif
 };
 
-#ifdef CONFIG_SCHED_WALT
-extern void sched_exit(struct task_struct *p);
-extern int sched_set_init_task_load(struct task_struct *p, int init_load_pct);
-extern u32 sched_get_init_task_load(struct task_struct *p);
-extern void free_task_load_ptrs(struct task_struct *p);
-#define RAVG_HIST_SIZE_MAX  5
-struct ravg {
-	/*
-	 * 'mark_start' marks the beginning of an event (task waking up, task
-	 * starting to execute, task being preempted) within a window
-	 *
-	 * 'sum' represents how runnable a task has been within current
-	 * window. It incorporates both running time and wait time and is
-	 * frequency scaled.
-	 *
-	 * 'sum_history' keeps track of history of 'sum' seen over previous
-	 * RAVG_HIST_SIZE windows. Windows where task was entirely sleeping are
-	 * ignored.
-	 *
-	 * 'demand' represents maximum sum seen over previous
-	 * sysctl_sched_ravg_hist_size windows. 'demand' could drive frequency
-	 * demand for tasks.
-	 *
-	 * 'curr_window_cpu' represents task's contribution to cpu busy time on
-	 * various CPUs in the current window
-	 *
-	 * 'prev_window_cpu' represents task's contribution to cpu busy time on
-	 * various CPUs in the previous window
-	 *
-	 * 'curr_window' represents the sum of all entries in curr_window_cpu
-	 *
-	 * 'prev_window' represents the sum of all entries in prev_window_cpu
-	 *
-	 */
-	u64 mark_start;
-	u32 sum, demand;
-	u32 sum_history[RAVG_HIST_SIZE_MAX];
-	u32 *curr_window_cpu, *prev_window_cpu;
-	u32 curr_window, prev_window;
-	u16 active_windows;
-	u16 demand_scaled;
-};
-#else
-static inline void sched_exit(struct task_struct *p) { }
-static inline void free_task_load_ptrs(struct task_struct *p) { }
-#endif /* CONFIG_SCHED_WALT */
-
 struct sched_rt_entity {
 	struct list_head		run_list;
 	unsigned long			timeout;
@@ -801,22 +702,6 @@ struct task_struct {
 	const struct sched_class	*sched_class;
 	struct sched_entity		se;
 	struct sched_rt_entity		rt;
-#ifdef CONFIG_SCHED_WALT
-	struct ravg ravg;
-	/*
-	 * 'init_load_pct' represents the initial task load assigned to children
-	 * of this task
-	 */
-	u32 init_load_pct;
-	u64 last_sleep_ts;
-#endif
-
-#ifdef CONFIG_SCHED_RTG
-	int rtg_depth;
-	struct related_thread_group	*grp;
-	struct list_head		grp_list;
-#endif
-
 #ifdef CONFIG_CGROUP_SCHED
 	struct task_group		*sched_task_group;
 #endif
@@ -835,6 +720,10 @@ struct task_struct {
 	struct uclamp_se		uclamp[UCLAMP_CNT];
 #endif
 
+#ifdef CONFIG_HOTPLUG_CPU
+	struct list_head		percpu_kthread_node;
+#endif
+
 #ifdef CONFIG_PREEMPT_NOTIFIERS
 	/* List of struct preempt_notifier: */
 	struct hlist_head		preempt_notifiers;
@@ -1014,6 +903,10 @@ struct task_struct {
 	u64				stimescaled;
 #endif
 	u64				gtime;
+#ifdef CONFIG_CPU_FREQ_TIMES
+	u64				*time_in_state;
+	unsigned int			max_state;
+#endif
 	struct prev_cputime		prev_cputime;
 #ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
 	struct vtime			vtime;
@@ -1125,6 +1018,7 @@ struct task_struct {
 	raw_spinlock_t			pi_lock;
 
 	struct wake_q_node		wake_q;
+	int				wake_q_count;
 
 #ifdef CONFIG_RT_MUTEXES
 	/* PI waiters blocked on a rt_mutex held by this task: */
@@ -1349,7 +1243,7 @@ struct task_struct {
 	u64				timer_slack_ns;
 	u64				default_timer_slack_ns;
 
-#ifdef CONFIG_KASAN
+#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
 	unsigned int			kasan_depth;
 #endif
 
@@ -1462,10 +1356,6 @@ struct task_struct {
 	/* Used by LSM modules for access restriction: */
 	void				*security;
 #endif
-#ifdef CONFIG_BPF_SYSCALL
-	/* Used for BPF run context */
-	struct bpf_run_ctx		*bpf_ctx;
-#endif
 
 #ifdef CONFIG_GCC_PLUGIN_STACKLEAK
 	unsigned long			lowest_stack;
@@ -1480,9 +1370,7 @@ struct task_struct {
 					mce_whole_page : 1,
 					__mce_reserved : 62;
 	struct callback_head		mce_kill_me;
-	int				mce_count;
 #endif
-
 #ifdef CONFIG_ACCESS_TOKENID
 	u64				token;
 	u64				ftoken;
@@ -1719,7 +1607,7 @@ extern struct pid *cad_pid;
 #define tsk_used_math(p)			((p)->flags & PF_USED_MATH)
 #define used_math()				tsk_used_math(current)
 
-static __always_inline bool is_percpu_thread(void)
+static inline bool is_percpu_thread(void)
 {
 #ifdef CONFIG_SMP
 	return (current->flags & PF_NO_SETAFFINITY) &&
@@ -1789,9 +1677,20 @@ current_restore_flags(unsigned long orig_flags, unsigned long flags)
 
 extern int cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);
 extern int task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed);
+
+#ifdef CONFIG_RT_SOFTINT_OPTIMIZATION
+extern bool cpupri_check_rt(void);
+#else
+static inline bool cpupri_check_rt(void)
+{
+	return false;
+}
+#endif
+
 #ifdef CONFIG_SMP
 extern void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask);
 extern int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask);
+extern void force_compatible_cpus_allowed_ptr(struct task_struct *p);
 #else
 static inline void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)
 {
diff --git a/include/linux/sched/core_ctl.h b/include/linux/sched/core_ctl.h
deleted file mode 100644
index ca321b7b0..000000000
--- a/include/linux/sched/core_ctl.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (c) 2016, 2019-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef __CORE_CTL_H
-#define __CORE_CTL_H
-
-#ifdef CONFIG_SCHED_CORE_CTRL
-extern void core_ctl_check(u64 wallclock);
-#else
-static inline void core_ctl_check(u64 wallclock) { }
-#endif
-#endif
diff --git a/include/linux/sched/cpufreq.h b/include/linux/sched/cpufreq.h
index 94e7f84de..3ed5aa185 100644
--- a/include/linux/sched/cpufreq.h
+++ b/include/linux/sched/cpufreq.h
@@ -9,9 +9,6 @@
  */
 
 #define SCHED_CPUFREQ_IOWAIT	(1U << 0)
-#define SCHED_CPUFREQ_WALT	(1U << 1)
-#define SCHED_CPUFREQ_CONTINUE	(1U << 2)
-#define SCHED_CPUFREQ_FORCE_UPDATE	(1U << 3)
 
 #ifdef CONFIG_CPU_FREQ
 struct cpufreq_policy;
diff --git a/include/linux/sched/frame_rtg.h b/include/linux/sched/frame_rtg.h
deleted file mode 100644
index 6713f6771..000000000
--- a/include/linux/sched/frame_rtg.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Frame declaration
- *
- * Copyright (c) 2022-2023 Huawei Technologies Co., Ltd.
- */
-
-#ifndef __SCHED_FRAME_RTG_H
-#define __SCHED_FRAME_RTG_H
-
-#ifdef CONFIG_SCHED_RTG_FRAME
-
-#define MAX_TID_NUM 5
-
-struct frame_info {
-	/*
-	 * use rtg load tracking in frame_info
-	 * rtg->curr_window_load  -=> the workload of current frame
-	 * rtg->prev_window_load  -=> the workload of last frame
-	 * rtg->curr_window_exec  -=> the thread's runtime of current frame
-	 * rtg->prev_window_exec  -=> the thread's runtime of last frame
-	 * rtg->prev_window_time  -=> the actual time of the last frame
-	 */
-	struct mutex lock;
-	struct related_thread_group *rtg;
-	int prio;
-	struct task_struct *thread[MAX_TID_NUM];
-	atomic_t thread_prio[MAX_TID_NUM];
-	int thread_num;
-	unsigned int frame_rate; // frame rate
-	u64 frame_time;
-	atomic_t curr_rt_thread_num;
-	atomic_t max_rt_thread_num;
-	atomic_t frame_sched_state;
-	atomic_t start_frame_freq;
-	atomic_t frame_state;
-
-	/*
-	 * frame_vload : the emergency level of current frame.
-	 * max_vload_time : the timeline frame_load increase to FRAME_MAX_VLOAD
-	 * it's always equal to 2 * frame_time / NSEC_PER_MSEC
-	 *
-	 * The closer to the deadline, the higher emergency of current
-	 * frame, so the frame_vload is only related to frame time,
-	 * and grown with time.
-	 */
-	u64 frame_vload;
-	int vload_margin;
-	int max_vload_time;
-
-	u64 frame_util;
-	unsigned long status;
-	unsigned long prev_fake_load_util;
-	unsigned long prev_frame_load_util;
-	unsigned long prev_frame_time;
-	unsigned long prev_frame_exec;
-	unsigned long prev_frame_load;
-	unsigned int frame_min_util;
-	unsigned int frame_max_util;
-	unsigned int prev_min_util;
-	unsigned int prev_max_util;
-	unsigned int frame_boost_min_util;
-
-	bool margin_imme;
-	bool timestamp_skipped;
-};
-
-struct frame_info *rtg_frame_info(int id);
-static inline
-struct related_thread_group *frame_info_rtg(const struct frame_info *frame_info)
-{
-	return frame_info->rtg;
-}
-#endif
-#endif
diff --git a/include/linux/sched/hotplug.h b/include/linux/sched/hotplug.h
index 9a62ffdd2..89fb9b027 100644
--- a/include/linux/sched/hotplug.h
+++ b/include/linux/sched/hotplug.h
@@ -8,7 +8,11 @@
 
 extern int sched_cpu_starting(unsigned int cpu);
 extern int sched_cpu_activate(unsigned int cpu);
+extern int sched_cpus_activate(struct cpumask *cpus);
 extern int sched_cpu_deactivate(unsigned int cpu);
+extern int sched_cpus_deactivate_nosync(struct cpumask *cpus);
+extern int sched_cpu_drain_rq(unsigned int cpu);
+extern void sched_cpu_drain_rq_wait(unsigned int cpu);
 
 #ifdef CONFIG_HOTPLUG_CPU
 extern int sched_cpu_dying(unsigned int cpu);
diff --git a/include/linux/sched/isolation.h b/include/linux/sched/isolation.h
index 22420b45b..cc9f393e2 100644
--- a/include/linux/sched/isolation.h
+++ b/include/linux/sched/isolation.h
@@ -28,25 +28,10 @@ extern void __init housekeeping_init(void);
 
 #else
 
-#ifdef CONFIG_CPU_ISOLATION_OPT
-static inline int housekeeping_any_cpu(enum hk_flags flags)
-{
-	cpumask_t available;
-	int cpu;
-
-	cpumask_andnot(&available, cpu_online_mask, cpu_isolated_mask);
-	cpu = cpumask_any(&available);
-	if (cpu >= nr_cpu_ids)
-		cpu = smp_processor_id();
-
-	return cpu;
-}
-#else
 static inline int housekeeping_any_cpu(enum hk_flags flags)
 {
 	return smp_processor_id();
 }
-#endif
 
 static inline const struct cpumask *housekeeping_cpumask(enum hk_flags flags)
 {
@@ -69,11 +54,7 @@ static inline bool housekeeping_cpu(int cpu, enum hk_flags flags)
 	if (static_branch_unlikely(&housekeeping_overridden))
 		return housekeeping_test_cpu(cpu, flags);
 #endif
-#ifdef CONFIG_CPU_ISOLATION_OPT
-	return !cpu_isolated(cpu);
-#else
 	return true;
-#endif
 }
 
 #endif /* _LINUX_SCHED_ISOLATION_H */
diff --git a/include/linux/sched/rtg.h b/include/linux/sched/rtg.h
deleted file mode 100644
index ec738f49f..000000000
--- a/include/linux/sched/rtg.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __SCHED_RTG_H
-#define __SCHED_RTG_H
-
-#ifdef CONFIG_SCHED_RTG
-
-#define DEFAULT_RTG_GRP_ID	0
-#define DEFAULT_CGROUP_COLOC_ID	1
-#define MAX_NUM_CGROUP_COLOC_ID	21
-
-struct group_cpu_time {
-	u64	window_start;
-	u64	curr_runnable_sum;
-	u64	prev_runnable_sum;
-	u64	nt_curr_runnable_sum;
-	u64	nt_prev_runnable_sum;
-};
-
-struct group_ravg {
-	unsigned long curr_window_load;
-	unsigned long curr_window_exec;
-	unsigned long prev_window_load;
-	unsigned long prev_window_exec;
-	unsigned long normalized_util;
-};
-
-struct rtg_class;
-
-struct related_thread_group {
-	int id;
-	raw_spinlock_t lock;
-	struct list_head tasks;
-	struct list_head list;
-
-	unsigned int nr_running;
-	struct group_ravg ravg;
-	u64 window_start;
-	u64 mark_start;
-	u64 prev_window_time;
-	/* rtg window information for WALT */
-	unsigned int window_size;
-	const struct rtg_class *rtg_class;
-	struct sched_cluster *preferred_cluster;
-	int max_boost;
-	unsigned long util_invalid_interval; /* in nanoseconds */
-	unsigned long util_update_timeout; /* in nanoseconds */
-	unsigned long freq_update_interval; /* in nanoseconds */
-	u64 last_util_update_time;
-	u64 last_freq_update_time;
-	void *private_data;
-};
-
-struct rtg_class {
-	void (*sched_update_rtg_tick)(struct related_thread_group *grp);
-};
-
-enum rtg_freq_update_flags {
-	RTG_FREQ_FORCE_UPDATE = (1 << 0),
-	RTG_FREQ_NORMAL_UPDATE = (1 << 1),
-};
-
-int sched_set_group_id(struct task_struct *p, unsigned int group_id);
-unsigned int sched_get_group_id(struct task_struct *p);
-#endif /* CONFIG_SCHED_RTG */
-#endif
diff --git a/include/linux/sched/rtg_ctrl.h b/include/linux/sched/rtg_ctrl.h
deleted file mode 100644
index b71dd74e7..000000000
--- a/include/linux/sched/rtg_ctrl.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * rtg control interface
- *
- * Copyright (c) 2022-2023 Huawei Technologies Co., Ltd.
- */
-
-#ifndef __SCHED_RTG_CTL_H
-#define __SCHED_RTG_CTL_H
-
-#include <linux/fs.h>
-
-#define SYSTEM_SERVER_UID 1000
-#define MIN_APP_UID 10000
-#define MAX_BOOST_DURATION_MS 5000
-
-#define RTG_SCHED_IPC_MAGIC 0XAB
-
-#define CMD_ID_SET_ENABLE \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_ENABLE, struct rtg_enable_data)
-#define CMD_ID_SET_RTG \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_RTG, struct rtg_str_data)
-#define CMD_ID_SET_CONFIG \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_CONFIG, struct rtg_str_data)
-#define CMD_ID_SET_RTG_ATTR \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_RTG_ATTR, struct rtg_str_data)
-#define CMD_ID_BEGIN_FRAME_FREQ \
-	_IOWR(RTG_SCHED_IPC_MAGIC, BEGIN_FRAME_FREQ, struct proc_state_data)
-#define CMD_ID_END_FRAME_FREQ \
-	_IOWR(RTG_SCHED_IPC_MAGIC, END_FRAME_FREQ, struct proc_state_data)
-#define CMD_ID_END_SCENE \
-	_IOWR(RTG_SCHED_IPC_MAGIC, END_SCENE, struct proc_state_data)
-#define CMD_ID_SET_MIN_UTIL \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_MIN_UTIL, struct proc_state_data)
-#define CMD_ID_SET_MARGIN \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SET_MARGIN, struct proc_state_data)
-#define CMD_ID_LIST_RTG \
-	_IOWR(RTG_SCHED_IPC_MAGIC, LIST_RTG, struct rtg_info)
-#define CMD_ID_LIST_RTG_THREAD \
-	_IOWR(RTG_SCHED_IPC_MAGIC, LIST_RTG_THREAD, struct rtg_grp_data)
-#define CMD_ID_SEARCH_RTG \
-	_IOWR(RTG_SCHED_IPC_MAGIC, SEARCH_RTG, struct proc_state_data)
-#define CMD_ID_GET_ENABLE \
-	_IOWR(RTG_SCHED_IPC_MAGIC, GET_ENABLE, struct rtg_enable_data)
-
-int proc_rtg_open(struct inode *inode, struct file *filp);
-long proc_rtg_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
-#ifdef CONFIG_COMPAT
-long proc_rtg_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
-#endif
-
-enum ioctl_abi_format {
-	IOCTL_ABI_ARM32,
-	IOCTL_ABI_AARCH64,
-};
-
-enum rtg_sched_cmdid {
-	SET_ENABLE = 1,
-	SET_RTG,
-	SET_CONFIG,
-	SET_RTG_ATTR,
-	BEGIN_FRAME_FREQ = 5,
-	END_FRAME_FREQ,
-	END_SCENE,
-	SET_MIN_UTIL,
-	SET_MARGIN,
-	LIST_RTG = 10,
-	LIST_RTG_THREAD,
-	SEARCH_RTG,
-	GET_ENABLE,
-	RTG_CTRL_MAX_NR,
-};
-
-/* proc_state */
-enum grp_ctrl_cmd {
-	CMD_CREATE_RTG_GRP,
-	CMD_ADD_RTG_THREAD,
-	CMD_REMOVE_RTG_THREAD,
-	CMD_CLEAR_RTG_GRP,
-	CMD_DESTROY_RTG_GRP
-};
-
-struct rtg_enable_data {
-	int enable;
-	int len;
-	char *data;
-};
-
-struct rtg_str_data {
-	int type;
-	int len;
-	char *data;
-};
-
-struct proc_state_data {
-	int grp_id;
-	int state_param;
-};
-#endif
diff --git a/include/linux/sched/stat.h b/include/linux/sched/stat.h
index ca8b0d1cc..568286411 100644
--- a/include/linux/sched/stat.h
+++ b/include/linux/sched/stat.h
@@ -21,15 +21,6 @@ extern bool single_task_running(void);
 extern unsigned long nr_iowait(void);
 extern unsigned long nr_iowait_cpu(int cpu);
 
-#ifdef CONFIG_SCHED_WALT
-extern unsigned int sched_get_cpu_util(int cpu);
-#else
-static inline unsigned int sched_get_cpu_util(int cpu)
-{
-	return 0;
-}
-#endif
-
 static inline int sched_info_on(void)
 {
 #ifdef CONFIG_SCHEDSTATS
diff --git a/include/linux/sched/wake_q.h b/include/linux/sched/wake_q.h
index 26a2013ac..1e05e5669 100644
--- a/include/linux/sched/wake_q.h
+++ b/include/linux/sched/wake_q.h
@@ -38,6 +38,7 @@
 struct wake_q_head {
 	struct wake_q_node *first;
 	struct wake_q_node **lastp;
+	int count;
 };
 
 #define WAKE_Q_TAIL ((struct wake_q_node *) 0x01)
@@ -49,6 +50,7 @@ static inline void wake_q_init(struct wake_q_head *head)
 {
 	head->first = WAKE_Q_TAIL;
 	head->lastp = &head->first;
+	head->count = 0;
 }
 
 static inline bool wake_q_empty(struct wake_q_head *head)
diff --git a/include/linux/sched/xacct.h b/include/linux/sched/xacct.h
index c078f0a94..9544c9d9d 100644
--- a/include/linux/sched/xacct.h
+++ b/include/linux/sched/xacct.h
@@ -28,6 +28,11 @@ static inline void inc_syscw(struct task_struct *tsk)
 {
 	tsk->ioac.syscw++;
 }
+
+static inline void inc_syscfs(struct task_struct *tsk)
+{
+	tsk->ioac.syscfs++;
+}
 #else
 static inline void add_rchar(struct task_struct *tsk, ssize_t amt)
 {
@@ -44,6 +49,10 @@ static inline void inc_syscr(struct task_struct *tsk)
 static inline void inc_syscw(struct task_struct *tsk)
 {
 }
+
+static inline void inc_syscfs(struct task_struct *tsk)
+{
+}
 #endif
 
 #endif /* _LINUX_SCHED_XACCT_H */
diff --git a/include/linux/sensor-dev.h b/include/linux/sensor-dev.h
new file mode 100644
index 000000000..fd8ad694c
--- /dev/null
+++ b/include/linux/sensor-dev.h
@@ -0,0 +1,349 @@
+/* include/linux/sensor-dev.h - sensor header file
+ *
+ * Copyright (C) 2012-2015 ROCKCHIP.
+ * Author: luowei <lw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/miscdevice.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <dt-bindings/sensor-dev.h>
+#include <linux/module.h>
+
+#define SENSOR_ON		1
+#define SENSOR_OFF		0
+#define SENSOR_UNKNOW_DATA	-1
+
+#define GPIO_HIGH 1
+#define GPIO_LOW 0
+
+enum sensor_id {
+	ID_INVALID = 0,
+
+	ANGLE_ID_ALL,
+	ANGLE_ID_KXTIK,
+	ANGLE_ID_LIS3DH,
+
+	ACCEL_ID_ALL,
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303DLX,
+	ACCEL_ID_LIS3DH,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_KXTIK,
+	ACCEL_ID_KXTJ9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_BMA250,
+	ACCEL_ID_ADXL34X,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA845X,
+	ACCEL_ID_MMA7660,
+	ACCEL_ID_SC7660,
+	ACCEL_ID_SC7A20,
+	ACCEL_ID_SC7A30,
+	ACCEL_ID_MPU6050,
+	ACCEL_ID_MXC6225,
+	ACCEL_ID_MXC6655XA,
+	ACCEL_ID_DMARD10,
+	ACCEL_ID_LSM303D,
+	ACCEL_ID_MC3230,
+	ACCEL_ID_MPU6880,
+	ACCEL_ID_MPU6500,
+	ACCEL_ID_LSM330,
+	ACCEL_ID_BMA2XX,
+	ACCEL_ID_STK8BAXX,
+	ACCEL_ID_MIR3DA,
+	ACCEL_ID_ICM2060X,
+	COMPASS_ID_ALL,
+	COMPASS_ID_AK8975,
+	COMPASS_ID_AK8963,
+	COMPASS_ID_AK09911,
+	COMPASS_ID_AK8972,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_AMI306,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_YAS530,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303DLH,
+	COMPASS_ID_LSM303DLM,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_HSCDTD002B,
+	COMPASS_ID_HSCDTD004A,
+	COMPASS_ID_AK09918,
+
+	GYRO_ID_ALL,
+	GYRO_ID_L3G4200D,
+	GYRO_ID_L3G20D,
+	GYRO_ID_EWTSA,
+	GYRO_ID_K3G,
+	GYRO_ID_MPU6500,
+	GYRO_ID_MPU6880,
+	GYRO_ID_LSM330,
+	GYRO_ID_ICM2060X,
+	LIGHT_ID_ALL,
+	LIGHT_ID_CM3217,
+	LIGHT_ID_CM3218,
+	LIGHT_ID_CM3232,
+	LIGHT_ID_AL3006,
+	LIGHT_ID_STK3171,
+	LIGHT_ID_ISL29023,
+	LIGHT_ID_AP321XX,
+	LIGHT_ID_PHOTORESISTOR,
+	LIGHT_ID_US5152,
+	LIGHT_ID_STK3410,
+	LIGHT_ID_EM3071X,
+
+	PROXIMITY_ID_ALL,
+	PROXIMITY_ID_AL3006,
+	PROXIMITY_ID_STK3171,
+	PROXIMITY_ID_AP321XX,
+	PROXIMITY_ID_STK3410,
+	PROXIMITY_ID_EM3071X,
+
+	TEMPERATURE_ID_ALL,
+	TEMPERATURE_ID_MS5607,
+
+	PRESSURE_ID_ALL,
+	PRESSURE_ID_BMA085,
+	PRESSURE_ID_MS5607,
+
+	HALL_ID_ALL,
+	HALL_ID_OCH165T,
+
+	SENSOR_NUM_ID,
+};
+
+struct sensor_axis {
+	int x;
+	int y;
+	int z;
+};
+
+struct sensor_flag {
+	atomic_t a_flag;
+	atomic_t m_flag;
+	atomic_t mv_flag;
+	atomic_t open_flag;
+	atomic_t debug_flag;
+	long long delay;
+	wait_queue_head_t open_wq;
+};
+
+
+struct sensor_operate {
+	char *name;
+	int type;
+	int id_i2c;
+	int range[2];
+	int brightness[2];
+	int read_reg;
+	int read_len;
+	int id_reg;
+	int id_data;
+	int precision;
+	int ctrl_reg;
+	int ctrl_data;
+	int int_ctrl_reg;
+	int int_status_reg;
+	int trig;
+	int (*active)(struct i2c_client *client, int enable, int rate);
+	int (*init)(struct i2c_client *client);
+	int (*report)(struct i2c_client *client);
+	int (*suspend)(struct i2c_client *client);
+	int (*resume)(struct i2c_client *client);
+	struct miscdevice *misc_dev;
+};
+
+/* Platform data for the sensor */
+struct sensor_private_data {
+	int type;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int stop_work;
+	struct delayed_work delaywork;
+	struct sensor_axis axis;
+	char sensor_data[40];
+	atomic_t is_factory;
+	wait_queue_head_t is_factory_ok;
+	struct mutex data_mutex;
+	struct mutex operation_mutex;
+	struct mutex sensor_mutex;
+	struct mutex i2c_mutex;
+	int status_cur;
+	int start_count;
+	int devid;
+	struct sensor_flag flags;
+	struct i2c_device_id *i2c_id;
+	struct sensor_platform_data *pdata;
+	struct sensor_operate *ops;
+	struct file_operations fops;
+	struct miscdevice miscdev;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+struct sensor_platform_data {
+	int type;
+	int irq;
+	int irq_pin;
+	int power_pin;
+	int reset_pin;
+	int standby_pin;
+	int irq_enable;
+	int poll_delay_ms;
+	int x_min;
+	int y_min;
+	int z_min;
+	int factory;
+	int layout;
+	unsigned char address;
+	unsigned long irq_flags;
+	signed char orientation[9];
+	short m_layout[4][3][3];
+	int *project_name;
+	int power_off_in_suspend;
+};
+
+struct gsensor_platform_data {
+	u16 model;
+	u16 swap_xy;
+	u16 swap_xyz;
+	signed char orientation[9];
+	int (*get_pendown_state)(void);
+	int (*init_platform_hw)(void);
+	int (*gsensor_platform_sleep)(void);
+	int (*gsensor_platform_wakeup)(void);
+	void (*exit_platform_hw)(void);
+};
+
+struct akm8975_platform_data {
+	short m_layout[4][3][3];
+	char project_name[64];
+	int gpio_DRDY;
+};
+
+struct akm_platform_data {
+	short m_layout[4][3][3];
+	char project_name[64];
+	char layout;
+	char outbit;
+	int gpio_DRDY;
+	int gpio_RST;
+};
+
+extern int sensor_register_device(struct i2c_client *client,
+			struct sensor_platform_data *slave_pdata,
+			const struct i2c_device_id *devid,
+			struct sensor_operate *ops);
+
+
+extern int sensor_unregister_device(struct i2c_client *client,
+			struct sensor_platform_data *slave_pdata,
+			struct sensor_operate *ops);
+
+extern void sensor_shutdown(struct i2c_client *client);
+extern const struct dev_pm_ops sensor_pm_ops;
+
+#define DBG(x...)
+
+#define GSENSOR_IOCTL_MAGIC			'a'
+#define GBUFF_SIZE				12	/* Rx buffer size */
+
+/* IOCTLs for MMA8452 library */
+#define GSENSOR_IOCTL_INIT						_IO(GSENSOR_IOCTL_MAGIC, 0x01)
+#define GSENSOR_IOCTL_RESET					_IO(GSENSOR_IOCTL_MAGIC, 0x04)
+#define GSENSOR_IOCTL_CLOSE					_IO(GSENSOR_IOCTL_MAGIC, 0x02)
+#define GSENSOR_IOCTL_START					_IO(GSENSOR_IOCTL_MAGIC, 0x03)
+#define GSENSOR_IOCTL_GETDATA					_IOR(GSENSOR_IOCTL_MAGIC, 0x08, char[GBUFF_SIZE+1])
+#define GSENSOR_IOCTL_APP_SET_RATE			_IOW(GSENSOR_IOCTL_MAGIC, 0x10, short)
+#define GSENSOR_IOCTL_GET_CALIBRATION		_IOR(GSENSOR_IOCTL_MAGIC, 0x11, int[3])
+
+
+#define COMPASS_IOCTL_MAGIC					'c'
+/* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MODE				_IOW(COMPASS_IOCTL_MAGIC, 0x10, short)
+#define ECS_IOCTL_APP_SET_MFLAG				_IOW(COMPASS_IOCTL_MAGIC, 0x11, short)
+#define ECS_IOCTL_APP_GET_MFLAG				_IOW(COMPASS_IOCTL_MAGIC, 0x12, short)
+#define ECS_IOCTL_APP_SET_AFLAG				_IOW(COMPASS_IOCTL_MAGIC, 0x13, short)
+#define ECS_IOCTL_APP_GET_AFLAG				_IOR(COMPASS_IOCTL_MAGIC, 0x14, short)
+#define ECS_IOCTL_APP_SET_TFLAG				_IOR(COMPASS_IOCTL_MAGIC, 0x15, short)/* NOT use */
+#define ECS_IOCTL_APP_GET_TFLAG				_IOR(COMPASS_IOCTL_MAGIC, 0x16, short)/* NOT use */
+#define ECS_IOCTL_APP_RESET_PEDOMETER		_IOW(COMPASS_IOCTL_MAGIC, 0x17)	/* NOT use */
+#define ECS_IOCTL_APP_SET_DELAY				_IOW(COMPASS_IOCTL_MAGIC, 0x18, short)
+#define ECS_IOCTL_APP_SET_MVFLAG				_IOW(COMPASS_IOCTL_MAGIC, 0x19, short)
+#define ECS_IOCTL_APP_GET_MVFLAG				_IOR(COMPASS_IOCTL_MAGIC, 0x1A, short)
+#define ECS_IOCTL_APP_GET_DELAY				_IOR(COMPASS_IOCTL_MAGIC, 0x1B, short)
+
+#ifdef CONFIG_COMPAT
+#define COMPAT_ECS_IOCTL_APP_SET_MODE			_IOW(COMPASS_IOCTL_MAGIC, 0x10, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_SET_MFLAG			_IOW(COMPASS_IOCTL_MAGIC, 0x11, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_GET_MFLAG			_IOW(COMPASS_IOCTL_MAGIC, 0x12, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_SET_AFLAG			_IOW(COMPASS_IOCTL_MAGIC, 0x13, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_GET_AFLAG			_IOR(COMPASS_IOCTL_MAGIC, 0x14, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_SET_TFLAG			_IOR(COMPASS_IOCTL_MAGIC, 0x15, compat_short_t)/* NOT use */
+#define COMPAT_ECS_IOCTL_APP_GET_TFLAG			_IOR(COMPASS_IOCTL_MAGIC, 0x16, compat_short_t)/* NOT use */
+#define COMPAT_ECS_IOCTL_APP_RESET_PEDOMETER	_IOW(COMPASS_IOCTL_MAGIC, 0x17) /* NOT use */
+#define COMPAT_ECS_IOCTL_APP_SET_DELAY			_IOW(COMPASS_IOCTL_MAGIC, 0x18, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_SET_MVFLAG			_IOW(COMPASS_IOCTL_MAGIC, 0x19, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_GET_MVFLAG			_IOR(COMPASS_IOCTL_MAGIC, 0x1A, compat_short_t)
+#define COMPAT_ECS_IOCTL_APP_GET_DELAY			_IOR(COMPASS_IOCTL_MAGIC, 0x1B, compat_short_t)
+#endif
+
+#define LIGHTSENSOR_IOCTL_MAGIC					'l'
+#define LIGHTSENSOR_IOCTL_GET_ENABLED			_IOR(LIGHTSENSOR_IOCTL_MAGIC, 1, int *)
+#define LIGHTSENSOR_IOCTL_ENABLE					_IOW(LIGHTSENSOR_IOCTL_MAGIC, 2, int *)
+#define LIGHTSENSOR_IOCTL_SET_RATE				_IOW(LIGHTSENSOR_IOCTL_MAGIC, 3, short)
+
+#ifdef CONFIG_COMPAT
+#define COMPAT_LIGHTSENSOR_IOCTL_GET_ENABLED	_IOR(LIGHTSENSOR_IOCTL_MAGIC, 1, compat_uptr_t)
+#define COMPAT_LIGHTSENSOR_IOCTL_ENABLE			_IOW(LIGHTSENSOR_IOCTL_MAGIC, 2, compat_uptr_t)
+#define COMPAT_LIGHTSENSOR_IOCTL_SET_RATE		_IOW(LIGHTSENSOR_IOCTL_MAGIC, 3, compat_short_t)
+#endif
+
+#define PSENSOR_IOCTL_MAGIC				'p'
+#define PSENSOR_IOCTL_GET_ENABLED		_IOR(PSENSOR_IOCTL_MAGIC, 1, int *)
+#define PSENSOR_IOCTL_ENABLE				_IOW(PSENSOR_IOCTL_MAGIC, 2, int *)
+#define PSENSOR_IOCTL_DISABLE				_IOW(PSENSOR_IOCTL_MAGIC, 3, int *)
+
+#ifdef CONFIG_COMPAT
+#define COMPAT_PSENSOR_IOCTL_GET_ENABLED	_IOR(PSENSOR_IOCTL_MAGIC, 1, compat_uptr_t)
+#define COMPAT_PSENSOR_IOCTL_ENABLE			_IOW(PSENSOR_IOCTL_MAGIC, 2, compat_uptr_t)
+#define COMPAT_PSENSOR_IOCTL_DISABLE			_IOW(PSENSOR_IOCTL_MAGIC, 3, compat_uptr_t)
+#endif
+
+#define PRESSURE_IOCTL_MAGIC 				'r'
+#define PRESSURE_IOCTL_GET_ENABLED		_IOR(PRESSURE_IOCTL_MAGIC, 1, int *)
+#define PRESSURE_IOCTL_ENABLE				_IOW(PRESSURE_IOCTL_MAGIC, 2, int *)
+#define PRESSURE_IOCTL_DISABLE			_IOW(PRESSURE_IOCTL_MAGIC, 3, int *)
+#define PRESSURE_IOCTL_SET_DELAY			_IOW(PRESSURE_IOCTL_MAGIC, 4, int *)
+
+
+#define TEMPERATURE_IOCTL_MAGIC			't'
+#define TEMPERATURE_IOCTL_GET_ENABLED	_IOR(TEMPERATURE_IOCTL_MAGIC, 1, int *)
+#define TEMPERATURE_IOCTL_ENABLE			_IOW(TEMPERATURE_IOCTL_MAGIC, 2, int *)
+#define TEMPERATURE_IOCTL_DISABLE		_IOW(TEMPERATURE_IOCTL_MAGIC, 3, int *)
+#define TEMPERATURE_IOCTL_SET_DELAY		_IOW(TEMPERATURE_IOCTL_MAGIC, 4, int *)
+
+
+extern int sensor_rx_data(struct i2c_client *client, char *rxData, int length);
+extern int sensor_tx_data(struct i2c_client *client, char *txData, int length);
+extern int sensor_write_reg(struct i2c_client *client, int addr, int value);
+extern int sensor_read_reg(struct i2c_client *client, int addr);
+extern int sensor_tx_data_normal(struct i2c_client *client, char *buf, int num);
+extern int sensor_rx_data_normal(struct i2c_client *client, char *buf, int num);
+extern int sensor_write_reg_normal(struct i2c_client *client, char value);
+extern int sensor_read_reg_normal(struct i2c_client *client);
diff --git a/include/linux/soc/rockchip/pvtm.h b/include/linux/soc/rockchip/pvtm.h
new file mode 100644
index 000000000..3d2495cfd
--- /dev/null
+++ b/include/linux/soc/rockchip/pvtm.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __SOC_ROCKCHIP_PVTM_H
+#define __SOC_ROCKCHIP_PVTM_H
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_PVTM)
+u32 rockchip_get_pvtm_value(unsigned int id, unsigned int ring_sel,
+			    unsigned int time_us);
+#else
+static inline u32 rockchip_get_pvtm_value(unsigned int id,
+					  unsigned int ring_sel,
+					  unsigned int time_us)
+{
+	return 0;
+}
+#endif
+
+#endif /* __SOC_ROCKCHIP_PVTM_H */
diff --git a/include/linux/soc/rockchip/rk_fiq_debugger.h b/include/linux/soc/rockchip/rk_fiq_debugger.h
new file mode 100644
index 000000000..f5ec8d143
--- /dev/null
+++ b/include/linux/soc/rockchip/rk_fiq_debugger.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PLAT_RK_FIQ_DEBUGGER_H
+#define __PLAT_RK_FIQ_DEBUGGER_H
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+void fiq_debugger_fiq(void *regs, u32 cpu);
+
+#ifdef CONFIG_ARM_SDE_INTERFACE
+int sdei_fiq_debugger_is_enabled(void);
+int fiq_sdei_event_enable(u32 event_num);
+int fiq_sdei_event_routing_set(u32 event_num, unsigned long flags,
+			       unsigned long affinity);
+int fiq_sdei_event_disable(u32 event_num);
+#else
+static inline int sdei_fiq_debugger_is_enabled(void)
+{
+	return 0;
+}
+#endif
+#endif
+
+#endif
diff --git a/include/linux/soc/rockchip/rk_vendor_storage.h b/include/linux/soc/rockchip/rk_vendor_storage.h
new file mode 100644
index 000000000..33033a4cf
--- /dev/null
+++ b/include/linux/soc/rockchip/rk_vendor_storage.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef __PLAT_RK_VENDOR_STORAGE_H
+#define __PLAT_RK_VENDOR_STORAGE_H
+
+#define RSV_ID				0
+#define SN_ID				1
+#define WIFI_MAC_ID			2
+#define LAN_MAC_ID			3
+#define BT_MAC_ID			4
+#define HDCP_14_HDMI_ID			5
+#define HDCP_14_DP_ID			6
+#define HDCP_2X_ID			7
+#define DRM_KEY_ID			8
+#define PLAYREADY_CERT_ID		9
+#define ATTENTION_KEY_ID		10
+#define PLAYREADY_ROOT_KEY_0_ID		11
+#define PLAYREADY_ROOT_KEY_1_ID		12
+#define SENSOR_CALIBRATION_ID		13
+#define IMEI_ID				15
+#define LAN_RGMII_DL_ID			16
+#define EINK_VCOM_ID			17
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_VENDOR_STORAGE)
+int rk_vendor_read(u32 id, void *pbuf, u32 size);
+int rk_vendor_write(u32 id, void *pbuf, u32 size);
+int rk_vendor_register(void *read, void *write);
+bool is_rk_vendor_ready(void);
+#else
+static inline int rk_vendor_read(u32 id, void *pbuf, u32 size)
+{
+	return -1;
+}
+
+static inline int rk_vendor_write(u32 id, void *pbuf, u32 size)
+{
+	return -1;
+}
+
+static inline int rk_vendor_register(void *read, void *write)
+{
+	return -1;
+}
+
+static inline bool is_rk_vendor_ready(void)
+{
+	return false;
+}
+#endif
+
+#endif
diff --git a/include/linux/soc/rockchip/rockchip_decompress.h b/include/linux/soc/rockchip/rockchip_decompress.h
new file mode 100644
index 000000000..dff419bd7
--- /dev/null
+++ b/include/linux/soc/rockchip/rockchip_decompress.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright (c) 2020 Rockchip Electronics Co., Ltd */
+
+#ifndef _ROCKCHIP_DECOMPRESS
+#define _ROCKCHIP_DECOMPRESS
+
+enum decom_mod {
+	LZ4_MOD,
+	GZIP_MOD,
+	ZLIB_MOD,
+};
+
+#ifdef CONFIG_ROCKCHIP_HW_DECOMPRESS
+int rk_decom_start(u32 mode, phys_addr_t src, phys_addr_t dst, u32 dst_max_size);
+#else
+static inline int rk_decom_start(u32 mode, phys_addr_t src, phys_addr_t dst, u32 dst_max_size)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/include/linux/soc/rockchip/rockchip_thunderboot_crypto.h b/include/linux/soc/rockchip/rockchip_thunderboot_crypto.h
new file mode 100644
index 000000000..2fe176649
--- /dev/null
+++ b/include/linux/soc/rockchip/rockchip_thunderboot_crypto.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright (c) 2021 Rockchip Electronics Co., Ltd */
+
+#ifndef _ROCKCHIP_THUNDERBOOT_CRYPTO_
+#define _ROCKCHIP_THUNDERBOOT_CRYPTO_
+
+int rk_tb_sha256(dma_addr_t data, size_t data_len, void *user_data);
+
+#endif
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index b56e1dedc..ba4246721 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -183,6 +183,7 @@ struct plat_stmmacenet_data {
 	void (*serdes_powerdown)(struct net_device *ndev, void *priv);
 	int (*init)(struct platform_device *pdev, void *priv);
 	void (*exit)(struct platform_device *pdev, void *priv);
+	void (*get_eth_addr)(void *priv, unsigned char *addr);
 	struct mac_device_info *(*setup)(void *priv);
 	void *bsp_priv;
 	struct clk *stmmac_clk;
diff --git a/include/linux/stop_machine.h b/include/linux/stop_machine.h
index 57908e344..ddafb3cf4 100644
--- a/include/linux/stop_machine.h
+++ b/include/linux/stop_machine.h
@@ -28,16 +28,27 @@ struct cpu_stop_work {
 	struct cpu_stop_done	*done;
 };
 
+/*
+ * Structure to determine completion condition and record errors.  May
+ * be shared by works on different cpus.
+ */
+struct cpu_stop_done {
+	atomic_t		nr_todo;	/* nr left to execute */
+	int			ret;		/* collected return value */
+	struct completion	completion;	/* fired if nr_todo reaches 0 */
+};
+
 int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg);
 int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg);
 bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,
 			 struct cpu_stop_work *work_buf);
-#ifdef CONFIG_CPU_ISOLATION_OPT
-int stop_cpus(const struct cpumask *cpumask, cpu_stop_fn_t fn, void *arg);
-#endif
 void stop_machine_park(int cpu);
 void stop_machine_unpark(int cpu);
 void stop_machine_yield(const struct cpumask *cpumask);
+int stop_one_cpu_async(unsigned int cpu, cpu_stop_fn_t fn, void *arg,
+		       struct cpu_stop_work *work_buf,
+		       struct cpu_stop_done *done);
+void cpu_stop_work_wait(struct cpu_stop_work *work_buf);
 
 #else	/* CONFIG_SMP */
 
@@ -83,14 +94,6 @@ static inline bool stop_one_cpu_nowait(unsigned int cpu,
 	return false;
 }
 
-static inline int stop_cpus(const struct cpumask *cpumask,
-			    cpu_stop_fn_t fn, void *arg)
-{
-	if (cpumask_test_cpu(raw_smp_processor_id(), cpumask))
-		return stop_one_cpu(raw_smp_processor_id(), fn, arg);
-	return -ENOENT;
-}
-
 #endif	/* CONFIG_SMP */
 
 /*
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index 176d9454e..aa4b4114b 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -399,6 +399,7 @@ void thermal_cdev_update(struct thermal_cooling_device *);
 void thermal_notify_framework(struct thermal_zone_device *, int);
 int thermal_zone_device_enable(struct thermal_zone_device *tz);
 int thermal_zone_device_disable(struct thermal_zone_device *tz);
+int thermal_zone_device_is_enabled(struct thermal_zone_device *tz);
 #else
 static inline struct thermal_zone_device *thermal_zone_device_register(
 	const char *type, int trips, int mask, void *devdata,
@@ -453,6 +454,10 @@ static inline int thermal_zone_device_enable(struct thermal_zone_device *tz)
 
 static inline int thermal_zone_device_disable(struct thermal_zone_device *tz)
 { return -ENODEV; }
+
+static inline int
+thermal_zone_device_is_enabled(struct thermal_zone_device *tz)
+{ return -ENODEV; }
 #endif /* CONFIG_THERMAL */
 
 #endif /* __THERMAL_H__ */
diff --git a/include/linux/usb/audio-v2.h b/include/linux/usb/audio-v2.h
index ead8c9a47..899c84e7c 100644
--- a/include/linux/usb/audio-v2.h
+++ b/include/linux/usb/audio-v2.h
@@ -168,6 +168,20 @@ struct uac2_effect_unit_descriptor {
 	__u8 bmaControls[]; /* variable length */
 } __attribute__((packed));
 
+#define UAC2_DT_FEATURE_UNIT_SIZE(ch)		(6 + ((ch) + 1) * 4)
+
+/* As above, but more useful for defining your own descriptors: */
+#define DECLARE_UAC2_FEATURE_UNIT_DESCRIPTOR(ch)		\
+struct uac2_feature_unit_descriptor_##ch {			\
+	__u8  bLength;						\
+	__u8  bDescriptorType;					\
+	__u8  bDescriptorSubtype;				\
+	__u8  bUnitID;						\
+	__u8  bSourceID;					\
+	__le32 bmaControls[ch + 1];				\
+	__u8  iFeature;						\
+} __attribute__((packed))
+
 /* 4.9.2 Class-Specific AS Interface Descriptor */
 
 struct uac2_as_header_descriptor {
@@ -331,6 +345,9 @@ struct uac2_interrupt_data_msg {
 #define UAC2_FU_OVERFLOW		0x0f
 #define UAC2_FU_LATENCY			0x10
 
+#define UAC2_CONTROL_BIT_RO(CS)		(0x01 << (((CS) - 1) << 1))
+#define UAC2_CONTROL_BIT_RW(CS)		(0x03 << (((CS) - 1) << 1))
+
 /* A.17.8.1 Parametric Equalizer Section Effect Unit Control Selectors */
 #define UAC2_PE_UNDEFINED		0x00
 #define UAC2_PE_ENABLE			0x01
diff --git a/include/linux/usb/audio.h b/include/linux/usb/audio.h
index 170acd500..646cb0a8d 100644
--- a/include/linux/usb/audio.h
+++ b/include/linux/usb/audio.h
@@ -31,6 +31,7 @@ struct usb_audio_control {
 	int data[5];
 	int (*set)(struct usb_audio_control *con, u8 cmd, int value);
 	int (*get)(struct usb_audio_control *con, u8 cmd);
+	void *context;
 };
 
 struct usb_audio_control_selector {
diff --git a/include/linux/usb/ch9.h b/include/linux/usb/ch9.h
index 604c6c514..1cffa3474 100644
--- a/include/linux/usb/ch9.h
+++ b/include/linux/usb/ch9.h
@@ -36,62 +36,24 @@
 #include <linux/device.h>
 #include <uapi/linux/usb/ch9.h>
 
-/**
- * usb_ep_type_string() - Returns human readable-name of the endpoint type.
- * @ep_type: The endpoint type to return human-readable name for.  If it's not
- *   any of the types: USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT},
- *   usually got by usb_endpoint_type(), the string 'unknown' will be returned.
- */
-extern const char *usb_ep_type_string(int ep_type);
+/* USB 3.2 SuperSpeed Plus phy signaling rate generation and lane count */
 
-/**
- * usb_speed_string() - Returns human readable-name of the speed.
- * @speed: The speed to return human-readable name for.  If it's not
- *   any of the speeds defined in usb_device_speed enum, string for
- *   USB_SPEED_UNKNOWN will be returned.
- */
-extern const char *usb_speed_string(enum usb_device_speed speed);
+enum usb_ssp_rate {
+	USB_SSP_GEN_UNKNOWN = 0,
+	USB_SSP_GEN_2x1,
+	USB_SSP_GEN_1x2,
+	USB_SSP_GEN_2x2,
+};
 
-/**
- * usb_get_maximum_speed - Get maximum requested speed for a given USB
- * controller.
- * @dev: Pointer to the given USB controller device
- *
- * The function gets the maximum speed string from property "maximum-speed",
- * and returns the corresponding enum usb_device_speed.
- */
+extern const char *usb_ep_type_string(int ep_type);
+extern const char *usb_speed_string(enum usb_device_speed speed);
 extern enum usb_device_speed usb_get_maximum_speed(struct device *dev);
-
-/**
- * usb_state_string - Returns human readable name for the state.
- * @state: The state to return a human-readable name for. If it's not
- *	any of the states devices in usb_device_state_string enum,
- *	the string UNKNOWN will be returned.
- */
+extern enum usb_ssp_rate usb_get_maximum_ssp_rate(struct device *dev);
 extern const char *usb_state_string(enum usb_device_state state);
+unsigned int usb_decode_interval(const struct usb_endpoint_descriptor *epd,
+				 enum usb_device_speed speed);
 
 #ifdef CONFIG_TRACING
-/**
- * usb_decode_ctrl - Returns human readable representation of control request.
- * @str: buffer to return a human-readable representation of control request.
- *       This buffer should have about 200 bytes.
- * @size: size of str buffer.
- * @bRequestType: matches the USB bmRequestType field
- * @bRequest: matches the USB bRequest field
- * @wValue: matches the USB wValue field (CPU byte order)
- * @wIndex: matches the USB wIndex field (CPU byte order)
- * @wLength: matches the USB wLength field (CPU byte order)
- *
- * Function returns decoded, formatted and human-readable description of
- * control request packet.
- *
- * The usage scenario for this is for tracepoints, so function as a return
- * use the same value as in parameters. This approach allows to use this
- * function in TP_printk
- *
- * Important: wValue, wIndex, wLength parameters before invoking this function
- * should be processed by le16_to_cpu macro.
- */
 extern const char *usb_decode_ctrl(char *str, size_t size, __u8 bRequestType,
 				   __u8 bRequest, __u16 wValue, __u16 wIndex,
 				   __u16 wLength);
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index a2d229ab6..4d352204e 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -525,6 +525,8 @@ extern struct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,
 extern int usb_string_ids_n(struct usb_composite_dev *c, unsigned n);
 
 extern void composite_disconnect(struct usb_gadget *gadget);
+extern void composite_reset(struct usb_gadget *gadget);
+
 extern int composite_setup(struct usb_gadget *gadget,
 		const struct usb_ctrlrequest *ctrl);
 extern void composite_suspend(struct usb_gadget *gadget);
@@ -590,6 +592,7 @@ struct usb_function_instance {
 	struct config_group group;
 	struct list_head cfs_list;
 	struct usb_function_driver *fd;
+	struct usb_function *f;
 	int (*set_inst_name)(struct usb_function_instance *inst,
 			      const char *name);
 	void (*free_func_inst)(struct usb_function_instance *inst);
diff --git a/include/linux/usb/f_accessory.h b/include/linux/usb/f_accessory.h
new file mode 100644
index 000000000..ebe3c4d59
--- /dev/null
+++ b/include/linux/usb/f_accessory.h
@@ -0,0 +1,23 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_USB_F_ACCESSORY_H
+#define __LINUX_USB_F_ACCESSORY_H
+
+#include <uapi/linux/usb/f_accessory.h>
+
+#endif /* __LINUX_USB_F_ACCESSORY_H */
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index e7351d64f..a15700a40 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -217,6 +217,7 @@ struct usb_ep_caps {
  *	enabled and remains valid until the endpoint is disabled.
  * @comp_desc: In case of SuperSpeed support, this is the endpoint companion
  *	descriptor that is used to configure the endpoint
+ * @transfer_type: Used to specify transfer type of EP.
  *
  * the bus controller driver lists all the general purpose endpoints in
  * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
@@ -240,6 +241,9 @@ struct usb_ep {
 	u8			address;
 	const struct usb_endpoint_descriptor	*desc;
 	const struct usb_ss_ep_comp_descriptor	*comp_desc;
+#if defined(CONFIG_ARCH_ROCKCHIP) && defined(CONFIG_NO_GKI)
+	u8			transfer_type;
+#endif
 };
 
 /*-------------------------------------------------------------------------*/
@@ -323,6 +327,8 @@ struct usb_gadget_ops {
 			struct usb_gadget_driver *);
 	int	(*udc_stop)(struct usb_gadget *);
 	void	(*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
+	void	(*udc_set_ssp_rate)(struct usb_gadget *gadget,
+			enum usb_ssp_rate rate);
 	struct usb_ep *(*match_ep)(struct usb_gadget *,
 			struct usb_endpoint_descriptor *,
 			struct usb_ss_ep_comp_descriptor *);
@@ -339,6 +345,10 @@ struct usb_gadget_ops {
  * @speed: Speed of current connection to USB host.
  * @max_speed: Maximal speed the UDC can handle.  UDC must support this
  *      and all slower speeds.
+ * @ssp_rate: Current connected SuperSpeed Plus signaling rate and lane count.
+ * @max_ssp_rate: Maximum SuperSpeed Plus signaling rate and lane count the UDC
+ *	can handle. The UDC must support this and all slower speeds and lower
+ *	number of lanes.
  * @state: the state we are now (attached, suspended, configured, etc)
  * @name: Identifies the controller hardware type.  Used in diagnostics
  *	and sometimes configuration.
@@ -406,6 +416,11 @@ struct usb_gadget {
 	struct list_head		ep_list;	/* of usb_ep */
 	enum usb_device_speed		speed;
 	enum usb_device_speed		max_speed;
+
+	/* USB SuperSpeed Plus only */
+	enum usb_ssp_rate		ssp_rate;
+	enum usb_ssp_rate		max_ssp_rate;
+
 	enum usb_device_state		state;
 	const char			*name;
 	struct device			dev;
diff --git a/include/linux/usb/pd.h b/include/linux/usb/pd.h
index 433040ff8..96b7ff66f 100644
--- a/include/linux/usb/pd.h
+++ b/include/linux/usb/pd.h
@@ -225,6 +225,7 @@ enum pd_pdo_type {
 #define PDO_FIXED_EXTPOWER		BIT(27) /* Externally powered */
 #define PDO_FIXED_USB_COMM		BIT(26) /* USB communications capable */
 #define PDO_FIXED_DATA_SWAP		BIT(25) /* Data role swap supported */
+#define PDO_FIXED_UNCHUNK_EXT		BIT(24) /* Unchunked Extended Message supported (Source) */
 #define PDO_FIXED_FRS_CURR_MASK		(BIT(24) | BIT(23)) /* FR_Swap Current (Sink) */
 #define PDO_FIXED_FRS_CURR_SHIFT	23
 #define PDO_FIXED_VOLT_SHIFT		10	/* 50mV units */
@@ -466,6 +467,7 @@ static inline unsigned int rdo_max_power(u32 rdo)
 #define PD_T_DRP_SRC		30
 #define PD_T_PS_SOURCE_OFF	920
 #define PD_T_PS_SOURCE_ON	480
+#define PD_T_PS_SOURCE_ON_PRS	450	/* 390 - 480ms */
 #define PD_T_PS_HARD_RESET	30
 #define PD_T_SRC_RECOVER	760
 #define PD_T_SRC_RECOVER_MAX	1000
@@ -478,14 +480,19 @@ static inline unsigned int rdo_max_power(u32 rdo)
 #define PD_T_NEWSRC		250	/* Maximum of 275ms */
 #define PD_T_SWAP_SRC_START	20	/* Minimum of 20ms */
 #define PD_T_BIST_CONT_MODE	50	/* 30 - 60 ms */
+#define PD_T_SINK_TX		16	/* 16 - 20 ms */
+#define PD_T_CHUNK_NOT_SUPP	42	/* 40 - 50 ms */
 
 #define PD_T_DRP_TRY		100	/* 75 - 150 ms */
 #define PD_T_DRP_TRYWAIT	600	/* 400 - 800 ms */
 
 #define PD_T_CC_DEBOUNCE	200	/* 100 - 200 ms */
 #define PD_T_PD_DEBOUNCE	20	/* 10 - 20 ms */
+#define PD_T_TRY_CC_DEBOUNCE	15	/* 10 - 20 ms */
 
 #define PD_N_CAPS_COUNT		(PD_T_NO_RESPONSE / PD_T_SEND_SOURCE_CAP)
 #define PD_N_HARD_RESET_COUNT	2
 
+#define PD_P_SNK_STDBY_MW	2500	/* 2500 mW */
+
 #endif /* __LINUX_USB_PD_H */
diff --git a/include/linux/usb/pd_ext_sdb.h b/include/linux/usb/pd_ext_sdb.h
index 0eb83ce19..b517ebc8f 100644
--- a/include/linux/usb/pd_ext_sdb.h
+++ b/include/linux/usb/pd_ext_sdb.h
@@ -24,8 +24,4 @@ enum usb_pd_ext_sdb_fields {
 #define USB_PD_EXT_SDB_EVENT_OVP		BIT(3)
 #define USB_PD_EXT_SDB_EVENT_CF_CV_MODE		BIT(4)
 
-#define USB_PD_EXT_SDB_PPS_EVENTS	(USB_PD_EXT_SDB_EVENT_OCP |	\
-					 USB_PD_EXT_SDB_EVENT_OTP |	\
-					 USB_PD_EXT_SDB_EVENT_OVP)
-
 #endif /* __LINUX_USB_PD_EXT_SDB_H */
diff --git a/include/linux/usb/pd_vdo.h b/include/linux/usb/pd_vdo.h
index 68bdc4e2f..7f5e330a6 100644
--- a/include/linux/usb/pd_vdo.h
+++ b/include/linux/usb/pd_vdo.h
@@ -21,22 +21,24 @@
  * ----------
  * <31:16>  :: SVID
  * <15>     :: VDM type ( 1b == structured, 0b == unstructured )
- * <14:13>  :: Structured VDM version (can only be 00 == 1.0 currently)
+ * <14:13>  :: Structured VDM version
  * <12:11>  :: reserved
  * <10:8>   :: object position (1-7 valid ... used for enter/exit mode only)
  * <7:6>    :: command type (SVDM only?)
  * <5>      :: reserved (SVDM), command type (UVDM)
  * <4:0>    :: command
  */
-#define VDO(vid, type, custom)				\
+#define VDO(vid, type, ver, custom)			\
 	(((vid) << 16) |				\
 	 ((type) << 15) |				\
+	 ((ver) << 13) |				\
 	 ((custom) & 0x7FFF))
 
 #define VDO_SVDM_TYPE		(1 << 15)
 #define VDO_SVDM_VERS(x)	((x) << 13)
 #define VDO_OPOS(x)		((x) << 8)
 #define VDO_CMDT(x)		((x) << 6)
+#define VDO_SVDM_VERS_MASK	VDO_SVDM_VERS(0x3)
 #define VDO_OPOS_MASK		VDO_OPOS(0x7)
 #define VDO_CMDT_MASK		VDO_CMDT(0x3)
 
@@ -74,6 +76,7 @@
 
 #define PD_VDO_VID(vdo)		((vdo) >> 16)
 #define PD_VDO_SVDM(vdo)	(((vdo) >> 15) & 1)
+#define PD_VDO_SVDM_VER(vdo)	(((vdo) >> 13) & 0x3)
 #define PD_VDO_OPOS(vdo)	(((vdo) >> 8) & 0x7)
 #define PD_VDO_CMD(vdo)		((vdo) & 0x1f)
 #define PD_VDO_CMDT(vdo)	(((vdo) >> 6) & 0x3)
@@ -103,25 +106,50 @@
  * --------------------
  * <31>     :: data capable as a USB host
  * <30>     :: data capable as a USB device
- * <29:27>  :: product type
+ * <29:27>  :: product type (UFP / Cable / VPD)
  * <26>     :: modal operation supported (1b == yes)
- * <25:16>  :: Reserved, Shall be set to zero
+ * <25:23>  :: product type (DFP) (SVDM version 2.0+ only; set to zero in version 1.0)
+ * <22:21>  :: connector type (SVDM version 2.0+ only; set to zero in version 1.0)
+ * <20:16>  :: Reserved, Shall be set to zero
  * <15:0>   :: USB-IF assigned VID for this cable vendor
  */
+
+/* PD Rev2.0 definition */
 #define IDH_PTYPE_UNDEF		0
+
+/* SOP Product Type (UFP) */
+#define IDH_PTYPE_NOT_UFP	0
 #define IDH_PTYPE_HUB		1
 #define IDH_PTYPE_PERIPH	2
+#define IDH_PTYPE_PSD		3
+#define IDH_PTYPE_AMA		5
+
+/* SOP' Product Type (Cable Plug / VPD) */
+#define IDH_PTYPE_NOT_CABLE	0
 #define IDH_PTYPE_PCABLE	3
 #define IDH_PTYPE_ACABLE	4
-#define IDH_PTYPE_AMA		5
+#define IDH_PTYPE_VPD		6
 
-#define VDO_IDH(usbh, usbd, ptype, is_modal, vid)		\
-	((usbh) << 31 | (usbd) << 30 | ((ptype) & 0x7) << 27	\
-	 | (is_modal) << 26 | ((vid) & 0xffff))
+/* SOP Product Type (DFP) */
+#define IDH_PTYPE_NOT_DFP	0
+#define IDH_PTYPE_DFP_HUB	1
+#define IDH_PTYPE_DFP_HOST	2
+#define IDH_PTYPE_DFP_PB	3
+
+/* ID Header Mask */
+#define IDH_DFP_MASK		GENMASK(25, 23)
+#define IDH_CONN_MASK		GENMASK(22, 21)
+
+#define VDO_IDH(usbh, usbd, ufp_cable, is_modal, dfp, conn, vid)		\
+	((usbh) << 31 | (usbd) << 30 | ((ufp_cable) & 0x7) << 27		\
+	 | (is_modal) << 26 | ((dfp) & 0x7) << 23 | ((conn) & 0x3) << 21	\
+	 | ((vid) & 0xffff))
 
 #define PD_IDH_PTYPE(vdo)	(((vdo) >> 27) & 0x7)
 #define PD_IDH_VID(vdo)		((vdo) & 0xffff)
 #define PD_IDH_MODAL_SUPP(vdo)	((vdo) & (1 << 26))
+#define PD_IDH_DFP_PTYPE(vdo)	(((vdo) >> 23) & 0x7)
+#define PD_IDH_CONN_TYPE(vdo)	(((vdo) >> 21) & 0x3)
 
 /*
  * Cert Stat VDO
@@ -129,6 +157,7 @@
  * <31:0>  : USB-IF assigned XID for this cable
  */
 #define PD_CSTAT_XID(vdo)	(vdo)
+#define VDO_CERT(xid)		((xid) & 0xffffffff)
 
 /*
  * Product VDO
@@ -140,77 +169,270 @@
 #define PD_PRODUCT_PID(vdo)	(((vdo) >> 16) & 0xffff)
 
 /*
- * UFP VDO1
+ * UFP VDO (PD Revision 3.0+ only)
  * --------
  * <31:29> :: UFP VDO version
  * <28>    :: Reserved
  * <27:24> :: Device capability
- * <23:6>  :: Reserved
+ * <23:22> :: Connector type (10b == receptacle, 11b == captive plug)
+ * <21:11> :: Reserved
+ * <10:8>  :: Vconn power (AMA only)
+ * <7>     :: Vconn required (AMA only, 0b == no, 1b == yes)
+ * <6>     :: Vbus required (AMA only, 0b == yes, 1b == no)
  * <5:3>   :: Alternate modes
  * <2:0>   :: USB highest speed
  */
-#define PD_VDO1_UFP_DEVCAP(vdo)	(((vdo) & GENMASK(27, 24)) >> 24)
+#define PD_VDO_UFP_DEVCAP(vdo)	(((vdo) & GENMASK(27, 24)) >> 24)
 
+/* UFP VDO Version */
+#define UFP_VDO_VER1_2		2
+
+/* Device Capability */
 #define DEV_USB2_CAPABLE	BIT(0)
 #define DEV_USB2_BILLBOARD	BIT(1)
 #define DEV_USB3_CAPABLE	BIT(2)
 #define DEV_USB4_CAPABLE	BIT(3)
 
+/* Connector Type */
+#define UFP_RECEPTACLE		2
+#define UFP_CAPTIVE		3
+
+/* Vconn Power (AMA only, set to AMA_VCONN_NOT_REQ if Vconn is not required) */
+#define AMA_VCONN_PWR_1W	0
+#define AMA_VCONN_PWR_1W5	1
+#define AMA_VCONN_PWR_2W	2
+#define AMA_VCONN_PWR_3W	3
+#define AMA_VCONN_PWR_4W	4
+#define AMA_VCONN_PWR_5W	5
+#define AMA_VCONN_PWR_6W	6
+
+/* Vconn Required (AMA only) */
+#define AMA_VCONN_NOT_REQ	0
+#define AMA_VCONN_REQ		1
+
+/* Vbus Required (AMA only) */
+#define AMA_VBUS_REQ		0
+#define AMA_VBUS_NOT_REQ	1
+
+/* Alternate Modes */
+#define UFP_ALTMODE_NOT_SUPP	0
+#define UFP_ALTMODE_TBT3	BIT(0)
+#define UFP_ALTMODE_RECFG	BIT(1)
+#define UFP_ALTMODE_NO_RECFG	BIT(2)
+
+/* USB Highest Speed */
+#define UFP_USB2_ONLY		0
+#define UFP_USB32_GEN1		1
+#define UFP_USB32_4_GEN2	2
+#define UFP_USB4_GEN3		3
+
+#define VDO_UFP(ver, cap, conn, vcpwr, vcr, vbr, alt, spd)			\
+	(((ver) & 0x7) << 29 | ((cap) & 0xf) << 24 | ((conn) & 0x3) << 22	\
+	 | ((vcpwr) & 0x7) << 8 | (vcr) << 7 | (vbr) << 6 | ((alt) & 0x7) << 3	\
+	 | ((spd) & 0x7))
+
 /*
- * DFP VDO
+ * DFP VDO (PD Revision 3.0+ only)
  * --------
  * <31:29> :: DFP VDO version
  * <28:27> :: Reserved
  * <26:24> :: Host capability
- * <23:5>  :: Reserved
+ * <23:22> :: Connector type (10b == receptacle, 11b == captive plug)
+ * <21:5>  :: Reserved
  * <4:0>   :: Port number
  */
 #define PD_VDO_DFP_HOSTCAP(vdo)	(((vdo) & GENMASK(26, 24)) >> 24)
 
+#define DFP_VDO_VER1_1		1
 #define HOST_USB2_CAPABLE	BIT(0)
 #define HOST_USB3_CAPABLE	BIT(1)
 #define HOST_USB4_CAPABLE	BIT(2)
+#define DFP_RECEPTACLE		2
+#define DFP_CAPTIVE		3
+
+#define VDO_DFP(ver, cap, conn, pnum)						\
+	(((ver) & 0x7) << 29 | ((cap) & 0x7) << 24 | ((conn) & 0x3) << 22	\
+	 | ((pnum) & 0x1f))
 
 /*
- * Cable VDO
+ * Cable VDO (for both Passive and Active Cable VDO in PD Rev2.0)
  * ---------
  * <31:28> :: Cable HW version
  * <27:24> :: Cable FW version
  * <23:20> :: Reserved, Shall be set to zero
- * <19:18> :: type-C to Type-A/B/C (00b == A, 01 == B, 10 == C)
- * <17>    :: Type-C to Plug/Receptacle (0b == plug, 1b == receptacle)
+ * <19:18> :: type-C to Type-A/B/C/Captive (00b == A, 01 == B, 10 == C, 11 == Captive)
+ * <17>    :: Reserved, Shall be set to zero
  * <16:13> :: cable latency (0001 == <10ns(~1m length))
  * <12:11> :: cable termination type (11b == both ends active VCONN req)
  * <10>    :: SSTX1 Directionality support (0b == fixed, 1b == cfgable)
  * <9>     :: SSTX2 Directionality support
  * <8>     :: SSRX1 Directionality support
  * <7>     :: SSRX2 Directionality support
- * <6:5>   :: Vbus current handling capability
+ * <6:5>   :: Vbus current handling capability (01b == 3A, 10b == 5A)
  * <4>     :: Vbus through cable (0b == no, 1b == yes)
  * <3>     :: SOP" controller present? (0b == no, 1b == yes)
  * <2:0>   :: USB SS Signaling support
+ *
+ * Passive Cable VDO (PD Rev3.0+)
+ * ---------
+ * <31:28> :: Cable HW version
+ * <27:24> :: Cable FW version
+ * <23:21> :: VDO version
+ * <20>    :: Reserved, Shall be set to zero
+ * <19:18> :: Type-C to Type-C/Captive (10b == C, 11b == Captive)
+ * <17>    :: Reserved, Shall be set to zero
+ * <16:13> :: cable latency (0001 == <10ns(~1m length))
+ * <12:11> :: cable termination type (10b == Vconn not req, 01b == Vconn req)
+ * <10:9>  :: Maximum Vbus voltage (00b == 20V, 01b == 30V, 10b == 40V, 11b == 50V)
+ * <8:7>   :: Reserved, Shall be set to zero
+ * <6:5>   :: Vbus current handling capability (01b == 3A, 10b == 5A)
+ * <4:3>   :: Reserved, Shall be set to zero
+ * <2:0>   :: USB highest speed
+ *
+ * Active Cable VDO 1 (PD Rev3.0+)
+ * ---------
+ * <31:28> :: Cable HW version
+ * <27:24> :: Cable FW version
+ * <23:21> :: VDO version
+ * <20>    :: Reserved, Shall be set to zero
+ * <19:18> :: Connector type (10b == C, 11b == Captive)
+ * <17>    :: Reserved, Shall be set to zero
+ * <16:13> :: cable latency (0001 == <10ns(~1m length))
+ * <12:11> :: cable termination type (10b == one end active, 11b == both ends active VCONN req)
+ * <10:9>  :: Maximum Vbus voltage (00b == 20V, 01b == 30V, 10b == 40V, 11b == 50V)
+ * <8>     :: SBU supported (0b == supported, 1b == not supported)
+ * <7>     :: SBU type (0b == passive, 1b == active)
+ * <6:5>   :: Vbus current handling capability (01b == 3A, 10b == 5A)
+ * <2:0>   :: USB highest speed
  */
+/* Cable VDO Version */
+#define CABLE_VDO_VER1_0	0
+#define CABLE_VDO_VER1_3	3
+
+/* Connector Type (_ATYPE and _BTYPE are for PD Rev2.0 only) */
 #define CABLE_ATYPE		0
 #define CABLE_BTYPE		1
 #define CABLE_CTYPE		2
-#define CABLE_PLUG		0
-#define CABLE_RECEPTACLE	1
-#define CABLE_CURR_1A5		0
+#define CABLE_CAPTIVE		3
+
+/* Cable Latency */
+#define CABLE_LATENCY_1M	1
+#define CABLE_LATENCY_2M	2
+#define CABLE_LATENCY_3M	3
+#define CABLE_LATENCY_4M	4
+#define CABLE_LATENCY_5M	5
+#define CABLE_LATENCY_6M	6
+#define CABLE_LATENCY_7M	7
+#define CABLE_LATENCY_7M_PLUS	8
+
+/* Cable Termination Type */
+#define PCABLE_VCONN_NOT_REQ	0
+#define PCABLE_VCONN_REQ	1
+#define ACABLE_ONE_END		2
+#define ACABLE_BOTH_END		3
+
+/* Maximum Vbus Voltage */
+#define CABLE_MAX_VBUS_20V	0
+#define CABLE_MAX_VBUS_30V	1
+#define CABLE_MAX_VBUS_40V	2
+#define CABLE_MAX_VBUS_50V	3
+
+/* Active Cable SBU Supported/Type */
+#define ACABLE_SBU_SUPP		0
+#define ACABLE_SBU_NOT_SUPP	1
+#define ACABLE_SBU_PASSIVE	0
+#define ACABLE_SBU_ACTIVE	1
+
+/* Vbus Current Handling Capability */
+#define CABLE_CURR_DEF		0
 #define CABLE_CURR_3A		1
 #define CABLE_CURR_5A		2
+
+/* USB SuperSpeed Signaling Support (PD Rev2.0) */
 #define CABLE_USBSS_U2_ONLY	0
 #define CABLE_USBSS_U31_GEN1	1
 #define CABLE_USBSS_U31_GEN2	2
-#define VDO_CABLE(hw, fw, cbl, gdr, lat, term, tx1d, tx2d, rx1d, rx2d, cur,\
-		  vps, sopp, usbss) \
-	(((hw) & 0x7) << 28 | ((fw) & 0x7) << 24 | ((cbl) & 0x3) << 18	\
-	 | (gdr) << 17 | ((lat) & 0x7) << 13 | ((term) & 0x3) << 11	\
-	 | (tx1d) << 10 | (tx2d) << 9 | (rx1d) << 8 | (rx2d) << 7	\
-	 | ((cur) & 0x3) << 5 | (vps) << 4 | (sopp) << 3		\
-	 | ((usbss) & 0x7))
+
+/* USB Highest Speed */
+#define CABLE_USB2_ONLY		0
+#define CABLE_USB32_GEN1	1
+#define CABLE_USB32_4_GEN2	2
+#define CABLE_USB4_GEN3		3
+
+#define VDO_CABLE(hw, fw, cbl, lat, term, tx1d, tx2d, rx1d, rx2d, cur, vps, sopp, usbss) \
+	(((hw) & 0x7) << 28 | ((fw) & 0x7) << 24 | ((cbl) & 0x3) << 18		\
+	 | ((lat) & 0x7) << 13 | ((term) & 0x3) << 11 | (tx1d) << 10		\
+	 | (tx2d) << 9 | (rx1d) << 8 | (rx2d) << 7 | ((cur) & 0x3) << 5		\
+	 | (vps) << 4 | (sopp) << 3 | ((usbss) & 0x7))
+#define VDO_PCABLE(hw, fw, ver, conn, lat, term, vbm, cur, spd)			\
+	(((hw) & 0xf) << 28 | ((fw) & 0xf) << 24 | ((ver) & 0x7) << 21		\
+	 | ((conn) & 0x3) << 18 | ((lat) & 0xf) << 13 | ((term) & 0x3) << 11	\
+	 | ((vbm) & 0x3) << 9 | ((cur) & 0x3) << 5 | ((spd) & 0x7))
+#define VDO_ACABLE1(hw, fw, ver, conn, lat, term, vbm, sbu, sbut, cur, vbt, sopp, spd) \
+	(((hw) & 0xf) << 28 | ((fw) & 0xf) << 24 | ((ver) & 0x7) << 21		\
+	 | ((conn) & 0x3) << 18	| ((lat) & 0xf) << 13 | ((term) & 0x3) << 11	\
+	 | ((vbm) & 0x3) << 9 | (sbu) << 8 | (sbut) << 7 | ((cur) & 0x3) << 5	\
+	 | (vbt) << 4 | (sopp) << 3 | ((spd) & 0x7))
+
+#define VDO_TYPEC_CABLE_TYPE(vdo)	(((vdo) >> 18) & 0x3)
+
+/*
+ * Active Cable VDO 2
+ * ---------
+ * <31:24> :: Maximum operating temperature
+ * <23:16> :: Shutdown temperature
+ * <15>    :: Reserved, Shall be set to zero
+ * <14:12> :: U3/CLd power
+ * <11>    :: U3 to U0 transition mode (0b == direct, 1b == through U3S)
+ * <10>    :: Physical connection (0b == copper, 1b == optical)
+ * <9>     :: Active element (0b == redriver, 1b == retimer)
+ * <8>     :: USB4 supported (0b == yes, 1b == no)
+ * <7:6>   :: USB2 hub hops consumed
+ * <5>     :: USB2 supported (0b == yes, 1b == no)
+ * <4>     :: USB3.2 supported (0b == yes, 1b == no)
+ * <3>     :: USB lanes supported (0b == one lane, 1b == two lanes)
+ * <2>     :: Optically isolated active cable (0b == no, 1b == yes)
+ * <1>     :: Reserved, Shall be set to zero
+ * <0>     :: USB gen (0b == gen1, 1b == gen2+)
+ */
+
+/* U3/CLd Power*/
+#define ACAB2_U3_CLD_10MW_PLUS	0
+#define ACAB2_U3_CLD_10MW	1
+#define ACAB2_U3_CLD_5MW	2
+#define ACAB2_U3_CLD_1MW	3
+#define ACAB2_U3_CLD_500UW	4
+#define ACAB2_U3_CLD_200UW	5
+#define ACAB2_U3_CLD_50UW	6
+
+/* Other Active Cable VDO 2 Fields */
+#define ACAB2_U3U0_DIRECT	0
+#define ACAB2_U3U0_U3S		1
+#define ACAB2_PHY_COPPER	0
+#define ACAB2_PHY_OPTICAL	1
+#define ACAB2_REDRIVER		0
+#define ACAB2_RETIMER		1
+#define ACAB2_USB4_SUPP		0
+#define ACAB2_USB4_NOT_SUPP	1
+#define ACAB2_USB2_SUPP		0
+#define ACAB2_USB2_NOT_SUPP	1
+#define ACAB2_USB32_SUPP	0
+#define ACAB2_USB32_NOT_SUPP	1
+#define ACAB2_LANES_ONE		0
+#define ACAB2_LANES_TWO		1
+#define ACAB2_OPT_ISO_NO	0
+#define ACAB2_OPT_ISO_YES	1
+#define ACAB2_GEN_1		0
+#define ACAB2_GEN_2_PLUS	1
+
+#define VDO_ACABLE2(mtemp, stemp, u3p, trans, phy, ele, u4, hops, u2, u32, lane, iso, gen)	\
+	(((mtemp) & 0xff) << 24 | ((stemp) & 0xff) << 16 | ((u3p) & 0x7) << 12	\
+	 | (trans) << 11 | (phy) << 10 | (ele) << 9 | (u4) << 8			\
+	 | ((hops) & 0x3) << 6 | (u2) << 5 | (u32) << 4 | (lane) << 3		\
+	 | (iso) << 2 | (gen))
 
 /*
- * AMA VDO
+ * AMA VDO (PD Rev2.0)
  * ---------
  * <31:28> :: Cable HW version
  * <27:24> :: Cable FW version
@@ -233,18 +455,40 @@
 #define PD_VDO_AMA_VCONN_REQ(vdo)	(((vdo) >> 4) & 1)
 #define PD_VDO_AMA_VBUS_REQ(vdo)	(((vdo) >> 3) & 1)
 
-#define AMA_VCONN_PWR_1W	0
-#define AMA_VCONN_PWR_1W5	1
-#define AMA_VCONN_PWR_2W	2
-#define AMA_VCONN_PWR_3W	3
-#define AMA_VCONN_PWR_4W	4
-#define AMA_VCONN_PWR_5W	5
-#define AMA_VCONN_PWR_6W	6
 #define AMA_USBSS_U2_ONLY	0
 #define AMA_USBSS_U31_GEN1	1
 #define AMA_USBSS_U31_GEN2	2
 #define AMA_USBSS_BBONLY	3
 
+/*
+ * VPD VDO
+ * ---------
+ * <31:28> :: HW version
+ * <27:24> :: FW version
+ * <23:21> :: VDO version
+ * <20:17> :: Reserved, Shall be set to zero
+ * <16:15> :: Maximum Vbus voltage (00b == 20V, 01b == 30V, 10b == 40V, 11b == 50V)
+ * <14>    :: Charge through current support (0b == 3A, 1b == 5A)
+ * <13>    :: Reserved, Shall be set to zero
+ * <12:7>  :: Vbus impedance
+ * <6:1>   :: Ground impedance
+ * <0>     :: Charge through support (0b == no, 1b == yes)
+ */
+#define VPD_VDO_VER1_0		0
+#define VPD_MAX_VBUS_20V	0
+#define VPD_MAX_VBUS_30V	1
+#define VPD_MAX_VBUS_40V	2
+#define VPD_MAX_VBUS_50V	3
+#define VPDCT_CURR_3A		0
+#define VPDCT_CURR_5A		1
+#define VPDCT_NOT_SUPP		0
+#define VPDCT_SUPP		1
+
+#define VDO_VPD(hw, fw, ver, vbm, curr, vbi, gi, ct)			\
+	(((hw) & 0xf) << 28 | ((fw) & 0xf) << 24 | ((ver) & 0x7) << 21	\
+	 | ((vbm) & 0x3) << 15 | (curr) << 14 | ((vbi) & 0x3f) << 7	\
+	 | ((gi) & 0x3f) << 1 | (ct))
+
 /*
  * SVDM Discover SVIDs request -> response
  *
diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
index 5e4c497f5..6567f7445 100644
--- a/include/linux/usb/quirks.h
+++ b/include/linux/usb/quirks.h
@@ -72,4 +72,7 @@
 /* device has endpoints that should be ignored */
 #define USB_QUIRK_ENDPOINT_IGNORE		BIT(15)
 
+/* device can't support auto suspend function */
+#define USB_QUIRK_AUTO_SUSPEND			BIT(16)
+
 #endif /* __LINUX_USB_QUIRKS_H */
diff --git a/include/linux/usb/tcpm.h b/include/linux/usb/tcpm.h
index 09762d26f..cb69546f8 100644
--- a/include/linux/usb/tcpm.h
+++ b/include/linux/usb/tcpm.h
@@ -19,6 +19,10 @@ enum typec_cc_status {
 	TYPEC_CC_RP_3_0,
 };
 
+/* Collision Avoidance */
+#define SINK_TX_NG	TYPEC_CC_RP_1_5
+#define SINK_TX_OK	TYPEC_CC_RP_3_0
+
 enum typec_cc_polarity {
 	TYPEC_POLARITY_CC1,
 	TYPEC_POLARITY_CC2,
@@ -62,6 +66,8 @@ enum tcpm_transmit_type {
  *		For example, some tcpcs may include BC1.2 charger detection
  *		and use that in this case.
  * @set_cc:	Called to set value of CC pins
+ * @apply_rc:	Optional; Needed to move TCPCI based chipset to APPLY_RC state
+ *		as stated by the TCPCI specification.
  * @get_cc:	Called to read current CC pin values
  * @set_polarity:
  *		Called to set polarity
@@ -83,6 +89,39 @@ enum tcpm_transmit_type {
  *		Optional; Called to enable/disable PD 3.0 fast role swap.
  *		Enabling frs is accessory dependent as not all PD3.0
  *		accessories support fast role swap.
+ * @frs_sourcing_vbus:
+ *		Optional; Called to notify that vbus is now being sourced.
+ *		Low level drivers can perform chip specific operations, if any.
+ * @enable_auto_vbus_discharge:
+ *		Optional; TCPCI spec based TCPC implementations can optionally
+ *		support hardware to autonomously dischrge vbus upon disconnecting
+ *		as sink or source. TCPM signals TCPC to enable the mechanism upon
+ *		entering connected state and signals disabling upon disconnect.
+ * @set_auto_vbus_discharge_threshold:
+ *		Mandatory when enable_auto_vbus_discharge is implemented. TCPM
+ *		calls this function to allow lower levels drivers to program the
+ *		vbus threshold voltage below which the vbus discharge circuit
+ *		will be turned on. requested_vbus_voltage is set to 0 when vbus
+ *		is going to disappear knowingly i.e. during PR_SWAP and
+ *		HARD_RESET etc.
+ * @is_vbus_vsafe0v:
+ *		Optional; TCPCI spec based TCPC implementations are expected to
+ *		detect VSAFE0V voltage level at vbus. When detection of VSAFE0V
+ *		is supported by TCPC, set this callback for TCPM to query
+ *		whether vbus is at VSAFE0V when needed.
+ *		Returns true when vbus is at VSAFE0V, false otherwise.
+ * @set_partner_usb_comm_capable:
+ *              Optional; The USB Communications Capable bit indicates if port
+ *              partner is capable of communication over the USB data lines
+ *              (e.g. D+/- or SS Tx/Rx). Called to notify the status of the bit.
+ * @check_contaminant:
+ *		Optional; The callback is called when CC pins report open status
+ *		at the end of the toggling period. Chip level drivers are
+ *		expected to check for contaminant and re-enable toggling if
+ *		needed. When 0 is not returned, check_contaminant is expected to
+ *		restart toggling after checking the connector for contaminant.
+ *		This forces the TCPM state machine to tranistion to TOGGLING state
+ *		without calling start_toggling callback.
  */
 struct tcpc_dev {
 	struct fwnode_handle *fwnode;
@@ -91,6 +130,8 @@ struct tcpc_dev {
 	int (*get_vbus)(struct tcpc_dev *dev);
 	int (*get_current_limit)(struct tcpc_dev *dev);
 	int (*set_cc)(struct tcpc_dev *dev, enum typec_cc_status cc);
+	int (*apply_rc)(struct tcpc_dev *dev, enum typec_cc_status cc,
+			enum typec_cc_polarity polarity);
 	int (*get_cc)(struct tcpc_dev *dev, enum typec_cc_status *cc1,
 		      enum typec_cc_status *cc2);
 	int (*set_polarity)(struct tcpc_dev *dev,
@@ -106,9 +147,16 @@ struct tcpc_dev {
 			      enum typec_cc_status cc);
 	int (*try_role)(struct tcpc_dev *dev, int role);
 	int (*pd_transmit)(struct tcpc_dev *dev, enum tcpm_transmit_type type,
-			   const struct pd_message *msg);
+			   const struct pd_message *msg, unsigned int negotiated_rev);
 	int (*set_bist_data)(struct tcpc_dev *dev, bool on);
 	int (*enable_frs)(struct tcpc_dev *dev, bool enable);
+	void (*frs_sourcing_vbus)(struct tcpc_dev *dev);
+	int (*enable_auto_vbus_discharge)(struct tcpc_dev *dev, bool enable);
+	int (*set_auto_vbus_discharge_threshold)(struct tcpc_dev *dev, enum typec_pwr_opmode mode,
+						 bool pps_active, u32 requested_vbus_voltage);
+	int (*check_contaminant)(struct tcpc_dev *dev);
+	bool (*is_vbus_vsafe0v)(struct tcpc_dev *dev);
+	void (*set_partner_usb_comm_capable)(struct tcpc_dev *dev, bool enable);
 };
 
 struct tcpm_port;
@@ -116,6 +164,10 @@ struct tcpm_port;
 struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc);
 void tcpm_unregister_port(struct tcpm_port *port);
 
+int tcpm_update_sink_capabilities(struct tcpm_port *port, const u32 *pdo,
+				  unsigned int nr_pdo,
+				  unsigned int operating_snk_mw);
+
 void tcpm_vbus_change(struct tcpm_port *port);
 void tcpm_cc_change(struct tcpm_port *port);
 void tcpm_sink_frs(struct tcpm_port *port);
@@ -126,5 +178,7 @@ void tcpm_pd_transmit_complete(struct tcpm_port *port,
 			       enum tcpm_transmit_status status);
 void tcpm_pd_hard_reset(struct tcpm_port *port);
 void tcpm_tcpc_reset(struct tcpm_port *port);
+bool tcpm_is_debouncing(struct tcpm_port *tcpm);
+bool tcpm_is_toggling(struct tcpm_port *port);
 
 #endif /* __LINUX_USB_TCPM_H */
diff --git a/include/linux/usb/typec.h b/include/linux/usb/typec.h
index 6be558045..91b4303ca 100644
--- a/include/linux/usb/typec.h
+++ b/include/linux/usb/typec.h
@@ -126,9 +126,12 @@ struct typec_altmode_desc {
 	enum typec_port_data	roles;
 };
 
+void typec_partner_set_pd_revision(struct typec_partner *partner, u16 pd_revision);
+int typec_partner_set_num_altmodes(struct typec_partner *partner, int num_altmodes);
 struct typec_altmode
 *typec_partner_register_altmode(struct typec_partner *partner,
 				const struct typec_altmode_desc *desc);
+int typec_plug_set_num_altmodes(struct typec_plug *plug, int num_altmodes);
 struct typec_altmode
 *typec_plug_register_altmode(struct typec_plug *plug,
 			     const struct typec_altmode_desc *desc);
@@ -162,6 +165,7 @@ struct typec_plug_desc {
  * @type: The plug type from USB PD Cable VDO
  * @active: Is the cable active or passive
  * @identity: Result of Discover Identity command
+ * @pd_revision: USB Power Delivery Specification revision if supported
  *
  * Represents USB Type-C Cable attached to USB Type-C port.
  */
@@ -169,6 +173,8 @@ struct typec_cable_desc {
 	enum typec_plug_type	type;
 	unsigned int		active:1;
 	struct usb_pd_identity	*identity;
+	u16			pd_revision; /* 0300H = "3.0" */
+
 };
 
 /*
@@ -176,15 +182,22 @@ struct typec_cable_desc {
  * @usb_pd: USB Power Delivery support
  * @accessory: Audio, Debug or none.
  * @identity: Discover Identity command data
+ * @pd_revision: USB Power Delivery Specification Revision if supported
  *
  * Details about a partner that is attached to USB Type-C port. If @identity
  * member exists when partner is registered, a directory named "identity" is
  * created to sysfs for the partner device.
+ *
+ * @pd_revision is based on the setting of the "Specification Revision" field
+ * in the message header on the initial "Source Capabilities" message received
+ * from the partner, or a "Request" message received from the partner, depending
+ * on whether our port is a Sink or a Source.
  */
 struct typec_partner_desc {
 	unsigned int		usb_pd:1;
 	enum typec_accessory	accessory;
 	struct usb_pd_identity	*identity;
+	u16			pd_revision; /* 0300H = "3.0" */
 };
 
 /**
@@ -204,12 +217,19 @@ struct typec_operations {
 			     enum typec_port_type type);
 };
 
+enum usb_pd_svdm_ver {
+	SVDM_VER_1_0 = 0,
+	SVDM_VER_2_0 = 1,
+	SVDM_VER_MAX = SVDM_VER_2_0,
+};
+
 /*
  * struct typec_capability - USB Type-C Port Capabilities
  * @type: Supported power role of the port
  * @data: Supported data role of the port
  * @revision: USB Type-C Specification release. Binary coded decimal
  * @pd_revision: USB Power Delivery Specification revision if supported
+ * @svdm_version: USB PD Structured VDM version if supported
  * @prefer_role: Initial role preference (DRP ports).
  * @accessory: Supported Accessory Modes
  * @fwnode: Optional fwnode of the port
@@ -223,6 +243,7 @@ struct typec_capability {
 	enum typec_port_data	data;
 	u16			revision; /* 0120H = "1.2" */
 	u16			pd_revision; /* 0300H = "3.0" */
+	enum usb_pd_svdm_ver	svdm_version;
 	int			prefer_role;
 	enum typec_accessory	accessory[TYPEC_MAX_ACCESSORY];
 	unsigned int		orientation_aware:1;
@@ -273,4 +294,8 @@ int typec_find_orientation(const char *name);
 int typec_find_port_power_role(const char *name);
 int typec_find_power_role(const char *name);
 int typec_find_port_data_role(const char *name);
+
+void typec_partner_set_svdm_version(struct typec_partner *partner,
+				    enum usb_pd_svdm_ver svdm_version);
+int typec_get_negotiated_svdm_version(struct typec_port *port);
 #endif /* __LINUX_USB_TYPEC_H */
diff --git a/include/linux/usb/typec_altmode.h b/include/linux/usb/typec_altmode.h
index 5e0a7b764..65933cbe9 100644
--- a/include/linux/usb/typec_altmode.h
+++ b/include/linux/usb/typec_altmode.h
@@ -132,6 +132,16 @@ typec_altmode_get_orientation(struct typec_altmode *altmode)
 	return typec_get_orientation(typec_altmode2port(altmode));
 }
 
+/**
+ * typec_altmode_get_svdm_version - Get negotiated SVDM version
+ * @altmode: Handle to the alternate mode
+ */
+static inline int
+typec_altmode_get_svdm_version(struct typec_altmode *altmode)
+{
+	return typec_get_negotiated_svdm_version(typec_altmode2port(altmode));
+}
+
 /**
  * struct typec_altmode_driver - USB Type-C alternate mode device driver
  * @id_table: Null terminated array of SVIDs
diff --git a/include/linux/usb/typec_tbt.h b/include/linux/usb/typec_tbt.h
index 47c2d501d..63dd44b72 100644
--- a/include/linux/usb/typec_tbt.h
+++ b/include/linux/usb/typec_tbt.h
@@ -39,12 +39,16 @@ struct typec_thunderbolt_data {
 #define   TBT_CABLE_USB3_GEN1		1
 #define   TBT_CABLE_USB3_PASSIVE	2
 #define   TBT_CABLE_10_AND_20GBPS	3
-#define TBT_CABLE_ROUNDED		BIT(19)
+#define TBT_CABLE_ROUNDED_SUPPORT(_vdo_) \
+					(((_vdo_) & GENMASK(20, 19)) >> 19)
+#define   TBT_GEN3_NON_ROUNDED                 0
+#define   TBT_GEN3_GEN4_ROUNDED_NON_ROUNDED    1
 #define TBT_CABLE_OPTICAL		BIT(21)
 #define TBT_CABLE_RETIMER		BIT(22)
 #define TBT_CABLE_LINK_TRAINING		BIT(23)
 
 #define TBT_SET_CABLE_SPEED(_s_)	(((_s_) & GENMASK(2, 0)) << 16)
+#define TBT_SET_CABLE_ROUNDED(_g_)	(((_g_) & GENMASK(1, 0)) << 19)
 
 /* TBT3 Device Enter Mode VDO bits */
 #define TBT_ENTER_MODE_CABLE_SPEED(s)	TBT_SET_CABLE_SPEED(s)
diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 8110c29fa..2e4f7721f 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -83,8 +83,6 @@ struct usbnet {
 #		define EVENT_LINK_CHANGE	11
 #		define EVENT_SET_RX_MODE	12
 #		define EVENT_NO_IP_ALIGN	13
-	u32			rx_speed;	/* in bps - NOT Mbps */
-	u32			tx_speed;	/* in bps - NOT Mbps */
 };
 
 static inline struct usb_driver *driver_of(struct usb_interface *intf)
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
new file mode 100644
index 000000000..7b4825ba9
--- /dev/null
+++ b/include/linux/wakelock.h
@@ -0,0 +1,76 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/ktime.h>
+#include <linux/device.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+	struct wakeup_source ws;
+};
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+				  const char *name)
+{
+	struct wakeup_source *ws = &lock->ws;
+
+	if (ws) {
+		memset(ws, 0, sizeof(*ws));
+		ws->name = name;
+	}
+	wakeup_source_add(ws);
+}
+
+static inline void wake_lock_destroy(struct wake_lock *lock)
+{
+	struct wakeup_source *ws = &lock->ws;
+
+	wakeup_source_remove(ws);
+	__pm_relax(ws);
+}
+
+static inline void wake_lock(struct wake_lock *lock)
+{
+	__pm_stay_awake(&lock->ws);
+}
+
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
+}
+
+static inline void wake_unlock(struct wake_lock *lock)
+{
+	__pm_relax(&lock->ws);
+}
+
+static inline int wake_lock_active(struct wake_lock *lock)
+{
+	return lock->ws.active;
+}
+
+#endif
diff --git a/include/linux/wakeup_reason.h b/include/linux/wakeup_reason.h
new file mode 100644
index 000000000..54f5caaa5
--- /dev/null
+++ b/include/linux/wakeup_reason.h
@@ -0,0 +1,37 @@
+/*
+ * include/linux/wakeup_reason.h
+ *
+ * Logs the reason which caused the kernel to resume
+ * from the suspend mode.
+ *
+ * Copyright (C) 2014 Google, Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_WAKEUP_REASON_H
+#define _LINUX_WAKEUP_REASON_H
+
+#define MAX_SUSPEND_ABORT_LEN 256
+
+#ifdef CONFIG_SUSPEND
+void log_irq_wakeup_reason(int irq);
+void log_threaded_irq_wakeup_reason(int irq, int parent_irq);
+void log_suspend_abort_reason(const char *fmt, ...);
+void log_abnormal_wakeup_reason(const char *fmt, ...);
+void clear_wakeup_reasons(void);
+#else
+static inline void log_irq_wakeup_reason(int irq) { }
+static inline void log_threaded_irq_wakeup_reason(int irq, int parent_irq) { }
+static inline void log_suspend_abort_reason(const char *fmt, ...) { }
+static inline void log_abnormal_wakeup_reason(const char *fmt, ...) { }
+static inline void clear_wakeup_reasons(void) { }
+#endif
+
+#endif /* _LINUX_WAKEUP_REASON_H */
diff --git a/include/media/tc35874x.h b/include/media/tc35874x.h
new file mode 100644
index 000000000..b86143a0e
--- /dev/null
+++ b/include/media/tc35874x.h
@@ -0,0 +1,132 @@
+/*
+ * tc35874x - Toshiba HDMI to CSI-2 bridge
+ *
+ * Copyright 2015 Cisco Systems, Inc. and/or its affiliates. All rights
+ * reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ * REF_02 - Toshiba, TC358743XBG_HDMI-CSI_Tv11p_nm.xls
+ * REF_03 - Toshiba, TC358749XBG (H2C+), Functional Specification, Rev 0.74
+ */
+
+#ifndef _TC35874X_
+#define _TC35874X_
+
+enum tc35874x_ddc5v_delays {
+	DDC5V_DELAY_0_MS,
+	DDC5V_DELAY_50_MS,
+	DDC5V_DELAY_100_MS,
+	DDC5V_DELAY_200_MS,
+};
+
+enum tc35874x_hdmi_detection_delay {
+	HDMI_MODE_DELAY_0_MS,
+	HDMI_MODE_DELAY_25_MS,
+	HDMI_MODE_DELAY_50_MS,
+	HDMI_MODE_DELAY_100_MS,
+};
+
+struct tc35874x_platform_data {
+	/* System clock connected to REFCLK (pin H5) */
+	u32 refclk_hz; /* 26 MHz, 27 MHz or 42 MHz */
+
+	/* DDC +5V debounce delay to avoid spurious interrupts when the cable
+	 * is connected.
+	 * Sets DDC5V_MODE in register DDC_CTL.
+	 * Default: DDC5V_DELAY_0_MS
+	 */
+	enum tc35874x_ddc5v_delays ddc5v_delay;
+
+	bool enable_hdcp;
+
+	/*
+	 * The FIFO size is 512x32, so Toshiba recommend to set the default FIFO
+	 * level to somewhere in the middle (e.g. 300), so it can cover speed
+	 * mismatches in input and output ports.
+	 */
+	u16 fifo_level;
+
+	/* Bps pr lane is (refclk_hz / pll_prd) * pll_fbd */
+	u16 pll_prd;
+	u16 pll_fbd;
+
+	/* CSI
+	 * Calculate CSI parameters with REF_02 for the highest resolution your
+	 * CSI interface can handle. The driver will adjust the number of CSI
+	 * lanes in use according to the pixel clock.
+	 *
+	 * The values in brackets are calculated with REF_02 when the number of
+	 * bps pr lane is 823.5 MHz, and can serve as a starting point.
+	 */
+	u32 lineinitcnt;	/* (0x00001770) */
+	u32 lptxtimecnt;	/* (0x00000005) */
+	u32 tclk_headercnt;	/* (0x00001d04) */
+	u32 tclk_trailcnt;	/* (0x00000000) */
+	u32 ths_headercnt;	/* (0x00000505) */
+	u32 twakeup;		/* (0x00004650) */
+	u32 tclk_postcnt;	/* (0x00000000) */
+	u32 ths_trailcnt;	/* (0x00000004) */
+	u32 hstxvregcnt;	/* (0x00000005) */
+
+	/* DVI->HDMI detection delay to avoid unnecessary switching between DVI
+	 * and HDMI mode.
+	 * Sets HDMI_DET_V in register HDMI_DET.
+	 * Default: HDMI_MODE_DELAY_0_MS
+	 */
+	enum tc35874x_hdmi_detection_delay hdmi_detection_delay;
+
+	/* Reset PHY automatically when TMDS clock goes from DC to AC.
+	 * Sets PHY_AUTO_RST2 in register PHY_CTL2.
+	 * Default: false
+	 */
+	bool hdmi_phy_auto_reset_tmds_detected;
+
+	/* Reset PHY automatically when TMDS clock passes 21 MHz.
+	 * Sets PHY_AUTO_RST3 in register PHY_CTL2.
+	 * Default: false
+	 */
+	bool hdmi_phy_auto_reset_tmds_in_range;
+
+	/* Reset PHY automatically when TMDS clock is detected.
+	 * Sets PHY_AUTO_RST4 in register PHY_CTL2.
+	 * Default: false
+	 */
+	bool hdmi_phy_auto_reset_tmds_valid;
+
+	/* Reset HDMI PHY automatically when hsync period is out of range.
+	 * Sets H_PI_RST in register HV_RST.
+	 * Default: false
+	 */
+	bool hdmi_phy_auto_reset_hsync_out_of_range;
+
+	/* Reset HDMI PHY automatically when vsync period is out of range.
+	 * Sets V_PI_RST in register HV_RST.
+	 * Default: false
+	 */
+	bool hdmi_phy_auto_reset_vsync_out_of_range;
+};
+
+/* custom controls */
+/* Audio sample rate in Hz */
+#define TC35874X_CID_AUDIO_SAMPLING_RATE (V4L2_CID_USER_TC35874X_BASE + 0)
+/* Audio present status */
+#define TC35874X_CID_AUDIO_PRESENT       (V4L2_CID_USER_TC35874X_BASE + 1)
+
+#endif
\ No newline at end of file
diff --git a/include/media/v4l2-async.h b/include/media/v4l2-async.h
index 92cd9f038..03b43b0f7 100644
--- a/include/media/v4l2-async.h
+++ b/include/media/v4l2-async.h
@@ -266,6 +266,21 @@ int v4l2_async_notifier_register(struct v4l2_device *v4l2_dev,
 int v4l2_async_subdev_notifier_register(struct v4l2_subdev *sd,
 					struct v4l2_async_notifier *notifier);
 
+/**
+ * v4l2_async_notifier_clr_unready_dev - remove unready subdevice
+ *
+ * @notifier: pointer to &struct v4l2_async_notifier
+ */
+#if IS_ENABLED(CONFIG_NO_GKI)
+int v4l2_async_notifier_clr_unready_dev(struct v4l2_async_notifier *notifier);
+#else
+static inline int
+v4l2_async_notifier_clr_unready_dev(struct v4l2_async_notifier *notifier)
+{
+	return 0;
+}
+#endif
+
 /**
  * v4l2_async_notifier_unregister - unregisters a subdevice
  *	asynchronous notifier
diff --git a/include/soc/rockchip/pm_domains.h b/include/soc/rockchip/pm_domains.h
new file mode 100644
index 000000000..fa276ce9b
--- /dev/null
+++ b/include/soc/rockchip/pm_domains.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __SOC_ROCKCHIP_PM_DOMAINS_H
+#define __SOC_ROCKCHIP_PM_DOMAINS_H
+
+#include <linux/errno.h>
+
+struct device;
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_PM_DOMAINS)
+int rockchip_pmu_pd_on(struct device *dev);
+int rockchip_pmu_pd_off(struct device *dev);
+bool rockchip_pmu_pd_is_on(struct device *dev);
+int rockchip_pmu_idle_request(struct device *dev, bool idle);
+int rockchip_save_qos(struct device *dev);
+int rockchip_restore_qos(struct device *dev);
+void rockchip_dump_pmu(void);
+#else
+static inline int rockchip_pmu_pd_on(struct device *dev)
+{
+	return -ENOTSUPP;
+}
+
+static inline int rockchip_pmu_pd_off(struct device *dev)
+{
+	return -ENOTSUPP;
+}
+
+static inline bool rockchip_pmu_pd_is_on(struct device *dev)
+{
+	return true;
+}
+
+static inline int rockchip_pmu_idle_request(struct device *dev, bool idle)
+{
+	return -ENOTSUPP;
+}
+
+static inline int rockchip_save_qos(struct device *dev)
+{
+	return -ENOTSUPP;
+}
+
+static inline int rockchip_restore_qos(struct device *dev)
+{
+	return -ENOTSUPP;
+}
+
+static inline void rockchip_dump_pmu(void)
+{
+}
+#endif
+
+#endif
diff --git a/include/soc/rockchip/rkfb_dmc.h b/include/soc/rockchip/rkfb_dmc.h
new file mode 100644
index 000000000..5e82b3194
--- /dev/null
+++ b/include/soc/rockchip/rkfb_dmc.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip devfb driver will probe earlier than devfreq, so it needs to register
+ * dmc_notify after than rk3399 dmc driver.
+*/
+
+#if defined(CONFIG_LCDC_RK322X)
+int vop_register_dmc(void);
+#else
+static inline int vop_register_dmc(void) { return 0;};
+#endif
diff --git a/include/soc/rockchip/rockchip-system-status.h b/include/soc/rockchip/rockchip-system-status.h
new file mode 100644
index 000000000..200b1ee89
--- /dev/null
+++ b/include/soc/rockchip/rockchip-system-status.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) 2019, Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __SOC_ROCKCHIP_SYSTEM_STATUS_H
+#define __SOC_ROCKCHIP_SYSTEM_STATUS_H
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_SYSTEM_MONITOR)
+int rockchip_register_system_status_notifier(struct notifier_block *nb);
+int rockchip_unregister_system_status_notifier(struct notifier_block *nb);
+void rockchip_set_system_status(unsigned long status);
+void rockchip_clear_system_status(unsigned long status);
+unsigned long rockchip_get_system_status(void);
+int rockchip_add_system_status_interface(struct device *dev);
+void rockchip_update_system_status(const char *buf);
+#else
+static inline int
+rockchip_register_system_status_notifier(struct notifier_block *nb)
+{
+	return -ENOTSUPP;
+};
+
+static inline int
+rockchip_unregister_system_status_notifier(struct notifier_block *nb)
+{
+	return -ENOTSUPP;
+};
+
+static inline void rockchip_set_system_status(unsigned long status)
+{
+};
+
+static inline void rockchip_clear_system_status(unsigned long status)
+{
+};
+
+static inline unsigned long rockchip_get_system_status(void)
+{
+	return 0;
+};
+
+static inline int rockchip_add_system_status_interface(struct device *dev)
+{
+	return -ENOTSUPP;
+};
+
+static inline void rockchip_update_system_status(const char *buf)
+{
+};
+#endif /* CONFIG_ROCKCHIP_SYSTEM_MONITOR */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_dmc.h b/include/soc/rockchip/rockchip_dmc.h
new file mode 100644
index 000000000..ec90962f2
--- /dev/null
+++ b/include/soc/rockchip/rockchip_dmc.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#ifndef __SOC_ROCKCHIP_DMC_H
+#define __SOC_ROCKCHIP_DMC_H
+
+#include <linux/devfreq.h>
+
+/* for lcdc_type */
+#define SCREEN_NULL		0
+#define SCREEN_RGB		1
+#define SCREEN_LVDS		2
+#define SCREEN_DUAL_LVDS	3
+#define SCREEN_MCU		4
+#define SCREEN_TVOUT		5
+#define SCREEN_HDMI		6
+#define SCREEN_MIPI		7
+#define SCREEN_DUAL_MIPI	8
+#define SCREEN_EDP		9
+#define SCREEN_TVOUT_TEST	10
+#define SCREEN_LVDS_10BIT	11
+#define SCREEN_DUAL_LVDS_10BIT	12
+#define SCREEN_DP		13
+
+#define DMCFREQ_TABLE_END	~1u
+
+struct freq_map_table {
+	unsigned int min;
+	unsigned int max;
+	unsigned long freq;
+};
+
+struct rl_map_table {
+	unsigned int pn; /* panel number */
+	unsigned int rl; /* readlatency */
+};
+
+struct dmcfreq_common_info {
+	struct device *dev;
+	struct devfreq *devfreq;
+	struct freq_map_table *vop_bw_tbl;
+	struct freq_map_table *vop_frame_bw_tbl;
+	struct rl_map_table *vop_pn_rl_tbl;
+	struct delayed_work msch_rl_work;
+	unsigned long vop_req_rate;
+	unsigned int read_latency;
+	unsigned int auto_freq_en;
+	bool is_msch_rl_work_started;
+	int (*set_msch_readlatency)(unsigned int rl);
+};
+
+struct dmcfreq_vop_info {
+	unsigned int line_bw_mbyte;
+	unsigned int frame_bw_mbyte;
+	unsigned int plane_num;
+};
+
+#if IS_ENABLED(CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ)
+void rockchip_dmcfreq_lock(void);
+void rockchip_dmcfreq_lock_nested(void);
+void rockchip_dmcfreq_unlock(void);
+int rockchip_dmcfreq_write_trylock(void);
+void rockchip_dmcfreq_write_unlock(void);
+int rockchip_dmcfreq_wait_complete(void);
+int rockchip_dmcfreq_vop_bandwidth_init(struct dmcfreq_common_info *info);
+int rockchip_dmcfreq_vop_bandwidth_request(struct dmcfreq_vop_info *vop_info);
+void rockchip_dmcfreq_vop_bandwidth_update(struct dmcfreq_vop_info *vop_info);
+#else
+static inline void rockchip_dmcfreq_lock(void)
+{
+}
+
+static inline void rockchip_dmcfreq_lock_nested(void)
+{
+}
+
+static inline void rockchip_dmcfreq_unlock(void)
+{
+}
+
+static inline int rockchip_dmcfreq_write_trylock(void)
+{
+	return 0;
+}
+
+static inline void rockchip_dmcfreq_write_unlock(void)
+{
+}
+
+static inline int rockchip_dmcfreq_wait_complete(void)
+{
+	return 0;
+}
+
+static inline int
+rockchip_dmcfreq_vop_bandwidth_request(struct dmcfreq_vop_info *vop_info)
+{
+	return 0;
+}
+
+static inline void
+rockchip_dmcfreq_vop_bandwidth_update(struct dmcfreq_vop_info *vop_info)
+{
+}
+
+static inline void
+rockchip_dmcfreq_vop_bandwidth_init(struct dmcfreq_common_info *info)
+{
+}
+#endif
+
+#endif
diff --git a/include/soc/rockchip/rockchip_iommu.h b/include/soc/rockchip/rockchip_iommu.h
new file mode 100644
index 000000000..e837d9fec
--- /dev/null
+++ b/include/soc/rockchip/rockchip_iommu.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd
+ */
+#ifndef __SOC_ROCKCHIP_IOMMU_H
+#define __SOC_ROCKCHIP_IOMMU_H
+
+struct device;
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_IOMMU)
+int rockchip_iommu_enable(struct device *dev);
+int rockchip_iommu_disable(struct device *dev);
+#else
+static inline int rockchip_iommu_enable(struct device *dev)
+{
+	return -ENODEV;
+}
+static inline int rockchip_iommu_disable(struct device *dev)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif
diff --git a/include/soc/rockchip/rockchip_ipa.h b/include/soc/rockchip/rockchip_ipa.h
new file mode 100644
index 000000000..cb333f463
--- /dev/null
+++ b/include/soc/rockchip/rockchip_ipa.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef __SOC_ROCKCHIP_IPA_H
+#define __SOC_ROCKCHIP_IPA_H
+
+struct ipa_power_model_data {
+	u32 static_coefficient;
+	u32 dynamic_coefficient;
+	s32 ts[4];			/* temperature scaling factor */
+	struct thermal_zone_device *tz;
+	u32 leakage;
+	u32 ref_leakage;
+	u32 lkg_range[2];		/* min leakage and max leakage */
+	s32 ls[3];			/* leakage scaling factor */
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_IPA)
+struct ipa_power_model_data *rockchip_ipa_power_model_init(struct device *dev,
+							   char *lkg_name);
+unsigned long
+rockchip_ipa_get_static_power(struct ipa_power_model_data *model_data,
+			      unsigned long voltage_mv);
+#else
+static inline struct ipa_power_model_data *
+rockchip_ipa_power_model_init(struct device *dev, char *lkg_name)
+{
+	return ERR_PTR(-ENOTSUPP);
+};
+
+static inline unsigned long
+rockchip_ipa_get_static_power(struct ipa_power_model_data *data,
+			      unsigned long voltage_mv)
+{
+	return 0;
+}
+#endif /* CONFIG_ROCKCHIP_IPA */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_opp_select.h b/include/soc/rockchip/rockchip_opp_select.h
new file mode 100644
index 000000000..69f4b9707
--- /dev/null
+++ b/include/soc/rockchip/rockchip_opp_select.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef __SOC_ROCKCHIP_OPP_SELECT_H
+#define __SOC_ROCKCHIP_OPP_SELECT_H
+
+#define VOLT_RM_TABLE_END	~1
+
+struct rockchip_opp_info;
+
+struct volt_rm_table {
+	int volt;
+	int rm;
+};
+
+struct rockchip_opp_data {
+	int (*get_soc_info)(struct device *dev, struct device_node *np,
+			    int *bin, int *process);
+	int (*set_read_margin)(struct device *dev,
+			       struct rockchip_opp_info *opp_info,
+			       unsigned long volt);
+};
+
+struct rockchip_opp_info {
+	const struct rockchip_opp_data *data;
+	struct volt_rm_table *volt_rm_tbl;
+	struct regmap *grf;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	unsigned long volt_rm;
+	u32 current_rm;
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_OPP)
+int rockchip_of_get_leakage(struct device *dev, char *lkg_name, int *leakage);
+void rockchip_of_get_lkg_sel(struct device *dev, struct device_node *np,
+			     char *lkg_name, int process,
+			     int *volt_sel, int *scale_sel);
+void rockchip_of_get_pvtm_sel(struct device *dev, struct device_node *np,
+			      char *reg_name, int process,
+			      int *volt_sel, int *scale_sel);
+void rockchip_of_get_bin_sel(struct device *dev, struct device_node *np,
+			     int bin, int *scale_sel);
+void rockchip_of_get_bin_volt_sel(struct device *dev, struct device_node *np,
+				  int bin, int *bin_volt_sel);
+int rockchip_nvmem_cell_read_u8(struct device_node *np, const char *cell_id,
+				u8 *val);
+int rockchip_nvmem_cell_read_u16(struct device_node *np, const char *cell_id,
+				 u16 *val);
+int rockchip_get_volt_rm_table(struct device *dev, struct device_node *np,
+			       char *porp_name, struct volt_rm_table **table);
+void rockchip_get_opp_data(const struct of_device_id *matches,
+			   struct rockchip_opp_info *info);
+void rockchip_get_scale_volt_sel(struct device *dev, char *lkg_name,
+				 char *reg_name, int bin, int process,
+				 int *scale, int *volt_sel);
+struct opp_table *rockchip_set_opp_prop_name(struct device *dev, int process,
+					     int volt_sel);
+int rockchip_adjust_power_scale(struct device *dev, int scale);
+int rockchip_init_opp_table(struct device *dev,
+			    struct rockchip_opp_info *info,
+			    char *lkg_name, char *reg_name);
+#else
+static inline int rockchip_of_get_leakage(struct device *dev, char *lkg_name,
+					  int *leakage)
+{
+	return -ENOTSUPP;
+}
+
+static inline void rockchip_of_get_lkg_sel(struct device *dev,
+					   struct device_node *np,
+					   char *lkg_name, int process,
+					   int *volt_sel, int *scale_sel)
+{
+}
+
+static inline void rockchip_of_get_pvtm_sel(struct device *dev,
+					    struct device_node *np,
+					    char *reg_name, int process,
+					    int *volt_sel, int *scale_sel)
+{
+}
+
+static inline void rockchip_of_get_bin_sel(struct device *dev,
+					   struct device_node *np, int bin,
+					   int *scale_sel)
+{
+}
+
+static inline void rockchip_of_get_bin_volt_sel(struct device *dev,
+						struct device_node *np,
+						int bin, int *bin_volt_sel)
+{
+}
+
+static inline int rockchip_nvmem_cell_read_u8(struct device_node *np,
+					      const char *cell_id, u8 *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_nvmem_cell_read_u16(struct device_node *np,
+					       const char *cell_id, u16 *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int rockchip_get_volt_rm_table(struct device *dev,
+					     struct device_node *np,
+					     char *porp_name,
+					     struct volt_rm_table **table)
+{
+	return -EOPNOTSUPP;
+
+}
+
+static inline void rockchip_get_opp_data(const struct of_device_id *matches,
+					 struct rockchip_opp_info *info)
+{
+}
+
+static inline void rockchip_get_scale_volt_sel(struct device *dev,
+					       char *lkg_name, char *reg_name,
+					       int bin, int process, int *scale,
+					       int *volt_sel)
+{
+}
+
+static inline struct opp_table *rockchip_set_opp_prop_name(struct device *dev,
+							   int process,
+							   int volt_sel)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline int rockchip_adjust_power_scale(struct device *dev, int scale)
+{
+	return -ENOTSUPP;
+}
+
+static inline int rockchip_init_opp_table(struct device *dev,
+					  struct rockchip_opp_info *info,
+					  char *lkg_name, char *reg_name)
+{
+	return -ENOTSUPP;
+}
+
+#endif /* CONFIG_ROCKCHIP_OPP */
+
+#endif
diff --git a/include/soc/rockchip/rockchip_performance.h b/include/soc/rockchip/rockchip_performance.h
new file mode 100644
index 000000000..629a4c01a
--- /dev/null
+++ b/include/soc/rockchip/rockchip_performance.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd
+ */
+#ifndef __SOC_ROCKCHIP_PERFORMANCE_H
+#define __SOC_ROCKCHIP_PERFORMANCE_H
+
+#ifdef CONFIG_ROCKCHIP_PERFORMANCE
+extern int rockchip_perf_get_level(void);
+extern int rockchip_perf_select_rt_cpu(int prev_cpu, struct cpumask *lowest_mask);
+extern bool rockchip_perf_misfit_rt(int cpu);
+extern void rockchip_perf_uclamp_sync_util_min_rt_default(void);
+#else
+static inline int rockchip_perf_get_level(void) { return 1; }
+static inline int rockchip_perf_select_rt_cpu(int prev_cpu, struct cpumask *lowest_mask)
+{
+	return prev_cpu;
+}
+static inline bool rockchip_perf_misfit_rt(int cpu) { return false; }
+static inline void rockchip_perf_uclamp_sync_util_min_rt_default(void) {}
+#endif
+
+#endif
diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
index c46a9ae2a..4afba01c6 100644
--- a/include/soc/rockchip/rockchip_sip.h
+++ b/include/soc/rockchip/rockchip_sip.h
@@ -15,6 +15,12 @@
 #define ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE	0x05
 #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
 #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
-#define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
+#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
+#define ROCKCHIP_SIP_CONFIG_DRAM_POST_SET_RATE	0x09
+#define ROCKCHIP_SIP_CONFIG_DRAM_SET_MSCH_RL	0x0a
+#define ROCKCHIP_SIP_CONFIG_DRAM_DEBUG		0x0b
+#define ROCKCHIP_SIP_CONFIG_MCU_START		0x0c
+#define ROCKCHIP_SIP_CONFIG_DRAM_GET_FREQ_INFO	0x0e
+#define ROCKCHIP_SIP_CONFIG_DRAM_ADDRMAP_GET	0x10
 
 #endif
diff --git a/include/soc/rockchip/rockchip_system_monitor.h b/include/soc/rockchip/rockchip_system_monitor.h
new file mode 100644
index 000000000..be64377d3
--- /dev/null
+++ b/include/soc/rockchip/rockchip_system_monitor.h
@@ -0,0 +1,205 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) 2019, Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __SOC_ROCKCHIP_SYSTEM_MONITOR_H
+#define __SOC_ROCKCHIP_SYSTEM_MONITOR_H
+
+enum monitor_dev_type {
+	MONITOR_TPYE_CPU = 0,	/* CPU */
+	MONITOR_TPYE_DEV,	/* GPU, NPU, DMC, and so on */
+};
+
+struct volt_adjust_table {
+	unsigned int min;	/* Minimum frequency in MHz */
+	unsigned int max;	/* Maximum frequency in MHz */
+	int volt;		/* Voltage in microvolt */
+};
+
+struct temp_freq_table {
+	int temp;		/* millicelsius */
+	unsigned int freq;	/* KHz */
+};
+
+/**
+ * struct temp_opp_table - System monitor device OPP description structure
+ * @rate:		Frequency in hertz
+ * @volt:		Target voltage in microvolt
+ * @low_temp_volt:	Target voltage when low temperature, in microvolt
+ * @max_volt:		Maximum voltage in microvolt
+ */
+struct temp_opp_table {
+	unsigned long rate;
+	unsigned long volt;
+	unsigned long low_temp_volt;
+	unsigned long max_volt;
+};
+
+/**
+ * struct monitor_dev_info - structure for a system monitor device
+ * @dev:		Device registered by system monitor
+ * @low_temp_adjust_table:	Voltage margin for different OPPs when lowe
+ *				temperature
+ * @opp_table:		Frequency and voltage information of device
+ * @devp:		Device-specific system monitor profile
+ * @node:		Node in monitor_dev_list
+ * @high_limit_table:	Limit maximum frequency at different temperature,
+ *			but the frequency is also changed by thermal framework.
+ * @volt_adjust_mutex:	A mutex to protect changing voltage.
+ * @max_temp_freq_req:	CPU maximum frequency constraint changed according
+ *			to temperature.
+ * @min_sta_freq_req:   CPU minimum frequency constraint changed according
+ *			to system status.
+ * @max_sta_freq_req:   CPU maximum frequency constraint changed according
+ *			to system status.
+ * @dev_max_freq_req:	Devices maximum frequency constraint changed according
+ *			to temperature.
+ * @low_limit:		Limit maximum frequency when low temperature, in Hz
+ * @high_limit:		Limit maximum frequency when high temperature, in Hz
+ * @max_volt:		Maximum voltage in microvolt
+ * @low_temp_min_volt:	Minimum voltage of OPPs when low temperature, in
+ *			microvolt
+ * @high_temp_max_volt:	Maximum voltage when high temperature, in microvolt
+ * @wide_temp_limit:	Target maximum frequency when low or high temperature,
+ *			in Hz
+ * @video_4k_freq:	Maximum frequency when paly 4k video, in KHz
+ * @reboot_freq:	Limit maximum and minimum frequency when reboot, in KHz
+ * @status_min_limit:	Minimum frequency of some status frequency, in KHz
+ * @status_max_limit:	Minimum frequency of all status frequency, in KHz
+ * @low_temp:		Low temperature trip point, in millicelsius
+ * @high_temp:		High temperature trip point, in millicelsius
+ * @temp_hysteresis:	A low hysteresis value on low_temp, in millicelsius
+ * @is_low_temp:	True if current temperature less than low_temp
+ * @is_high_temp:	True if current temperature greater than high_temp
+ * @is_low_temp_enabled:	True if device node contains low temperature
+ *				configuration
+ * @is_status_freq_fixed:	True if enter into some status
+ */
+struct monitor_dev_info {
+	struct device *dev;
+	struct volt_adjust_table *low_temp_adjust_table;
+	struct temp_opp_table *opp_table;
+	struct monitor_dev_profile *devp;
+	struct list_head node;
+	struct temp_freq_table *high_limit_table;
+	struct mutex volt_adjust_mutex;
+	struct freq_qos_request max_temp_freq_req;
+	struct freq_qos_request min_sta_freq_req;
+	struct freq_qos_request max_sta_freq_req;
+	struct dev_pm_qos_request dev_max_freq_req;
+	struct regulator *early_reg;
+	struct regulator **regulators;
+	struct clk *clk;
+	unsigned long low_limit;
+	unsigned long high_limit;
+	unsigned long max_volt;
+	unsigned long low_temp_min_volt;
+	unsigned long high_temp_max_volt;
+	unsigned int video_4k_freq;
+	unsigned int reboot_freq;
+	unsigned int init_freq;
+	unsigned int status_min_limit;
+	unsigned int status_max_limit;
+	unsigned int early_min_volt;
+	unsigned int regulator_count;
+	int low_temp;
+	int high_temp;
+	int temp_hysteresis;
+	bool is_low_temp;
+	bool is_high_temp;
+	bool is_low_temp_enabled;
+};
+
+struct monitor_dev_profile {
+	enum monitor_dev_type type;
+	void *data;
+	bool is_checked;
+	int (*low_temp_adjust)(struct monitor_dev_info *info, bool is_low);
+	int (*high_temp_adjust)(struct monitor_dev_info *info, bool is_low);
+	int (*update_volt)(struct monitor_dev_info *info, bool is_set_clk);
+	struct cpumask allowed_cpus;
+	struct rockchip_opp_info *opp_info;
+};
+
+#if IS_ENABLED(CONFIG_ROCKCHIP_SYSTEM_MONITOR)
+struct monitor_dev_info *
+rockchip_system_monitor_register(struct device *dev,
+				 struct monitor_dev_profile *devp);
+void rockchip_system_monitor_unregister(struct monitor_dev_info *info);
+int rockchip_monitor_cpu_low_temp_adjust(struct monitor_dev_info *info,
+					 bool is_low);
+int rockchip_monitor_cpu_high_temp_adjust(struct monitor_dev_info *info,
+					  bool is_high);
+void rockchip_monitor_volt_adjust_lock(struct monitor_dev_info *info);
+void rockchip_monitor_volt_adjust_unlock(struct monitor_dev_info *info);
+int rockchip_monitor_check_rate_volt(struct monitor_dev_info *info,
+				     bool is_set_clk);
+int rockchip_monitor_dev_low_temp_adjust(struct monitor_dev_info *info,
+					 bool is_low);
+int rockchip_monitor_dev_high_temp_adjust(struct monitor_dev_info *info,
+					  bool is_high);
+int rockchip_monitor_suspend_low_temp_adjust(int cpu);
+#else
+static inline struct monitor_dev_info *
+rockchip_system_monitor_register(struct device *dev,
+				 struct monitor_dev_profile *devp)
+{
+	return ERR_PTR(-ENOTSUPP);
+};
+
+static inline void
+rockchip_system_monitor_unregister(struct monitor_dev_info *info)
+{
+}
+
+static inline int
+rockchip_monitor_cpu_low_temp_adjust(struct monitor_dev_info *info, bool is_low)
+{
+	return 0;
+};
+
+static inline int
+rockchip_monitor_cpu_high_temp_adjust(struct monitor_dev_info *info,
+				      bool is_high)
+{
+	return 0;
+};
+
+static inline void
+rockchip_monitor_volt_adjust_lock(struct monitor_dev_info *info)
+{
+}
+
+static inline void
+rockchip_monitor_volt_adjust_unlock(struct monitor_dev_info *info)
+{
+}
+
+static inline int
+rockchip_monitor_check_rate_volt(struct monitor_dev_info *info, bool is_set_clk)
+{
+	return 0;
+}
+
+static inline int
+rockchip_monitor_dev_low_temp_adjust(struct monitor_dev_info *info, bool is_low)
+{
+	return 0;
+};
+
+static inline int
+rockchip_monitor_dev_high_temp_adjust(struct monitor_dev_info *info,
+				      bool is_high)
+{
+	return 0;
+};
+
+static inline int rockchip_monitor_suspend_low_temp_adjust(int cpu)
+{
+	return 0;
+};
+
+#endif /* CONFIG_ROCKCHIP_SYSTEM_MONITOR */
+
+#endif
diff --git a/include/soc/rockchip/scpi.h b/include/soc/rockchip/scpi.h
new file mode 100644
index 000000000..ad1a4e51a
--- /dev/null
+++ b/include/soc/rockchip/scpi.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __SOC_ROCKCHIP_SCPI_H
+#define __SOC_ROCKCHIP_SCPI_H
+
+#ifdef CONFIG_RK3368_SCPI_PROTOCOL
+struct scpi_opp_entry {
+	u32 freq_hz;
+	u32 volt_mv;
+} __packed;
+
+struct scpi_opp {
+	struct scpi_opp_entry *opp;
+	u32 latency; /* in usecs */
+	int count;
+} __packed;
+
+unsigned long scpi_clk_get_val(u16 clk_id);
+int scpi_clk_set_val(u16 clk_id, unsigned long rate);
+int scpi_dvfs_get_idx(u8 domain);
+int scpi_dvfs_set_idx(u8 domain, u8 idx);
+struct scpi_opp *scpi_dvfs_get_opps(u8 domain);
+int scpi_get_sensor(char *name);
+int scpi_get_sensor_value(u16 sensor, u32 *val);
+int scpi_sys_set_jtagmux_on_off(u32 en);
+int scpi_sys_set_mcu_state_suspend(void);
+int scpi_sys_set_mcu_state_resume(void);
+
+int scpi_ddr_dclk_mode(u32 dclk_mode);
+int scpi_ddr_init(u32 dram_speed_bin, u32 freq, u32 lcdc_type,
+		  u32 addr_mcu_el3);
+int scpi_ddr_set_clk_rate(u32 rate, u32 lcdc_type);
+int scpi_ddr_send_timing(u32 *p, u32 size);
+int scpi_ddr_round_rate(u32 m_hz);
+int scpi_ddr_set_auto_self_refresh(u32 en);
+int scpi_ddr_get_clk_rate(void);
+int scpi_thermal_get_temperature(void);
+int scpi_thermal_set_clk_cycle(u32 cycle);
+#else
+static inline unsigned long scpi_clk_get_val(u16 clk_id)
+{
+	return -EPERM;
+}
+
+static inline int scpi_clk_set_val(u16 clk_id, unsigned long rate)
+{
+	return -EPERM;
+}
+
+static inline int scpi_dvfs_get_idx(u8 domain)
+{
+	return -EPERM;
+}
+
+static inline int scpi_dvfs_set_idx(u8 domain, u8 idx)
+{
+	return -EPERM;
+}
+
+static inline struct scpi_opp *scpi_dvfs_get_opps(u8 domain)
+{
+	return ERR_PTR(-EPERM);
+}
+
+static inline int scpi_get_sensor(char *name)
+{
+	return -EPERM;
+}
+
+static inline int scpi_get_sensor_value(u16 sensor, u32 *val)
+{
+	return -EPERM;
+}
+
+static inline int scpi_sys_set_jtagmux_on_off(u32 en)
+{
+	return -EPERM;
+}
+
+static inline int scpi_sys_set_mcu_state_suspend(void)
+{
+	return -EPERM;
+}
+
+static inline int scpi_sys_set_mcu_state_resume(void)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_dclk_mode(u32 dclk_mode)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_init(u32 dram_speed_bin, u32 freq, u32 lcdc_type,
+				u32 addr_mcu_el3)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_set_clk_rate(u32 rate, u32 lcdc_type)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_send_timing(u32 *p, u32 size)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_round_rate(u32 m_hz)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_set_auto_self_refresh(u32 en)
+{
+	return -EPERM;
+}
+
+static inline int scpi_ddr_get_clk_rate(void)
+{
+	return -EPERM;
+}
+
+static inline int scpi_thermal_get_temperature(void)
+{
+	return -EPERM;
+}
+
+static inline int scpi_thermal_set_clk_cycle(u32 cycle)
+{
+	return -EPERM;
+}
+#endif
+#endif
diff --git a/include/sound/hdmi-codec.h b/include/sound/hdmi-codec.h
index b55970859..4fc733c8c 100644
--- a/include/sound/hdmi-codec.h
+++ b/include/sound/hdmi-codec.h
@@ -34,6 +34,11 @@ struct hdmi_codec_daifmt {
 	unsigned int frame_clk_inv:1;
 	unsigned int bit_clk_master:1;
 	unsigned int frame_clk_master:1;
+	/* bit_fmt could be standard PCM format or
+	 * IEC958 encoded format. ALSA IEC958 plugin will pass
+	 * IEC958_SUBFRAME format to the underneath driver.
+	 */
+	snd_pcm_format_t bit_fmt;
 };
 
 /*
@@ -60,12 +65,22 @@ struct hdmi_codec_ops {
 
 	/*
 	 * Configures HDMI-encoder for audio stream.
-	 * Mandatory
+	 * Having either prepare or hw_params is mandatory.
 	 */
 	int (*hw_params)(struct device *dev, void *data,
 			 struct hdmi_codec_daifmt *fmt,
 			 struct hdmi_codec_params *hparms);
 
+	/*
+	 * Configures HDMI-encoder for audio stream. Can be called
+	 * multiple times for each setup.
+	 *
+	 * Having either prepare or hw_params is mandatory.
+	 */
+	int (*prepare)(struct device *dev, void *data,
+		       struct hdmi_codec_daifmt *fmt,
+		       struct hdmi_codec_params *hparms);
+
 	/*
 	 * Shuts down the audio stream.
 	 * Mandatory
diff --git a/include/trace/events/cpuhp.h b/include/trace/events/cpuhp.h
index ad16f7731..f302ab6db 100644
--- a/include/trace/events/cpuhp.h
+++ b/include/trace/events/cpuhp.h
@@ -89,6 +89,28 @@ TRACE_EVENT(cpuhp_exit,
 		  __entry->cpu, __entry->state, __entry->idx,  __entry->ret)
 );
 
+TRACE_EVENT(cpuhp_pause,
+	TP_PROTO(struct cpumask *cpus, u64 start_time, unsigned char pause),
+
+	TP_ARGS(cpus, start_time, pause),
+
+	TP_STRUCT__entry(
+		__field( unsigned int,	cpus		)
+		__field( unsigned int,	active_cpus	)
+		__field( unsigned int,	time		)
+		__field( unsigned char,	pause		)
+	),
+
+	TP_fast_assign(
+		__entry->cpus	     = cpumask_bits(cpus)[0];
+		__entry->active_cpus = cpumask_bits(cpu_active_mask)[0];
+		__entry->time        = div64_u64(sched_clock() - start_time, 1000);
+		__entry->pause	     = pause;
+	),
+
+	TP_printk("req_cpus=0x%x act_cpus=0x%x time=%u us paused=%d",
+		  __entry->cpus, __entry->active_cpus, __entry->time, __entry->pause)
+);
 #endif
 
 /* This part must be outside protection */
diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index dd5fff2bb..6c6a23b4b 100644
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -203,6 +203,7 @@ TRACE_EVENT(sched_migrate_task,
 		__field(	int,	prio			)
 		__field(	int,	orig_cpu		)
 		__field(	int,	dest_cpu		)
+		__field(	int,	running			)
 	),
 
 	TP_fast_assign(
@@ -211,11 +212,13 @@ TRACE_EVENT(sched_migrate_task,
 		__entry->prio		= p->prio; /* XXX SCHED_DEADLINE */
 		__entry->orig_cpu	= task_cpu(p);
 		__entry->dest_cpu	= dest_cpu;
+		__entry->running	= (p->state == TASK_RUNNING);
 	),
 
-	TP_printk("comm=%s pid=%d prio=%d orig_cpu=%d dest_cpu=%d",
+	TP_printk("comm=%s pid=%d prio=%d orig_cpu=%d dest_cpu=%d running=%d",
 		  __entry->comm, __entry->pid, __entry->prio,
-		  __entry->orig_cpu, __entry->dest_cpu)
+		  __entry->orig_cpu, __entry->dest_cpu,
+		  __entry->running)
 );
 
 DECLARE_EVENT_CLASS(sched_process_template,
diff --git a/include/trace/events/thermal_ipa_power.h b/include/trace/events/thermal_ipa_power.h
new file mode 100644
index 000000000..a3a932c75
--- /dev/null
+++ b/include/trace/events/thermal_ipa_power.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM thermal_ipa_power
+
+#if !defined(_TRACE_THERMAL_IPA_POWER_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_THERMAL_IPA_POWER_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(thermal_ipa_get_static_power,
+	TP_PROTO(u32 leakage, u32 coefficient, s32 temp,
+		 u32 temp_scaling_factor, u32 volt, u32 volt_scaling_factor,
+		 u32 static_power),
+
+	TP_ARGS(leakage, coefficient, temp, temp_scaling_factor, volt,
+		volt_scaling_factor, static_power),
+
+	TP_STRUCT__entry(
+		__field(u32,	leakage)
+		__field(u32,	coefficient)
+		__field(s32,	temp)
+		__field(u32,	temp_scaling_factor)
+		__field(u32,	volt)
+		__field(u32,	volt_scaling_factor)
+		__field(u32,	static_power)
+	),
+
+	TP_fast_assign(
+		__entry->leakage = leakage;
+		__entry->coefficient = coefficient;
+		__entry->temp = temp;
+		__entry->temp_scaling_factor = temp_scaling_factor;
+		__entry->volt = volt;
+		__entry->volt_scaling_factor = volt_scaling_factor;
+		__entry->static_power = static_power;
+	),
+	TP_printk("lkg=%u c=%u t=%d ts=%u v=%u vs=%u static_power=%u",
+		   __entry->leakage, __entry->coefficient, __entry->temp,
+		  __entry->temp_scaling_factor, __entry->volt,
+		  __entry->volt_scaling_factor, __entry->static_power)
+);
+
+
+#endif /* _TRACE_THERMAL_IPA_POWER_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/cgroup.h b/include/trace/hooks/cgroup.h
new file mode 100644
index 000000000..6b6d7918c
--- /dev/null
+++ b/include/trace/hooks/cgroup.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM cgroup
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH trace/hooks
+#if !defined(_TRACE_HOOK_CGROUP_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HOOK_CGROUP_H
+#include <linux/tracepoint.h>
+#include <trace/hooks/vendor_hooks.h>
+
+struct task_struct;
+DECLARE_HOOK(android_vh_cgroup_set_task,
+	TP_PROTO(int ret, struct task_struct *task),
+	TP_ARGS(ret, task));
+DECLARE_RESTRICTED_HOOK(android_rvh_cpuset_fork,
+	TP_PROTO(struct task_struct *p, int *inherit_cpus),
+	TP_ARGS(p, inherit_cpus), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_cgroup_force_kthread_migration,
+	TP_PROTO(struct task_struct *tsk, struct cgroup *dst_cgrp, bool *force_migration),
+	TP_ARGS(tsk, dst_cgrp, force_migration), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_refrigerator,
+	TP_PROTO(bool f),
+	TP_ARGS(f), 1);
+
+struct cgroup_subsys;
+struct cgroup_taskset;
+DECLARE_HOOK(android_vh_cgroup_attach,
+	TP_PROTO(struct cgroup_subsys *ss, struct cgroup_taskset *tset),
+	TP_ARGS(ss, tset))
+#endif
+
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/dtask.h b/include/trace/hooks/dtask.h
new file mode 100644
index 000000000..3c49af0e6
--- /dev/null
+++ b/include/trace/hooks/dtask.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM dtask
+#define TRACE_INCLUDE_PATH trace/hooks
+
+#if !defined(_TRACE_HOOK_DTASK_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HOOK_DTASK_H
+#include <linux/tracepoint.h>
+#include <trace/hooks/vendor_hooks.h>
+/*
+ * Following tracepoints are not exported in tracefs and provide a
+ * mechanism for vendor modules to hook and extend functionality
+ */
+struct mutex;
+DECLARE_HOOK(android_vh_mutex_wait_start,
+	TP_PROTO(struct mutex *lock),
+	TP_ARGS(lock));
+DECLARE_HOOK(android_vh_mutex_wait_finish,
+	TP_PROTO(struct mutex *lock),
+	TP_ARGS(lock));
+
+struct rt_mutex;
+DECLARE_HOOK(android_vh_rtmutex_wait_start,
+	TP_PROTO(struct rt_mutex *lock),
+	TP_ARGS(lock));
+DECLARE_HOOK(android_vh_rtmutex_wait_finish,
+	TP_PROTO(struct rt_mutex *lock),
+	TP_ARGS(lock));
+
+struct rw_semaphore;
+DECLARE_HOOK(android_vh_rwsem_read_wait_start,
+	TP_PROTO(struct rw_semaphore *sem),
+	TP_ARGS(sem));
+DECLARE_HOOK(android_vh_rwsem_read_wait_finish,
+	TP_PROTO(struct rw_semaphore *sem),
+	TP_ARGS(sem));
+DECLARE_HOOK(android_vh_rwsem_write_wait_start,
+	TP_PROTO(struct rw_semaphore *sem),
+	TP_ARGS(sem));
+DECLARE_HOOK(android_vh_rwsem_write_wait_finish,
+	TP_PROTO(struct rw_semaphore *sem),
+	TP_ARGS(sem));
+
+struct task_struct;
+DECLARE_HOOK(android_vh_sched_show_task,
+	TP_PROTO(struct task_struct *task),
+	TP_ARGS(task));
+DECLARE_HOOK(android_vh_alter_mutex_list_add,
+	TP_PROTO(struct mutex *lock,
+		struct mutex_waiter *waiter,
+		struct list_head *list,
+		bool *already_on_list),
+	TP_ARGS(lock, waiter, list, already_on_list));
+DECLARE_HOOK(android_vh_mutex_unlock_slowpath,
+	TP_PROTO(struct mutex *lock),
+	TP_ARGS(lock));
+
+/* macro versions of hooks are no longer required */
+
+#endif /* _TRACE_HOOK_DTASK_H */
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/mm.h b/include/trace/hooks/mm.h
new file mode 100644
index 000000000..4b299fd6e
--- /dev/null
+++ b/include/trace/hooks/mm.h
@@ -0,0 +1,134 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mm
+
+#define TRACE_INCLUDE_PATH trace/hooks
+
+#if !defined(_TRACE_HOOK_MM_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HOOK_MM_H
+
+#include <linux/types.h>
+
+#include <linux/mm.h>
+#include <linux/oom.h>
+#include <linux/tracepoint.h>
+#include <trace/hooks/vendor_hooks.h>
+
+struct cma;
+
+DECLARE_RESTRICTED_HOOK(android_rvh_set_skip_swapcache_flags,
+			TP_PROTO(gfp_t *flags),
+			TP_ARGS(flags), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_set_gfp_zone_flags,
+			TP_PROTO(gfp_t *flags),
+			TP_ARGS(flags), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_set_readahead_gfp_mask,
+			TP_PROTO(gfp_t *flags),
+			TP_ARGS(flags), 1);
+DECLARE_HOOK(android_vh_cma_alloc_start,
+	TP_PROTO(s64 *ts),
+	TP_ARGS(ts));
+DECLARE_HOOK(android_vh_cma_alloc_finish,
+	TP_PROTO(struct cma *cma, struct page *page, unsigned long count,
+		 unsigned int align, gfp_t gfp_mask, s64 ts),
+	TP_ARGS(cma, page, count, align, gfp_mask, ts));
+DECLARE_HOOK(android_vh_rmqueue,
+	TP_PROTO(struct zone *preferred_zone, struct zone *zone,
+		unsigned int order, gfp_t gfp_flags,
+		unsigned int alloc_flags, int migratetype),
+	TP_ARGS(preferred_zone, zone, order,
+		gfp_flags, alloc_flags, migratetype));
+DECLARE_HOOK(android_vh_pagecache_get_page,
+	TP_PROTO(struct address_space *mapping, pgoff_t index,
+		int fgp_flags, gfp_t gfp_mask, struct page *page),
+	TP_ARGS(mapping, index, fgp_flags, gfp_mask, page));
+DECLARE_HOOK(android_vh_filemap_fault_get_page,
+	TP_PROTO(struct vm_fault *vmf, struct page **page, bool *retry),
+	TP_ARGS(vmf, page, retry));
+DECLARE_HOOK(android_vh_filemap_fault_cache_page,
+	TP_PROTO(struct vm_fault *vmf, struct page *page),
+	TP_ARGS(vmf, page));
+DECLARE_HOOK(android_vh_meminfo_proc_show,
+	TP_PROTO(struct seq_file *m),
+	TP_ARGS(m));
+DECLARE_HOOK(android_vh_exit_mm,
+	TP_PROTO(struct mm_struct *mm),
+	TP_ARGS(mm));
+DECLARE_HOOK(android_vh_get_from_fragment_pool,
+	TP_PROTO(struct mm_struct *mm, struct vm_unmapped_area_info *info,
+		unsigned long *addr),
+	TP_ARGS(mm, info, addr));
+DECLARE_HOOK(android_vh_exclude_reserved_zone,
+	TP_PROTO(struct mm_struct *mm, struct vm_unmapped_area_info *info),
+	TP_ARGS(mm, info));
+DECLARE_HOOK(android_vh_include_reserved_zone,
+	TP_PROTO(struct mm_struct *mm, struct vm_unmapped_area_info *info,
+		unsigned long *addr),
+	TP_ARGS(mm, info, addr));
+DECLARE_HOOK(android_vh_show_mem,
+	TP_PROTO(unsigned int filter, nodemask_t *nodemask),
+	TP_ARGS(filter, nodemask));
+DECLARE_HOOK(android_vh_alloc_pages_slowpath,
+	TP_PROTO(gfp_t gfp_mask, unsigned int order, unsigned long delta),
+	TP_ARGS(gfp_mask, order, delta));
+DECLARE_HOOK(android_vh_print_slabinfo_header,
+	TP_PROTO(struct seq_file *m),
+	TP_ARGS(m));
+struct slabinfo;
+DECLARE_HOOK(android_vh_cache_show,
+	TP_PROTO(struct seq_file *m, struct slabinfo *sinfo, struct kmem_cache *s),
+	TP_ARGS(m, sinfo, s));
+struct dirty_throttle_control;
+DECLARE_HOOK(android_vh_mm_dirty_limits,
+	TP_PROTO(struct dirty_throttle_control *const gdtc, bool strictlimit,
+		unsigned long dirty, unsigned long bg_thresh,
+		unsigned long nr_reclaimable, unsigned long pages_dirtied),
+	TP_ARGS(gdtc, strictlimit, dirty, bg_thresh,
+		nr_reclaimable, pages_dirtied));
+DECLARE_HOOK(android_vh_oom_check_panic,
+	TP_PROTO(struct oom_control *oc, int *ret),
+	TP_ARGS(oc, ret));
+DECLARE_HOOK(android_vh_save_vmalloc_stack,
+	TP_PROTO(unsigned long flags, struct vm_struct *vm),
+	TP_ARGS(flags, vm));
+DECLARE_HOOK(android_vh_show_stack_hash,
+	TP_PROTO(struct seq_file *m, struct vm_struct *v),
+	TP_ARGS(m, v));
+DECLARE_HOOK(android_vh_save_track_hash,
+	TP_PROTO(bool alloc, unsigned long p),
+	TP_ARGS(alloc, p));
+struct mem_cgroup;
+DECLARE_HOOK(android_vh_vmpressure,
+	TP_PROTO(struct mem_cgroup *memcg, bool *bypass),
+	TP_ARGS(memcg, bypass));
+DECLARE_HOOK(android_vh_mem_cgroup_alloc,
+	TP_PROTO(struct mem_cgroup *memcg),
+	TP_ARGS(memcg));
+DECLARE_HOOK(android_vh_mem_cgroup_free,
+	TP_PROTO(struct mem_cgroup *memcg),
+	TP_ARGS(memcg));
+DECLARE_HOOK(android_vh_mem_cgroup_id_remove,
+	TP_PROTO(struct mem_cgroup *memcg),
+	TP_ARGS(memcg));
+struct cgroup_subsys_state;
+DECLARE_HOOK(android_vh_mem_cgroup_css_online,
+	TP_PROTO(struct cgroup_subsys_state *css, struct mem_cgroup *memcg),
+	TP_ARGS(css, memcg));
+DECLARE_HOOK(android_vh_mem_cgroup_css_offline,
+	TP_PROTO(struct cgroup_subsys_state *css, struct mem_cgroup *memcg),
+	TP_ARGS(css, memcg));
+DECLARE_HOOK(android_vh_kmalloc_slab,
+	TP_PROTO(unsigned int index, gfp_t flags, struct kmem_cache **s),
+	TP_ARGS(index, flags, s));
+DECLARE_HOOK(android_vh_mmap_region,
+	TP_PROTO(struct vm_area_struct *vma, unsigned long addr),
+	TP_ARGS(vma, addr));
+DECLARE_HOOK(android_vh_try_to_unmap_one,
+	TP_PROTO(struct vm_area_struct *vma, struct page *page, unsigned long addr, bool ret),
+	TP_ARGS(vma, page, addr, ret));
+/* macro versions of hooks are no longer required */
+
+#endif /* _TRACE_HOOK_MM_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/psi.h b/include/trace/hooks/psi.h
new file mode 100644
index 000000000..62d1a0ee7
--- /dev/null
+++ b/include/trace/hooks/psi.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM psi
+
+#define TRACE_INCLUDE_PATH trace/hooks
+
+#if !defined(_TRACE_HOOK_PSI_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HOOK_PSI_H
+
+#include <linux/tracepoint.h>
+#include <trace/hooks/vendor_hooks.h>
+
+#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS)
+
+struct psi_trigger;
+struct psi_group;
+DECLARE_HOOK(android_vh_psi_event,
+	TP_PROTO(struct psi_trigger *t),
+	TP_ARGS(t));
+
+DECLARE_HOOK(android_vh_psi_group,
+	TP_PROTO(struct psi_group *group),
+	TP_ARGS(group));
+
+#else
+#define trace_android_vh_psi_event(t)
+#define trace_android_vh_psi_group(group)
+#endif
+
+#endif /* _TRACE_HOOK_PSI_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/sched.h b/include/trace/hooks/sched.h
new file mode 100644
index 000000000..0844244c9
--- /dev/null
+++ b/include/trace/hooks/sched.h
@@ -0,0 +1,397 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sched
+#define TRACE_INCLUDE_PATH trace/hooks
+#if !defined(_TRACE_HOOK_SCHED_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HOOK_SCHED_H
+#include <linux/tracepoint.h>
+#include <trace/hooks/vendor_hooks.h>
+/*
+ * Following tracepoints are not exported in tracefs and provide a
+ * mechanism for vendor modules to hook and extend functionality
+ */
+struct task_struct;
+DECLARE_RESTRICTED_HOOK(android_rvh_select_task_rq_fair,
+	TP_PROTO(struct task_struct *p, int prev_cpu, int sd_flag, int wake_flags, int *new_cpu),
+	TP_ARGS(p, prev_cpu, sd_flag, wake_flags, new_cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_select_task_rq_rt,
+	TP_PROTO(struct task_struct *p, int prev_cpu, int sd_flag, int wake_flags, int *new_cpu),
+	TP_ARGS(p, prev_cpu, sd_flag, wake_flags, new_cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_select_fallback_rq,
+	TP_PROTO(int cpu, struct task_struct *p, int *new_cpu),
+	TP_ARGS(cpu, p, new_cpu), 1);
+
+struct rq;
+DECLARE_HOOK(android_vh_scheduler_tick,
+	TP_PROTO(struct rq *rq),
+	TP_ARGS(rq));
+
+DECLARE_RESTRICTED_HOOK(android_rvh_enqueue_task,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int flags),
+	TP_ARGS(rq, p, flags), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_dequeue_task,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int flags),
+	TP_ARGS(rq, p, flags), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_can_migrate_task,
+	TP_PROTO(struct task_struct *p, int dst_cpu, int *can_migrate),
+	TP_ARGS(p, dst_cpu, can_migrate), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_find_lowest_rq,
+	TP_PROTO(struct task_struct *p, struct cpumask *local_cpu_mask,
+			int ret, int *lowest_cpu),
+	TP_ARGS(p, local_cpu_mask, ret, lowest_cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_prepare_prio_fork,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_finish_prio_fork,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_rtmutex_prepare_setprio,
+	TP_PROTO(struct task_struct *p, struct task_struct *pi_task),
+	TP_ARGS(p, pi_task), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_set_user_nice,
+	TP_PROTO(struct task_struct *p, long *nice, bool *allowed),
+	TP_ARGS(p, nice, allowed), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_setscheduler,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+struct sched_group;
+DECLARE_RESTRICTED_HOOK(android_rvh_find_busiest_group,
+	TP_PROTO(struct sched_group *busiest, struct rq *dst_rq, int *out_balance),
+		TP_ARGS(busiest, dst_rq, out_balance), 1);
+
+DECLARE_HOOK(android_vh_dump_throttled_rt_tasks,
+	TP_PROTO(int cpu, u64 clock, ktime_t rt_period, u64 rt_runtime,
+			s64 rt_period_timer_expires),
+	TP_ARGS(cpu, clock, rt_period, rt_runtime, rt_period_timer_expires));
+
+DECLARE_HOOK(android_vh_jiffies_update,
+	TP_PROTO(void *unused),
+	TP_ARGS(unused));
+
+struct rq_flags;
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_newidle_balance,
+	TP_PROTO(struct rq *this_rq, struct rq_flags *rf,
+		 int *pulled_task, int *done),
+	TP_ARGS(this_rq, rf, pulled_task, done), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_nohz_balancer_kick,
+	TP_PROTO(struct rq *rq, unsigned int *flags, int *done),
+	TP_ARGS(rq, flags, done), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_rebalance_domains,
+	TP_PROTO(struct rq *rq, int *continue_balancing),
+	TP_ARGS(rq, continue_balancing), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_find_busiest_queue,
+	TP_PROTO(int dst_cpu, struct sched_group *group,
+		 struct cpumask *env_cpus, struct rq **busiest,
+		 int *done),
+	TP_ARGS(dst_cpu, group, env_cpus, busiest, done), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_migrate_queued_task,
+	TP_PROTO(struct rq *rq, struct rq_flags *rf,
+		 struct task_struct *p, int new_cpu,
+		 int *detached),
+	TP_ARGS(rq, rf, p, new_cpu, detached), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_resume_cpus,
+	TP_PROTO(struct cpumask *cpus, int *err),
+	TP_ARGS(cpus, err), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_find_energy_efficient_cpu,
+	TP_PROTO(struct task_struct *p, int prev_cpu, int sync, int *new_cpu),
+	TP_ARGS(p, prev_cpu, sync, new_cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_set_iowait,
+	TP_PROTO(struct task_struct *p, int *should_iowait_boost),
+	TP_ARGS(p, should_iowait_boost), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_cpu_overutilized,
+	TP_PROTO(int cpu, int *overutilized),
+	TP_ARGS(cpu, overutilized), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_setaffinity,
+	TP_PROTO(struct task_struct *p, const struct cpumask *in_mask, int *retval),
+	TP_ARGS(p, in_mask, retval), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_update_cpus_allowed,
+	TP_PROTO(struct task_struct *p, cpumask_var_t cpus_requested,
+		 const struct cpumask *new_mask, int *ret),
+	TP_ARGS(p, cpus_requested, new_mask, ret), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_set_task_cpu,
+	TP_PROTO(struct task_struct *p, unsigned int new_cpu),
+	TP_ARGS(p, new_cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_try_to_wake_up,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_try_to_wake_up_success,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_fork,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_wake_up_new_task,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_new_task_stats,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_flush_task,
+	TP_PROTO(struct task_struct *prev),
+	TP_ARGS(prev), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_tick_entry,
+	TP_PROTO(struct rq *rq),
+	TP_ARGS(rq), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_schedule,
+	TP_PROTO(struct task_struct *prev, struct task_struct *next, struct rq *rq),
+	TP_ARGS(prev, next, rq), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_cpu_starting,
+	TP_PROTO(int cpu),
+	TP_ARGS(cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_cpu_dying,
+	TP_PROTO(int cpu),
+	TP_ARGS(cpu), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_account_irq,
+	TP_PROTO(struct task_struct *curr, int cpu, s64 delta),
+	TP_ARGS(curr, cpu, delta), 1);
+
+struct sched_entity;
+DECLARE_RESTRICTED_HOOK(android_rvh_place_entity,
+	TP_PROTO(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial, u64 vruntime),
+	TP_ARGS(cfs_rq, se, initial, vruntime), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_build_perf_domains,
+	TP_PROTO(bool *eas_check),
+	TP_ARGS(eas_check), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_update_cpu_capacity,
+	TP_PROTO(int cpu, unsigned long *capacity),
+	TP_ARGS(cpu, capacity), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_update_misfit_status,
+	TP_PROTO(struct task_struct *p, struct rq *rq, bool *need_update),
+	TP_ARGS(p, rq, need_update), 1);
+
+struct cgroup_taskset;
+DECLARE_RESTRICTED_HOOK(android_rvh_cpu_cgroup_attach,
+	TP_PROTO(struct cgroup_taskset *tset),
+	TP_ARGS(tset), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_cpu_cgroup_can_attach,
+	TP_PROTO(struct cgroup_taskset *tset, int *retval),
+	TP_ARGS(tset, retval), 1);
+
+struct cgroup_subsys_state;
+DECLARE_RESTRICTED_HOOK(android_rvh_cpu_cgroup_online,
+	TP_PROTO(struct cgroup_subsys_state *css),
+	TP_ARGS(css), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_fork_init,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_ttwu_cond,
+	TP_PROTO(bool *cond),
+	TP_ARGS(cond), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_schedule_bug,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_exec,
+	TP_PROTO(bool *cond),
+	TP_ARGS(cond), 1);
+
+struct cpufreq_policy;
+DECLARE_HOOK(android_vh_map_util_freq,
+	TP_PROTO(unsigned long util, unsigned long freq,
+		unsigned long cap, unsigned long *next_freq, struct cpufreq_policy *policy,
+		bool *need_freq_update),
+	TP_ARGS(util, freq, cap, next_freq, policy, need_freq_update));
+
+struct em_perf_domain;
+DECLARE_HOOK(android_vh_em_cpu_energy,
+	TP_PROTO(struct em_perf_domain *pd,
+		unsigned long max_util, unsigned long sum_util,
+		unsigned long *energy),
+	TP_ARGS(pd, max_util, sum_util, energy));
+
+DECLARE_RESTRICTED_HOOK(android_rvh_sched_balance_rt,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int *done),
+	TP_ARGS(rq, p, done), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_dequeue_task_idle,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p), 1);
+
+struct cfs_rq;
+DECLARE_RESTRICTED_HOOK(android_rvh_pick_next_entity,
+	TP_PROTO(struct cfs_rq *cfs_rq, struct sched_entity *curr,
+		 struct sched_entity **se),
+	TP_ARGS(cfs_rq, curr, se), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_check_preempt_wakeup,
+	TP_PROTO(struct rq *rq, struct task_struct *p, bool *preempt, bool *nopreempt,
+			int wake_flags, struct sched_entity *se, struct sched_entity *pse,
+			int next_buddy_marked, unsigned int granularity),
+	TP_ARGS(rq, p, preempt, nopreempt, wake_flags, se, pse, next_buddy_marked,
+			granularity), 1);
+
+DECLARE_HOOK(android_vh_do_wake_up_sync,
+	TP_PROTO(struct wait_queue_head *wq_head, int *done),
+	TP_ARGS(wq_head, done));
+
+DECLARE_HOOK(android_vh_set_wake_flags,
+	TP_PROTO(int *wake_flags, unsigned int *mode),
+	TP_ARGS(wake_flags, mode));
+
+enum uclamp_id;
+struct uclamp_se;
+DECLARE_RESTRICTED_HOOK(android_rvh_uclamp_eff_get,
+	TP_PROTO(struct task_struct *p, enum uclamp_id clamp_id,
+		 struct uclamp_se *uclamp_max, struct uclamp_se *uclamp_eff, int *ret),
+	TP_ARGS(p, clamp_id, uclamp_max, uclamp_eff, ret), 1);
+
+DECLARE_HOOK(android_vh_build_sched_domains,
+	TP_PROTO(bool has_asym),
+	TP_ARGS(has_asym));
+DECLARE_RESTRICTED_HOOK(android_rvh_check_preempt_tick,
+	TP_PROTO(struct task_struct *p, unsigned long *ideal_runtime, bool *skip_preempt,
+			unsigned long delta_exec, struct cfs_rq *cfs_rq, struct sched_entity *curr,
+			unsigned int granularity),
+	TP_ARGS(p, ideal_runtime, skip_preempt, delta_exec, cfs_rq, curr, granularity), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_check_preempt_wakeup_ignore,
+	TP_PROTO(struct task_struct *p, bool *ignore),
+	TP_ARGS(p, ignore), 1);
+DECLARE_RESTRICTED_HOOK(android_rvh_replace_next_task_fair,
+	TP_PROTO(struct rq *rq, struct task_struct **p, struct sched_entity **se, bool *repick,
+			bool simple, struct task_struct *prev),
+	TP_ARGS(rq, p, se, repick, simple, prev), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_do_sched_yield,
+	TP_PROTO(struct rq *rq),
+	TP_ARGS(rq), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_util_est_update,
+	TP_PROTO(struct cfs_rq *cfs_rq, struct task_struct *p, bool task_sleep, int *ret),
+	TP_ARGS(cfs_rq, p, task_sleep, ret), 1);
+
+DECLARE_HOOK(android_vh_account_task_time,
+	TP_PROTO(struct task_struct *p, struct rq *rq, int user_tick),
+	TP_ARGS(p, rq, user_tick));
+
+DECLARE_HOOK(android_vh_irqtime_account_process_tick,
+	TP_PROTO(struct task_struct *p, struct rq *rq, int user_tick, int ticks),
+	TP_ARGS(p, rq, user_tick, ticks));
+
+DECLARE_RESTRICTED_HOOK(android_rvh_post_init_entity_util_avg,
+	TP_PROTO(struct sched_entity *se),
+	TP_ARGS(se), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_set_cpus_allowed_comm,
+	TP_PROTO(struct task_struct *p, const struct cpumask *new_mask),
+	TP_ARGS(p, new_mask), 1);
+
+DECLARE_HOOK(android_vh_sched_setaffinity_early,
+	TP_PROTO(struct task_struct *p, const struct cpumask *new_mask, int *retval),
+	TP_ARGS(p, new_mask, retval));
+
+DECLARE_HOOK(android_vh_free_task,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p));
+
+DECLARE_RESTRICTED_HOOK(android_rvh_after_enqueue_task,
+	TP_PROTO(struct rq *rq, struct task_struct *p),
+	TP_ARGS(rq, p), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_after_dequeue_task,
+	TP_PROTO(struct rq *rq, struct task_struct *p),
+	TP_ARGS(rq, p), 1);
+
+struct cfs_rq;
+struct sched_entity;
+struct rq_flags;
+DECLARE_RESTRICTED_HOOK(android_rvh_enqueue_entity,
+	TP_PROTO(struct cfs_rq *cfs, struct sched_entity *se),
+	TP_ARGS(cfs, se), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_dequeue_entity,
+	TP_PROTO(struct cfs_rq *cfs, struct sched_entity *se),
+	TP_ARGS(cfs, se), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_entity_tick,
+	TP_PROTO(struct cfs_rq *cfs_rq, struct sched_entity *se),
+	TP_ARGS(cfs_rq, se), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_enqueue_task_fair,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int flags),
+	TP_ARGS(rq, p, flags), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_dequeue_task_fair,
+	TP_PROTO(struct rq *rq, struct task_struct *p, int flags),
+	TP_ARGS(rq, p, flags), 1);
+
+DECLARE_HOOK(android_vh_prepare_update_load_avg_se,
+	TP_PROTO(struct sched_entity *se, int flags),
+	TP_ARGS(se, flags));
+
+DECLARE_HOOK(android_vh_sched_stat_runtime_rt,
+	TP_PROTO(struct task_struct *tsk, u64 delta),
+	TP_ARGS(tsk, delta));
+
+DECLARE_HOOK(android_vh_finish_update_load_avg_se,
+	TP_PROTO(struct sched_entity *se, int flags),
+	TP_ARGS(se, flags));
+
+DECLARE_HOOK(android_vh_dup_task_struct,
+	TP_PROTO(struct task_struct *tsk, struct task_struct *orig),
+	TP_ARGS(tsk, orig));
+
+DECLARE_HOOK(android_vh_set_task_comm,
+	TP_PROTO(struct task_struct *p),
+	TP_ARGS(p));
+
+DECLARE_RESTRICTED_HOOK(android_rvh_find_new_ilb,
+	TP_PROTO(struct cpumask *nohz_idle_cpus_mask, int *ilb),
+	TP_ARGS(nohz_idle_cpus_mask, ilb), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_force_compatible_pre,
+	TP_PROTO(void *unused),
+	TP_ARGS(unused), 1);
+
+DECLARE_RESTRICTED_HOOK(android_rvh_force_compatible_post,
+	TP_PROTO(void *unused),
+	TP_ARGS(unused), 1);
+
+DECLARE_HOOK(android_vh_setscheduler_uclamp,
+	TP_PROTO(struct task_struct *tsk, int clamp_id, unsigned int value),
+	TP_ARGS(tsk, clamp_id, value));
+
+/* macro versions of hooks are no longer required */
+
+#endif /* _TRACE_HOOK_SCHED_H */
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/hooks/vendor_hooks.h b/include/trace/hooks/vendor_hooks.h
new file mode 100644
index 000000000..87fe9ccdc
--- /dev/null
+++ b/include/trace/hooks/vendor_hooks.h
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * Note: we intentionally omit include file ifdef protection
+ *  This is due to the way trace events work. If a file includes two
+ *  trace event headers under one "CREATE_TRACE_POINTS" the first include
+ *  will override the DECLARE_RESTRICTED_HOOK and break the second include.
+ */
+
+#include <linux/tracepoint.h>
+
+#if defined(CONFIG_TRACEPOINTS) && defined(CONFIG_ANDROID_VENDOR_HOOKS)
+
+#define DECLARE_HOOK DECLARE_TRACE
+
+int android_rvh_probe_register(struct tracepoint *tp, void *probe, void *data);
+
+#ifdef TRACE_HEADER_MULTI_READ
+
+#define DEFINE_HOOK_FN(_name, _reg, _unreg, proto, args)		\
+	static const char __tpstrtab_##_name[]				\
+	__section("__tracepoints_strings") = #_name;			\
+	extern struct static_call_key STATIC_CALL_KEY(tp_func_##_name);	\
+	int __traceiter_##_name(void *__data, proto);			\
+	struct tracepoint __tracepoint_##_name	__used			\
+	__section("__tracepoints") = {					\
+		.name = __tpstrtab_##_name,				\
+		.key = STATIC_KEY_INIT_FALSE,				\
+		.static_call_key = &STATIC_CALL_KEY(tp_func_##_name),	\
+		.static_call_tramp = STATIC_CALL_TRAMP_ADDR(tp_func_##_name), \
+		.iterator = &__traceiter_##_name,			\
+		.regfunc = _reg,					\
+		.unregfunc = _unreg,					\
+		.funcs = NULL };					\
+	__TRACEPOINT_ENTRY(_name);					\
+	int __nocfi __traceiter_##_name(void *__data, proto)			\
+	{								\
+		struct tracepoint_func *it_func_ptr;			\
+		void *it_func;						\
+									\
+		it_func_ptr = (&__tracepoint_##_name)->funcs;		\
+		it_func = (it_func_ptr)->func;				\
+		do {							\
+			__data = (it_func_ptr)->data;			\
+			((void(*)(void *, proto))(it_func))(__data, args); \
+			it_func = READ_ONCE((++it_func_ptr)->func);	\
+		} while (it_func);					\
+		return 0;						\
+	}								\
+	DEFINE_STATIC_CALL(tp_func_##_name, __traceiter_##_name);
+
+#undef DECLARE_RESTRICTED_HOOK
+#define DECLARE_RESTRICTED_HOOK(name, proto, args, cond) \
+	DEFINE_HOOK_FN(name, NULL, NULL, PARAMS(proto), PARAMS(args))
+
+/* prevent additional recursion */
+#undef TRACE_HEADER_MULTI_READ
+#else /* TRACE_HEADER_MULTI_READ */
+
+#define DO_HOOK(name, proto, args, cond)				\
+	do {								\
+		struct tracepoint_func *it_func_ptr;			\
+		void *__data;						\
+									\
+		if (!(cond))						\
+			return;						\
+									\
+		it_func_ptr = (&__tracepoint_##name)->funcs;		\
+		if (it_func_ptr) {					\
+			__data = (it_func_ptr)->data;			\
+			__DO_TRACE_CALL(name)(args);			\
+		}							\
+	} while (0)
+
+#define __DECLARE_HOOK(name, proto, args, cond, data_proto, data_args)	\
+	extern int __traceiter_##name(data_proto);			\
+	DECLARE_STATIC_CALL(tp_func_##name, __traceiter_##name);	\
+	extern struct tracepoint __tracepoint_##name;			\
+	static inline void __nocfi trace_##name(proto)			\
+	{								\
+		if (static_key_false(&__tracepoint_##name.key))		\
+			DO_HOOK(name,					\
+				TP_PROTO(data_proto),			\
+				TP_ARGS(data_args),			\
+				TP_CONDITION(cond));			\
+	}								\
+	static inline bool						\
+	trace_##name##_enabled(void)					\
+	{								\
+		return static_key_false(&__tracepoint_##name.key);	\
+	}								\
+	static inline int						\
+	register_trace_##name(void (*probe)(data_proto), void *data) 	\
+	{								\
+		return android_rvh_probe_register(&__tracepoint_##name,	\
+						  (void *)probe, data);	\
+	}								\
+	/* vendor hooks cannot be unregistered */			\
+
+#undef DECLARE_RESTRICTED_HOOK
+#define DECLARE_RESTRICTED_HOOK(name, proto, args, cond)		\
+	__DECLARE_HOOK(name, PARAMS(proto), PARAMS(args),		\
+			cond,						\
+			PARAMS(void *__data, proto),			\
+			PARAMS(__data, args))
+
+#endif /* TRACE_HEADER_MULTI_READ */
+
+#else /* !CONFIG_TRACEPOINTS || !CONFIG_ANDROID_VENDOR_HOOKS */
+/* suppress trace hooks */
+#define DECLARE_HOOK DECLARE_EVENT_NOP
+#define DECLARE_RESTRICTED_HOOK(name, proto, args, cond)		\
+	DECLARE_EVENT_NOP(name, PARAMS(proto), PARAMS(args))
+#endif
diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
index 5498d7a65..5b5db0381 100644
--- a/include/uapi/drm/drm_fourcc.h
+++ b/include/uapi/drm/drm_fourcc.h
@@ -242,6 +242,8 @@ extern "C" {
  * index 1 = Cr:Cb plane, [39:0] Cr1:Cb1:Cr0:Cb0 little endian
  */
 #define DRM_FORMAT_NV15		fourcc_code('N', 'V', '1', '5') /* 2x2 subsampled Cr:Cb plane */
+#define DRM_FORMAT_NV20		fourcc_code('N', 'V', '2', '0') /* 2x1 subsampled Cr:Cb plane */
+#define DRM_FORMAT_NV30		fourcc_code('N', 'V', '3', '0') /* non-subsampled Cr:Cb plane */
 
 /*
  * 2 plane YCbCr MSB aligned
diff --git a/include/uapi/drm/rockchip_drm.h b/include/uapi/drm/rockchip_drm.h
new file mode 100644
index 000000000..246192fa2
--- /dev/null
+++ b/include/uapi/drm/rockchip_drm.h
@@ -0,0 +1,134 @@
+/*
+ *
+ * Copyright (c) Fuzhou Rockchip Electronics Co.Ltd
+ * Authors:
+ *       Mark Yao <yzq@rock-chips.com>
+ *
+ * base on exynos_drm.h
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef _UAPI_ROCKCHIP_DRM_H
+#define _UAPI_ROCKCHIP_DRM_H
+
+#include <drm/drm.h>
+#include <drm/drm_file.h>
+
+/*
+ * Send vcnt event instead of blocking,
+ * like _DRM_VBLANK_EVENT
+ */
+#define _DRM_ROCKCHIP_VCNT_EVENT 0x80000000
+#define DRM_EVENT_ROCKCHIP_CRTC_VCNT   0xf
+
+/* memory type definitions. */
+enum drm_rockchip_gem_mem_type {
+	/* Physically Continuous memory. */
+	ROCKCHIP_BO_CONTIG	= 1 << 0,
+	/* cachable mapping. */
+	ROCKCHIP_BO_CACHABLE	= 1 << 1,
+	/* write-combine mapping. */
+	ROCKCHIP_BO_WC		= 1 << 2,
+	ROCKCHIP_BO_SECURE	= 1 << 3,
+	/* keep kmap for cma buffer or alloc kmap for other type memory */
+	ROCKCHIP_BO_ALLOC_KMAP	= 1 << 4,
+	ROCKCHIP_BO_MASK	= ROCKCHIP_BO_CONTIG | ROCKCHIP_BO_CACHABLE |
+				ROCKCHIP_BO_WC | ROCKCHIP_BO_SECURE | ROCKCHIP_BO_ALLOC_KMAP,
+};
+
+/**
+ * User-desired buffer creation information structure.
+ *
+ * @size: user-desired memory allocation size.
+ * @flags: user request for setting memory type or cache attributes.
+ * @handle: returned a handle to created gem object.
+ *     - this handle will be set by gem module of kernel side.
+ */
+struct drm_rockchip_gem_create {
+	uint64_t size;
+	uint32_t flags;
+	uint32_t handle;
+};
+
+struct drm_rockchip_gem_phys {
+	uint32_t handle;
+	uint32_t phy_addr;
+};
+
+/**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *     - this value should be set by user.
+ */
+struct drm_rockchip_gem_map_off {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t offset;
+};
+
+/* acquire type definitions. */
+enum drm_rockchip_gem_cpu_acquire_type {
+	DRM_ROCKCHIP_GEM_CPU_ACQUIRE_SHARED = 0x0,
+	DRM_ROCKCHIP_GEM_CPU_ACQUIRE_EXCLUSIVE = 0x1,
+};
+
+enum rockchip_crtc_feture {
+	ROCKCHIP_DRM_CRTC_FEATURE_ALPHA_SCALE,
+	ROCKCHIP_DRM_CRTC_FEATURE_HDR10,
+	ROCKCHIP_DRM_CRTC_FEATURE_NEXT_HDR,
+};
+
+enum rockchip_plane_feture {
+	ROCKCHIP_DRM_PLANE_FEATURE_SCALE,
+	ROCKCHIP_DRM_PLANE_FEATURE_ALPHA,
+	ROCKCHIP_DRM_PLANE_FEATURE_HDR2SDR,
+	ROCKCHIP_DRM_PLANE_FEATURE_SDR2HDR,
+	ROCKCHIP_DRM_PLANE_FEATURE_AFBDC,
+	ROCKCHIP_DRM_PLANE_FEATURE_PDAF_POS,
+	ROCKCHIP_DRM_PLANE_FEATURE_MAX,
+};
+
+enum rockchip_cabc_mode {
+	ROCKCHIP_DRM_CABC_MODE_DISABLE,
+	ROCKCHIP_DRM_CABC_MODE_NORMAL,
+	ROCKCHIP_DRM_CABC_MODE_LOWPOWER,
+	ROCKCHIP_DRM_CABC_MODE_USERSPACE,
+};
+
+struct drm_rockchip_vcnt_event {
+	struct drm_pending_event	base;
+};
+
+#define DRM_ROCKCHIP_GEM_CREATE		0x00
+#define DRM_ROCKCHIP_GEM_MAP_OFFSET	0x01
+#define DRM_ROCKCHIP_GEM_CPU_ACQUIRE	0x02
+#define DRM_ROCKCHIP_GEM_CPU_RELEASE	0x03
+#define DRM_ROCKCHIP_GEM_GET_PHYS	0x04
+#define DRM_ROCKCHIP_GET_VCNT_EVENT	0x05
+
+#define DRM_IOCTL_ROCKCHIP_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_CREATE, struct drm_rockchip_gem_create)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_MAP_OFFSET, struct drm_rockchip_gem_map_off)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_CPU_ACQUIRE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_CPU_ACQUIRE, struct drm_rockchip_gem_cpu_acquire)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_CPU_RELEASE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_CPU_RELEASE, struct drm_rockchip_gem_cpu_release)
+
+#define DRM_IOCTL_ROCKCHIP_GEM_GET_PHYS		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GEM_GET_PHYS, struct drm_rockchip_gem_phys)
+
+#define DRM_IOCTL_ROCKCHIP_GET_VCNT_EVENT	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_ROCKCHIP_GET_VCNT_EVENT, union drm_wait_vblank)
+
+#endif /* _UAPI_ROCKCHIP_DRM_H */
diff --git a/include/uapi/linux/fec-config.h b/include/uapi/linux/fec-config.h
new file mode 100644
index 000000000..2b3f97fb2
--- /dev/null
+++ b/include/uapi/linux/fec-config.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT)
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_FEC_CONFIG_H
+#define _UAPI_FEC_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+
+#define FEC_API_VERSION		KERNEL_VERSION(1, 0, 0)
+struct fec_config {
+	u32 mesh_density;
+	u32 src_width;
+	u32 src_height;
+	u32 dst_width;
+	u32 dst_height;
+	u32 mesh_size;
+	s32 buf_fd;
+	u32 fec_bic_mode;
+} __attribute__ ((packed));
+
+struct fec_params_cfg {
+	u32 module_en_update;
+	u32 module_ens;
+	u32 module_cfg_update;
+
+	u32 frame_id;
+	struct fec_config fec_cfg;
+} __attribute__ ((packed));
+
+#endif
diff --git a/include/uapi/linux/media-bus-format.h b/include/uapi/linux/media-bus-format.h
index 84fa53ffb..096f891d4 100644
--- a/include/uapi/linux/media-bus-format.h
+++ b/include/uapi/linux/media-bus-format.h
@@ -34,7 +34,7 @@
 
 #define MEDIA_BUS_FMT_FIXED			0x0001
 
-/* RGB - next is	0x101d */
+/* RGB - next is	0x1024 */
 #define MEDIA_BUS_FMT_RGB444_1X12		0x1016
 #define MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE	0x1001
 #define MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE	0x1002
@@ -63,6 +63,10 @@
 #define MEDIA_BUS_FMT_RGB101010_1X30		0x1018
 #define MEDIA_BUS_FMT_RGB121212_1X36		0x1019
 #define MEDIA_BUS_FMT_RGB161616_1X48		0x101a
+#define MEDIA_BUS_FMT_RGB888_DUMMY_4X8		0x101f
+#define MEDIA_BUS_FMT_BGR888_DUMMY_4X8		0x1020
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG	0x1022
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA	0x1023
 
 /* YUV (including grey) - next is	0x202e */
 #define MEDIA_BUS_FMT_Y8_1X8			0x2001
diff --git a/include/uapi/linux/rk-camera-module.h b/include/uapi/linux/rk-camera-module.h
new file mode 100644
index 000000000..6746ce7d9
--- /dev/null
+++ b/include/uapi/linux/rk-camera-module.h
@@ -0,0 +1,560 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+/*
+ * Rockchip module information
+ * Copyright (C) 2018-2019 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKMODULE_CAMERA_H
+#define _UAPI_RKMODULE_CAMERA_H
+
+#include <linux/types.h>
+#include <linux/rk-video-format.h>
+
+#define RKMODULE_API_VERSION		KERNEL_VERSION(0, 1, 0x2)
+
+/* using for rk3588 dual isp unite */
+#define RKMOUDLE_UNITE_EXTEND_PIXEL	128
+/* using for rv1109 and rv1126 */
+#define RKMODULE_EXTEND_LINE		24
+
+#define RKMODULE_NAME_LEN		32
+#define RKMODULE_LSCDATA_LEN		289
+
+#define RKMODULE_MAX_VC_CH		4
+
+#define RKMODULE_PADF_GAINMAP_LEN	1024
+#define RKMODULE_PDAF_DCCMAP_LEN	256
+#define RKMODULE_AF_OTP_MAX_LEN		3
+
+#define RKMODULE_CAMERA_MODULE_INDEX	"rockchip,camera-module-index"
+#define RKMODULE_CAMERA_MODULE_FACING	"rockchip,camera-module-facing"
+#define RKMODULE_CAMERA_MODULE_NAME	"rockchip,camera-module-name"
+#define RKMODULE_CAMERA_LENS_NAME	"rockchip,camera-module-lens-name"
+
+#define RKMODULE_CAMERA_SYNC_MODE	"rockchip,camera-module-sync-mode"
+#define RKMODULE_INTERNAL_MASTER_MODE	"internal_master"
+#define RKMODULE_EXTERNAL_MASTER_MODE	"external_master"
+#define RKMODULE_SLAVE_MODE		"slave"
+
+/* BT.656 & BT.1120 multi channel
+ * On which channels it can send video data
+ * related with struct rkmodule_bt656_mbus_info
+ */
+#define RKMODULE_CAMERA_BT656_ID_EN_BITS_1		(0x1)
+#define RKMODULE_CAMERA_BT656_ID_EN_BITS_2		(0x3)
+#define RKMODULE_CAMERA_BT656_ID_EN_BITS_3		(0x7)
+#define RKMODULE_CAMERA_BT656_ID_EN_BITS_4		(0xf)
+#define RKMODULE_CAMERA_BT656_PARSE_ID_LSB		BIT(0)
+#define RKMODULE_CAMERA_BT656_PARSE_ID_MSB		BIT(1)
+#define RKMODULE_CAMERA_BT656_CHANNEL_0			BIT(2)
+#define RKMODULE_CAMERA_BT656_CHANNEL_1			BIT(3)
+#define RKMODULE_CAMERA_BT656_CHANNEL_2			BIT(4)
+#define RKMODULE_CAMERA_BT656_CHANNEL_3			BIT(5)
+#define RKMODULE_CAMERA_BT656_CHANNELS			(RKMODULE_CAMERA_BT656_CHANNEL_0 | \
+							 RKMODULE_CAMERA_BT656_CHANNEL_1 | \
+							 RKMODULE_CAMERA_BT656_CHANNEL_2 | \
+							 RKMODULE_CAMERA_BT656_CHANNEL_3)
+
+#define RKMODULE_GET_MODULE_INFO	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct rkmodule_inf)
+
+#define RKMODULE_AWB_CFG	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 1, struct rkmodule_awb_cfg)
+
+#define RKMODULE_AF_CFG	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 2, struct rkmodule_af_cfg)
+
+#define RKMODULE_LSC_CFG	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 3, struct rkmodule_lsc_cfg)
+
+#define RKMODULE_GET_HDR_CFG	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 4, struct rkmodule_hdr_cfg)
+
+#define RKMODULE_SET_HDR_CFG	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 5, struct rkmodule_hdr_cfg)
+
+#define RKMODULE_SET_CONVERSION_GAIN	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 6, __u32)
+
+#define RKMODULE_GET_LVDS_CFG	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 7, struct rkmodule_lvds_cfg)
+
+#define RKMODULE_SET_DPCC_CFG	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 8, struct rkmodule_dpcc_cfg)
+
+#define RKMODULE_GET_NR_SWITCH_THRESHOLD	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 9, struct rkmodule_nr_switch_threshold)
+
+#define RKMODULE_SET_QUICK_STREAM	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 10, __u32)
+
+#define RKMODULE_GET_BT656_INTF_TYPE	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 11, __u32)
+
+#define RKMODULE_GET_VC_FMT_INFO \
+    _IOR('V', BASE_VIDIOC_PRIVATE + 12, struct rkmodule_vc_fmt_info)
+
+#define RKMODULE_GET_VC_HOTPLUG_INFO \
+    _IOR('V', BASE_VIDIOC_PRIVATE + 13, struct rkmodule_vc_hotplug_info)
+
+#define RKMODULE_GET_START_STREAM_SEQ	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 14, __u32)
+
+#define RKMODULE_GET_VICAP_RST_INFO	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 15, struct rkmodule_vicap_reset_info)
+
+#define RKMODULE_SET_VICAP_RST_INFO	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 16, struct rkmodule_vicap_reset_info)
+
+#define RKMODULE_GET_BT656_MBUS_INFO	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 17, struct rkmodule_bt656_mbus_info)
+
+#define RKMODULE_GET_DCG_RATIO	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 18, struct rkmodule_dcg_ratio)
+
+#define RKMODULE_GET_SONY_BRL	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 19, __u32)
+
+#define RKMODULE_GET_CHANNEL_INFO	\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 20, struct rkmodule_channel_info)
+
+#define RKMODULE_GET_SYNC_MODE       \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 21, __u32)
+
+#define RKMODULE_SET_SYNC_MODE       \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 22, __u32)
+
+/**
+ * struct rkmodule_base_inf - module base information
+ *
+ */
+struct rkmodule_base_inf {
+	char sensor[RKMODULE_NAME_LEN];
+	char module[RKMODULE_NAME_LEN];
+	char lens[RKMODULE_NAME_LEN];
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_fac_inf - module factory information
+ *
+ */
+struct rkmodule_fac_inf {
+	__u32 flag;
+
+	char module[RKMODULE_NAME_LEN];
+	char lens[RKMODULE_NAME_LEN];
+	__u32 year;
+	__u32 month;
+	__u32 day;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_awb_inf - module awb information
+ *
+ */
+struct rkmodule_awb_inf {
+	__u32 flag;
+
+	__u32 r_value;
+	__u32 b_value;
+	__u32 gr_value;
+	__u32 gb_value;
+
+	__u32 golden_r_value;
+	__u32 golden_b_value;
+	__u32 golden_gr_value;
+	__u32 golden_gb_value;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_lsc_inf - module lsc information
+ *
+ */
+struct rkmodule_lsc_inf {
+	__u32 flag;
+
+	__u16 lsc_w;
+	__u16 lsc_h;
+	__u16 decimal_bits;
+
+	__u16 lsc_r[RKMODULE_LSCDATA_LEN];
+	__u16 lsc_b[RKMODULE_LSCDATA_LEN];
+	__u16 lsc_gr[RKMODULE_LSCDATA_LEN];
+	__u16 lsc_gb[RKMODULE_LSCDATA_LEN];
+
+	__u16 width;
+	__u16 height;
+	__u16 table_size;
+} __attribute__ ((packed));
+
+/**
+ * enum rkmodule_af_dir - enum of module af otp direction
+ */
+enum rkmodele_af_otp_dir {
+	AF_OTP_DIR_HORIZONTAL = 0,
+	AF_OTP_DIR_UP = 1,
+	AF_OTP_DIR_DOWN = 2,
+};
+
+/**
+ * struct rkmodule_af_otp - module af otp in one direction
+ */
+struct rkmodule_af_otp {
+	__u32 vcm_start;
+	__u32 vcm_end;
+	__u32 vcm_dir;
+};
+
+/**
+ * struct rkmodule_af_inf - module af information
+ *
+ */
+struct rkmodule_af_inf {
+	__u32 flag;
+	__u32 dir_cnt;
+	struct rkmodule_af_otp af_otp[RKMODULE_AF_OTP_MAX_LEN];
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_pdaf_inf - module pdaf information
+ *
+ */
+struct rkmodule_pdaf_inf {
+	__u32 flag;
+
+	__u32 gainmap_width;
+	__u32 gainmap_height;
+	__u32 dccmap_width;
+	__u32 dccmap_height;
+	__u32 dcc_mode;
+	__u32 dcc_dir;
+	__u16 gainmap[RKMODULE_PADF_GAINMAP_LEN];
+	__u16 dccmap[RKMODULE_PDAF_DCCMAP_LEN];
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_otp_module_inf - otp module info
+ *
+ */
+struct rkmodule_otp_module_inf {
+	__u32 flag;
+	__u8 vendor[8];
+	__u32 module_id;
+	__u16 version;
+	__u16 full_width;
+	__u16 full_height;
+	__u8 supplier_id;
+	__u8 year;
+	__u8 mouth;
+	__u8 day;
+	__u8 sensor_id;
+	__u8 lens_id;
+	__u8 vcm_id;
+	__u8 drv_id;
+	__u8 flip;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_inf - module information
+ *
+ */
+struct rkmodule_inf {
+	struct rkmodule_base_inf base;
+	struct rkmodule_fac_inf fac;
+	struct rkmodule_awb_inf awb;
+	struct rkmodule_lsc_inf lsc;
+	struct rkmodule_af_inf af;
+	struct rkmodule_pdaf_inf pdaf;
+	struct rkmodule_otp_module_inf module_inf;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_awb_inf - module awb information
+ *
+ */
+struct rkmodule_awb_cfg {
+	__u32 enable;
+	__u32 golden_r_value;
+	__u32 golden_b_value;
+	__u32 golden_gr_value;
+	__u32 golden_gb_value;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_af_cfg
+ *
+ */
+struct rkmodule_af_cfg {
+	__u32 enable;
+	__u32 vcm_start;
+	__u32 vcm_end;
+	__u32 vcm_dir;
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_lsc_cfg
+ *
+ */
+struct rkmodule_lsc_cfg {
+	__u32 enable;
+} __attribute__ ((packed));
+
+/**
+ * NO_HDR: linear mode
+ * HDR_X2: hdr two frame or line mode
+ * HDR_X3: hdr three or line mode
+ */
+enum rkmodule_hdr_mode {
+	NO_HDR = 0,
+	HDR_X2 = 5,
+	HDR_X3 = 6,
+};
+
+/**
+ * HDR_NORMAL_VC: hdr frame with diff virtual channels
+ * HDR_LINE_CNT: hdr frame with line counter
+ * HDR_ID_CODE: hdr frame with identification code
+ */
+enum hdr_esp_mode {
+	HDR_NORMAL_VC = 0,
+	HDR_LINE_CNT,
+	HDR_ID_CODE,
+};
+
+/**
+ * lcnt: line counter
+ *     padnum: the pixels of padding row
+ *     padpix: the payload of padding
+ * idcd: identification code
+ *     efpix: identification code of Effective line
+ *     obpix: identification code of OB line
+ */
+struct rkmodule_hdr_esp {
+	enum hdr_esp_mode mode;
+	union {
+		struct {
+			__u32 padnum;
+			__u32 padpix;
+		} lcnt;
+		struct {
+			__u32 efpix;
+			__u32 obpix;
+		} idcd;
+	} val;
+};
+
+struct rkmodule_hdr_cfg {
+	__u32 hdr_mode;
+	struct rkmodule_hdr_esp esp;
+} __attribute__ ((packed));
+
+/* sensor lvds sync code
+ * sav: start of active video codes
+ * eav: end of active video codes
+ */
+struct rkmodule_sync_code {
+	__u16 sav;
+	__u16 eav;
+};
+
+/* sensor lvds difference sync code mode
+ * LS_FIRST: valid line ls-le or sav-eav
+ *	   invalid line fs-fe or sav-eav
+ * FS_FIRST: valid line fs-le
+ *	   invalid line ls-fe
+ * ls: line start
+ * le: line end
+ * fs: frame start
+ * fe: frame end
+ * SONY_DOL_HDR_1: sony dol hdr pattern 1
+ * SONY_DOL_HDR_2: sony dol hdr pattern 2
+ */
+enum rkmodule_lvds_mode {
+	LS_FIRST = 0,
+	FS_FIRST,
+	SONY_DOL_HDR_1,
+	SONY_DOL_HDR_2
+};
+
+/* sync code of different frame type (hdr or linear) for lvds
+ * act: valid line sync code
+ * blk: invalid line sync code
+ */
+struct rkmodule_lvds_frm_sync_code {
+	struct rkmodule_sync_code act;
+	struct rkmodule_sync_code blk;
+};
+
+/* sync code for lvds of sensor
+ * odd_sync_code: sync code of odd frame id for lvds of sony sensor
+ * even_sync_code: sync code of even frame id for lvds of sony sensor
+ */
+struct rkmodule_lvds_frame_sync_code {
+	struct rkmodule_lvds_frm_sync_code odd_sync_code;
+	struct rkmodule_lvds_frm_sync_code even_sync_code;
+};
+
+/* lvds sync code category of sensor for different operation */
+enum rkmodule_lvds_sync_code_group {
+	LVDS_CODE_GRP_LINEAR = 0x0,
+	LVDS_CODE_GRP_LONG,
+	LVDS_CODE_GRP_MEDIUM,
+	LVDS_CODE_GRP_SHORT,
+	LVDS_CODE_GRP_MAX
+};
+
+/* struct rkmodule_lvds_cfg
+ * frm_sync_code[index]:
+ *  index == LVDS_CODE_GRP_LONG:
+ *    sync code for frame of linear mode or for long frame of hdr mode
+ *  index == LVDS_CODE_GRP_MEDIUM:
+ *    sync code for medium long frame of hdr mode
+ *  index == LVDS_CODE_GRP_SHOR:
+ *    sync code for short long frame of hdr mode
+ */
+struct rkmodule_lvds_cfg {
+	enum rkmodule_lvds_mode mode;
+	struct rkmodule_lvds_frame_sync_code frm_sync_code[LVDS_CODE_GRP_MAX];
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_dpcc_cfg
+ * enable: 0 -> disable dpcc, 1 -> enable multiple,
+ *         2 -> enable single, 3 -> enable all;
+ * cur_single_dpcc: the strength of single dpcc;
+ * cur_multiple_dpcc: the strength of multiple dpcc;
+ * total_dpcc: the max strength;
+ */
+struct rkmodule_dpcc_cfg {
+	__u32 enable;
+	__u32 cur_single_dpcc;
+	__u32 cur_multiple_dpcc;
+	__u32 total_dpcc;
+} __attribute__ ((packed));
+
+/**
+ * nr switch by gain
+ * direct: 0 -> up_thres LSNR to HSNR, 1 -> up_thres HSNR to LSNR
+ * up_thres: threshold of nr change from low gain to high gain
+ * down_thres: threshold of nr change from high gain to low gain;
+ * div_coeff: Coefficients converted from float to int
+ */
+struct rkmodule_nr_switch_threshold {
+	__u32 direct;
+	__u32 up_thres;
+	__u32 down_thres;
+	__u32 div_coeff;
+} __attribute__ ((packed));
+
+/**
+ * enum rkmodule_bt656_intf_type
+ * to support sony bt656 raw
+ */
+enum rkmodule_bt656_intf_type {
+	BT656_STD_RAW = 0,
+	BT656_SONY_RAW,
+};
+
+/**
+ * struct rkmodule_vc_fmt_info - virtual channels fmt info
+ *
+ */
+struct rkmodule_vc_fmt_info {
+	__u32 width[RKMODULE_MAX_VC_CH];
+	__u32 height[RKMODULE_MAX_VC_CH];
+	__u32 fps[RKMODULE_MAX_VC_CH];
+} __attribute__ ((packed));
+
+/**
+ * struct rkmodule_vc_hotplug_info - virtual channels hotplug status info
+ * detect_status: hotplug status
+ *     bit 0~3 means channels id, value : 0 -> plug out, 1 -> plug in.
+ */
+struct rkmodule_vc_hotplug_info {
+	__u8 detect_status;
+} __attribute__ ((packed));
+
+
+/* sensor start stream sequence
+ * RKMODULE_START_STREAM_DEFAULT: by default
+ * RKMODULE_START_STREAM_BEHIND : sensor start stream should be behind the controller
+ * RKMODULE_START_STREAM_FRONT  : sensor start stream should be in front of the controller
+ */
+enum rkmodule_start_stream_seq {
+	RKMODULE_START_STREAM_DEFAULT = 0,
+	RKMODULE_START_STREAM_BEHIND,
+	RKMODULE_START_STREAM_FRONT,
+};
+
+/*
+ * the causation to do cif reset work
+ */
+enum rkmodule_reset_src {
+	RKCIF_RESET_SRC_NON = 0x0,
+	RKCIF_RESET_SRC_ERR_CSI2,
+	RKCIF_RESET_SRC_ERR_LVDS,
+	RKICF_RESET_SRC_ERR_CUTOFF,
+	RKCIF_RESET_SRC_ERR_HOTPLUG,
+	RKCIF_RESET_SRC_ERR_APP,
+};
+
+struct rkmodule_vicap_reset_info {
+	__u32 is_reset;
+	enum rkmodule_reset_src src;
+} __attribute__ ((packed));
+
+struct rkmodule_bt656_mbus_info {
+	__u32 flags;
+	__u32 id_en_bits;
+} __attribute__ ((packed));
+
+/* DCG ratio (float) = integer + decimal / div_coeff */
+struct rkmodule_dcg_ratio {
+	__u32 integer;
+	__u32 decimal;
+	__u32 div_coeff;
+};
+
+struct rkmodule_channel_info {
+	__u32 index;
+	__u32 vc;
+	__u32 width;
+	__u32 height;
+	__u32 bus_fmt;
+	__u32 data_type;
+	__u32 data_bit;
+} __attribute__ ((packed));
+
+/*
+ * link to vicap
+ * linear mode: pad0~pad3 for id0~id3;
+ *
+ * HDR_X2: id0 fiexd to vc0 for long frame
+ *         id1 fixed to vc1 for short frame;
+ *         id2~id3 reserved, can config by PAD2~PAD3
+ *
+ * HDR_X3: id0 fiexd to vc0 for long frame
+ *         id1 fixed to vc1 for middle frame
+ *         id2 fixed to vc2 for short frame;
+ *         id3 reserved, can config by PAD3
+ *
+ * link to isp, the connection relationship is as follows
+ */
+enum rkmodule_max_pad {
+	PAD0, /* link to isp */
+	PAD1, /* link to csi wr0 | hdr x2:L x3:M */
+	PAD2, /* link to csi wr1 | hdr      x3:L */
+	PAD3, /* link to csi wr2 | hdr x2:M x3:S */
+	PAD_MAX,
+};
+
+/*
+ * sensor exposure sync mode
+ */
+enum rkmodule_sync_mode {
+	NO_SYNC_MODE = 0,
+	EXTERNAL_MASTER_MODE,
+	INTERNAL_MASTER_MODE,
+	SLAVE_MODE,
+};
+#endif /* _UAPI_RKMODULE_CAMERA_H */
diff --git a/include/uapi/linux/rk-led-flash.h b/include/uapi/linux/rk-led-flash.h
new file mode 100644
index 000000000..916f6351f
--- /dev/null
+++ b/include/uapi/linux/rk-led-flash.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/* Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd. */
+#ifndef RK_LED_FLASH_H
+#define RK_LED_FLASH_H
+
+#define RK_VIDIOC_FLASH_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct timeval)
+
+#endif
diff --git a/include/uapi/linux/rk-pcie-dma.h b/include/uapi/linux/rk-pcie-dma.h
new file mode 100644
index 000000000..a35201d06
--- /dev/null
+++ b/include/uapi/linux/rk-pcie-dma.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright (C) 2018 Rockchip Electronics Co., Ltd.
+ */
+#ifndef _UAPI__PCIE_DMA_TRX_H__
+#define _UAPI__PCIE_DMA_TRX_H__
+
+enum transfer_type {
+	PCIE_DMA_DATA_SND,
+	PCIE_DMA_DATA_RCV_ACK,
+	PCIE_DMA_DATA_FREE_ACK,
+	PCIE_DMA_READ_REMOTE,
+};
+
+union pcie_dma_ioctl_param {
+	struct {
+		u32	idx;
+		u32	l_widx;
+		u32	r_widx;
+		u32	size;
+		u32	type;
+		u32	chn;
+	} in;
+	struct {
+		u32	lwa;
+		u32	rwa;
+	} out;
+	u32		lra;
+	u32		count;
+	u32             total_buffer_size;
+	phys_addr_t	local_addr;
+	u32		buffer_size;
+};
+
+#define PCIE_BASE	'P'
+#define PCIE_DMA_START					\
+	_IOW(PCIE_BASE, 0, union pcie_dma_ioctl_param)
+#define PCIE_DMA_GET_LOCAL_READ_BUFFER_INDEX		\
+	_IOR(PCIE_BASE, 1, union pcie_dma_ioctl_param)
+#define PCIE_DMA_GET_LOCAL_REMOTE_WRITE_BUFFER_INDEX	\
+	_IOR(PCIE_BASE, 2, union pcie_dma_ioctl_param)
+#define PCIE_DMA_SET_LOCAL_READ_BUFFER_INDEX		\
+	_IOW(PCIE_BASE, 3, union pcie_dma_ioctl_param)
+#define PCIE_DMA_SYNC_BUFFER_FOR_CPU			\
+	_IOW(PCIE_BASE, 4, union pcie_dma_ioctl_param)
+#define PCIE_DMA_SYNC_BUFFER_TO_DEVICE			\
+	_IOW(PCIE_BASE, 5, union pcie_dma_ioctl_param)
+#define PCIE_DMA_WAIT_TRANSFER_COMPLETE			\
+	_IO(PCIE_BASE, 6)
+#define PCIE_DMA_SET_LOOP_COUNT				\
+	_IOW(PCIE_BASE, 7, union pcie_dma_ioctl_param)
+#define PCIE_DMA_GET_TOTAL_BUFFER_SIZE			\
+	_IOW(PCIE_BASE, 8, union pcie_dma_ioctl_param)
+#define PCIE_DMA_SET_BUFFER_SIZE			\
+	_IOW(PCIE_BASE, 9, union pcie_dma_ioctl_param)
+#define PCIE_DMA_READ_FROM_REMOTE			\
+	_IOW(PCIE_BASE, 0xa, union pcie_dma_ioctl_param)
+#define PCIE_DMA_USER_SET_BUF_ADDR			\
+	_IOW(PCIE_BASE, 0xb, union pcie_dma_ioctl_param)
+
+#endif
diff --git a/include/uapi/linux/rk-preisp.h b/include/uapi/linux/rk-preisp.h
new file mode 100644
index 000000000..3695a3880
--- /dev/null
+++ b/include/uapi/linux/rk-preisp.h
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+/*
+ * Rockchip preisp driver
+ * Copyright (C) 2018 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKPREISP_H
+#define _UAPI_RKPREISP_H
+
+#include <linux/types.h>
+
+#define PREISP_FW_NAME_LEN		128
+
+#define PREISP_LSCTBL_SIZE		289
+
+#define PREISP_CMD_SET_HDRAE_EXP	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 0, struct preisp_hdrae_exp_s)
+
+#define PREISP_CMD_SAVE_HDRAE_PARAM	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 1, struct preisp_hdrae_para_s)
+
+#define PREISP_DISP_SET_FRAME_OUTPUT    \
+	 _IOW('V', BASE_VIDIOC_PRIVATE + 4, int)
+
+#define PREISP_DISP_SET_FRAME_FORMAT    \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 5, unsigned int)
+
+#define PREISP_DISP_SET_FRAME_TYPE      \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 6, unsigned int)
+
+#define PREISP_DISP_SET_PRO_TIME        \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 7, unsigned int)
+
+#define PREISP_DISP_SET_PRO_CURRENT     \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 8, unsigned int)
+
+#define PREISP_DISP_SET_DENOISE \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 9, unsigned int[2])
+
+#define PREISP_DISP_WRITE_EEPROM        \
+	_IO('V', BASE_VIDIOC_PRIVATE + 10)
+
+#define PREISP_DISP_READ_EEPROM \
+	_IO('V', BASE_VIDIOC_PRIVATE + 11)
+
+#define PREISP_DISP_SET_LED_ON_OFF	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 12, unsigned int)
+
+#define PREISP_POWER_ON		_IO('p',   1)
+#define PREISP_POWER_OFF	_IO('p',   2)
+#define PREISP_REQUEST_SLEEP	_IOW('p',  3, s32)
+#define PREISP_WAKEUP		_IO('p',   4)
+#define PREISP_DOWNLOAD_FW	_IOW('p',  5, char[PREISP_FW_NAME_LEN])
+#define PREISP_WRITE		_IOW('p',  6, struct preisp_apb_pkt)
+#define PREISP_READ		_IOR('p',  7, struct preisp_apb_pkt)
+#define PREISP_ST_QUERY		_IOR('p',  8, s32)
+#define PREISP_IRQ_REQUEST	_IOW('p',  9, s32)
+#define PREISP_SEND_MSG		_IOW('p', 11, s32)
+#define PREISP_QUERY_MSG	_IOR('p', 12, s32)
+#define PREISP_RECV_MSG		_IOR('p', 13, s32)
+#define PREISP_CLIENT_CONNECT	_IOW('p', 15, s32)
+#define PREISP_CLIENT_DISCONNECT _IO('p', 16)
+
+struct preisp_apb_pkt {
+	s32 data_len;
+	s32 addr;
+	s32 *data;
+};
+
+/**
+ * struct preisp_hdrae_para_s - awb and lsc para for preisp
+ *
+ * @r_gain: awb r gain
+ * @b_gain: awb b gain
+ * @gr_gain: awb gr gain
+ * @gb_gain: awb gb gain
+ * @lsc_table: lsc data of gr
+ */
+struct preisp_hdrae_para_s {
+	unsigned short r_gain;
+	unsigned short b_gain;
+	unsigned short gr_gain;
+	unsigned short gb_gain;
+	int lsc_table[PREISP_LSCTBL_SIZE];
+};
+
+/*
+ * enum cg_mode_e conversion gain
+ *
+ */
+enum cg_mode_e {
+		GAIN_MODE_LCG,
+		GAIN_MODE_HCG,
+};
+
+/**
+ * struct preisp_hdrae_exp_s - hdrae exposure
+ *
+ */
+struct preisp_hdrae_exp_s {
+	unsigned int long_exp_reg;
+	unsigned int long_gain_reg;
+	unsigned int middle_exp_reg;
+	unsigned int middle_gain_reg;
+	unsigned int short_exp_reg;
+	unsigned int short_gain_reg;
+	unsigned int long_exp_val;
+	unsigned int long_gain_val;
+	unsigned int middle_exp_val;
+	unsigned int middle_gain_val;
+	unsigned int short_exp_val;
+	unsigned int short_gain_val;
+	unsigned char long_cg_mode;
+	unsigned char middle_cg_mode;
+	unsigned char short_cg_mode;
+};
+
+#endif /* _UAPI_RKPREISP_H */
diff --git a/include/uapi/linux/rk-video-format.h b/include/uapi/linux/rk-video-format.h
new file mode 100644
index 000000000..7f60140d4
--- /dev/null
+++ b/include/uapi/linux/rk-video-format.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: (GPL-2.0+ WITH Linux-syscall-note) OR MIT
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd.
+ */
+#ifndef _UAPI_RK_VIDEO_FORMAT_H
+#define _UAPI_RK_VIDEO_FORMAT_H
+
+/*  Four-character-code (FOURCC) */
+#define v4l2_fourcc(a, b, c, d)\
+	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
+#define v4l2_fourcc_be(a, b, c, d)	(v4l2_fourcc(a, b, c, d) | (1U << 31))
+
+/* Rockchip yuv422sp frame buffer compression encoder */
+#define V4L2_PIX_FMT_FBC2     v4l2_fourcc('F', 'B', 'C', '2')
+/* Rockchip yuv420sp frame buffer compression encoder */
+#define V4L2_PIX_FMT_FBC0     v4l2_fourcc('F', 'B', 'C', '0')
+#define V4L2_PIX_FMT_FBCG     v4l2_fourcc('F', 'B', 'C', 'G')
+/* embedded data 8-bit */
+#define V4l2_PIX_FMT_EBD8     v4l2_fourcc('E', 'B', 'D', '8')
+/* shield pix data 16-bit */
+#define V4l2_PIX_FMT_SPD16    v4l2_fourcc('S', 'P', 'D', '6')
+
+/* Vendor specific - used for Rockchip ISP1 camera sub-system */
+#define V4L2_META_FMT_RK_ISP1_PARAMS	v4l2_fourcc('R', 'K', '1', 'P') /* Rockchip ISP1 params */
+#define V4L2_META_FMT_RK_ISP1_STAT_3A	v4l2_fourcc('R', 'K', '1', 'S') /* Rockchip ISP1 3A statistics */
+#define V4L2_META_FMT_RK_ISP1_STAT_LUMA	v4l2_fourcc('R', 'K', '1', 'L') /* Rockchip ISP1 luma statistics */
+#define V4L2_META_FMT_RK_ISPP_PARAMS	v4l2_fourcc('R', 'K', 'P', 'P') /* Rockchip ISPP params */
+#define V4L2_META_FMT_RK_ISPP_STAT	v4l2_fourcc('R', 'K', 'P', 'S') /* Rockchip ISPP statistics */
+
+/* sensor embedded data format */
+#define MEDIA_BUS_FMT_EBD_1X8		0x5002
+/* sensor shield pix data format */
+#define MEDIA_BUS_FMT_SPD_2X8		0x5003
+
+#endif /* _UAPI_RK_VIDEO_FORMAT_H */
diff --git a/include/uapi/linux/rk803.h b/include/uapi/linux/rk803.h
new file mode 100644
index 000000000..448468da9
--- /dev/null
+++ b/include/uapi/linux/rk803.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+/*
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RK803_H
+#define _UAPI_RK803_H
+
+#include <linux/types.h>
+
+#define RK803_SET_GPIO1		_IOW('p',  1, int)
+#define RK803_SET_GPIO2		_IOW('p',  2, int)
+#define RK803_SET_CURENT1	_IOW('p',  3, int)
+#define RK803_SET_CURENT2	_IOW('p',  4, int)
+
+#endif /* _UAPI_RK803_H */
diff --git a/include/uapi/linux/rk_vcm_head.h b/include/uapi/linux/rk_vcm_head.h
new file mode 100644
index 000000000..466867bc7
--- /dev/null
+++ b/include/uapi/linux/rk_vcm_head.h
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/* Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd. */
+
+#ifndef RK_VCM_HEAD_H
+#define RK_VCM_HEAD_H
+
+#define RK_VCM_HEAD_VERSION	KERNEL_VERSION(0, 0x02, 0x0)
+/*
+ * Focus position values:
+ * 65 logical positions ( 0 - 64 )
+ * where 64 is the setting for infinity and 0 for macro
+ */
+#define VCMDRV_MAX_LOG			64U
+#define VCMDRV_SETZOOM_MAXCNT	300U
+
+#define OF_CAMERA_VCMDRV_MAX_CURRENT	"rockchip,vcm-max-current"
+#define OF_CAMERA_VCMDRV_START_CURRENT	"rockchip,vcm-start-current"
+#define OF_CAMERA_VCMDRV_RATED_CURRENT	"rockchip,vcm-rated-current"
+#define OF_CAMERA_VCMDRV_STEP_MODE	"rockchip,vcm-step-mode"
+#define OF_CAMERA_VCMDRV_DLC_ENABLE	"rockchip,vcm-dlc-enable"
+#define OF_CAMERA_VCMDRV_MCLK		"rockchip,vcm-mclk"
+#define OF_CAMERA_VCMDRV_T_SRC		"rockchip,vcm-t-src"
+#define OF_CAMERA_VCMDRV_T_DIV          "rockchip,vcm-t-div"
+#define VCMDRV_SETZOOM_MAXCNT	300U
+
+#define RK_VIDIOC_VCM_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct rk_cam_vcm_tim)
+#define RK_VIDIOC_IRIS_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 1, struct rk_cam_vcm_tim)
+#define RK_VIDIOC_ZOOM_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 2, struct rk_cam_vcm_tim)
+
+#define RK_VIDIOC_GET_VCM_CFG \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 3, struct rk_cam_vcm_cfg)
+#define RK_VIDIOC_SET_VCM_CFG \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 4, struct rk_cam_vcm_cfg)
+
+#define RK_VIDIOC_FOCUS_CORRECTION \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 5, unsigned int)
+#define RK_VIDIOC_IRIS_CORRECTION \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 6, unsigned int)
+#define RK_VIDIOC_ZOOM_CORRECTION \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 7, unsigned int)
+
+#define RK_VIDIOC_FOCUS_SET_BACKLASH \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 8, unsigned int)
+#define RK_VIDIOC_IRIS_SET_BACKLASH \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 9, unsigned int)
+#define RK_VIDIOC_ZOOM_SET_BACKLASH \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 10, unsigned int)
+
+#define RK_VIDIOC_ZOOM1_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 11, struct rk_cam_vcm_tim)
+#define RK_VIDIOC_ZOOM1_CORRECTION \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 12, unsigned int)
+#define RK_VIDIOC_ZOOM1_SET_BACKLASH \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 13, unsigned int)
+
+#define RK_VIDIOC_ZOOM_SET_POSITION \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 14, struct rk_cam_set_zoom)
+#define RK_VIDIOC_FOCUS_SET_POSITION \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 15, struct rk_cam_set_focus)
+#define RK_VIDIOC_MODIFY_POSITION \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 16, struct rk_cam_modify_pos)
+
+#define RK_VIDIOC_COMPAT_VCM_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct rk_cam_compat_vcm_tim)
+#define RK_VIDIOC_COMPAT_IRIS_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 1, struct rk_cam_compat_vcm_tim)
+#define RK_VIDIOC_COMPAT_ZOOM_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 2, struct rk_cam_compat_vcm_tim)
+#define RK_VIDIOC_COMPAT_ZOOM1_TIMEINFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 11, struct rk_cam_compat_vcm_tim)
+
+struct rk_cam_modify_pos {
+	s32 focus_pos;
+	s32 zoom_pos;
+	s32 zoom1_pos;
+};
+
+struct rk_cam_set_focus {
+	bool is_need_reback;
+	s32 focus_pos;
+};
+
+struct rk_cam_zoom_pos {
+	s32 zoom_pos;
+	s32 focus_pos;
+};
+
+struct rk_cam_set_zoom {
+	bool is_need_zoom_reback;
+	bool is_need_focus_reback;
+	u32 setzoom_cnt;
+	struct rk_cam_zoom_pos zoom_pos[VCMDRV_SETZOOM_MAXCNT];
+};
+
+struct rk_cam_vcm_tim {
+	struct __kernel_old_timeval vcm_start_t;
+	struct __kernel_old_timeval vcm_end_t;
+};
+
+struct rk_cam_compat_vcm_tim {
+	struct old_timeval32 vcm_start_t;
+	struct old_timeval32 vcm_end_t;
+};
+
+struct rk_cam_vcm_cfg {
+	int start_ma;
+	int rated_ma;
+	int step_mode;
+};
+
+#endif /* RK_VCM_HEAD_H */
diff --git a/include/uapi/linux/rkcif-config.h b/include/uapi/linux/rkcif-config.h
new file mode 100644
index 000000000..1d57aa3a6
--- /dev/null
+++ b/include/uapi/linux/rkcif-config.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT)
+ *
+ * Copyright (C) 2019 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKCIF_CONFIG_H
+#define _UAPI_RKCIF_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+
+#define RKCIF_API_VERSION		KERNEL_VERSION(0, 1, 0xa)
+
+#define RKCIF_CMD_GET_CSI_MEMORY_MODE \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, int)
+
+#define RKCIF_CMD_SET_CSI_MEMORY_MODE \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 1, int)
+
+#define RKCIF_CMD_GET_SCALE_BLC \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 2, struct bayer_blc)
+
+#define RKCIF_CMD_SET_SCALE_BLC \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 3, struct bayer_blc)
+
+/* cif memory mode
+ * 0: raw12/raw10/raw8 8bit memory compact
+ * 1: raw12/raw10 16bit memory one pixel
+ *    low align for rv1126/rv1109/rk356x
+ *    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *    | -| -| -| -|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ * 2: raw12/raw10 16bit memory one pixel
+ *    high align for rv1126/rv1109/rk356x
+ *    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *    |11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0| -| -| -| -|
+ *
+ * note: rv1109/rv1126/rk356x dvp only support uncompact mode,
+ *       and can be set low align or high align
+ */
+
+enum cif_csi_lvds_memory {
+	CSI_LVDS_MEM_COMPACT = 0,
+	CSI_LVDS_MEM_WORD_LOW_ALIGN = 1,
+	CSI_LVDS_MEM_WORD_HIGH_ALIGN = 2,
+};
+
+/* black level for scale image
+ * The sequence of pattern00~03 is the same as the output of sensor bayer
+ */
+
+struct bayer_blc {
+	u8 pattern00;
+	u8 pattern01;
+	u8 pattern02;
+	u8 pattern03;
+};
+#endif
diff --git a/include/uapi/linux/rkisp1-config.h b/include/uapi/linux/rkisp1-config.h
new file mode 100644
index 000000000..c26d4bb69
--- /dev/null
+++ b/include/uapi/linux/rkisp1-config.h
@@ -0,0 +1,872 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+/*
+ * Rockchip isp1 driver
+ * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKISP1_CONFIG_H
+#define _UAPI_RKISP1_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+#include "rkisp21-config.h"
+
+#define CIFISP_MODULE_DPCC			(1 << 0)
+#define CIFISP_MODULE_BLS			(1 << 1)
+#define CIFISP_MODULE_SDG			(1 << 2)
+#define CIFISP_MODULE_HST			(1 << 3)
+#define CIFISP_MODULE_LSC			(1 << 4)
+#define CIFISP_MODULE_AWB_GAIN			(1 << 5)
+#define CIFISP_MODULE_FLT			(1 << 6)
+#define CIFISP_MODULE_BDM			(1 << 7)
+#define CIFISP_MODULE_CTK			(1 << 8)
+#define CIFISP_MODULE_GOC			(1 << 9)
+#define CIFISP_MODULE_CPROC			(1 << 10)
+#define CIFISP_MODULE_AFC			(1 << 11)
+#define CIFISP_MODULE_AWB			(1 << 12)
+#define CIFISP_MODULE_IE			(1 << 13)
+#define CIFISP_MODULE_AEC			(1 << 14)
+#define CIFISP_MODULE_WDR			(1 << 15)
+#define CIFISP_MODULE_DPF			(1 << 16)
+#define CIFISP_MODULE_DPF_STRENGTH		(1 << 17)
+#define CIFISP_MODULE_DEMOSAICLP		(1 << 18)
+#define CIFISP_MODULE_RK_IESHARP		(1 << 19)
+
+#define CIFISP_CTK_COEFF_MAX			0x100
+#define CIFISP_CTK_OFFSET_MAX			0x800
+
+#define CIFISP_AE_MEAN_MAX			81
+#define CIFISP_HIST_BIN_N_MAX			32
+#define CIFISP_AFM_MAX_WINDOWS			3
+#define CIFISP_DEGAMMA_CURVE_SIZE		17
+
+#define CIFISP_BDM_MAX_TH			0xFF
+
+/*
+ * Black level compensation
+ */
+/* maximum value for horizontal start address */
+#define CIFISP_BLS_START_H_MAX			0x00000FFF
+/* maximum value for horizontal stop address */
+#define CIFISP_BLS_STOP_H_MAX			0x00000FFF
+/* maximum value for vertical start address */
+#define CIFISP_BLS_START_V_MAX			0x00000FFF
+/* maximum value for vertical stop address */
+#define CIFISP_BLS_STOP_V_MAX			0x00000FFF
+/* maximum is 2^18 = 262144*/
+#define CIFISP_BLS_SAMPLES_MAX			0x00000012
+/* maximum value for fixed black level */
+#define CIFISP_BLS_FIX_SUB_MAX			0x00000FFF
+/* minimum value for fixed black level */
+#define CIFISP_BLS_FIX_SUB_MIN			0xFFFFF000
+/* 13 bit range (signed)*/
+#define CIFISP_BLS_FIX_MASK			0x00001FFF
+
+/*
+ * Automatic white balance measurments
+ */
+#define CIFISP_AWB_MAX_GRID			1
+#define CIFISP_AWB_MAX_FRAMES			7
+
+/*
+ * Gamma out
+ */
+/* Maximum number of color samples supported */
+#define CIFISP_GAMMA_OUT_MAX_SAMPLES		34
+
+/*
+ * Lens shade correction
+ */
+#define CIFISP_LSC_GRAD_TBL_SIZE		8
+#define CIFISP_LSC_SIZE_TBL_SIZE		8
+/*
+ * The following matches the tuning process,
+ * not the max capabilities of the chip.
+ * Last value unused.
+ */
+#define	CIFISP_LSC_DATA_TBL_SIZE		290
+
+/*
+ * Histogram calculation
+ */
+/* Last 3 values unused. */
+#define CIFISP_HISTOGRAM_WEIGHT_GRIDS_SIZE	81
+
+/*
+ * Defect Pixel Cluster Correction
+ */
+#define CIFISP_DPCC_METHODS_MAX			3
+
+/*
+ * Denoising pre filter
+ */
+#define CIFISP_DPF_MAX_NLF_COEFFS		17
+#define CIFISP_DPF_MAX_SPATIAL_COEFFS		6
+
+/* WDR */
+#define CIFISP_WDR_SIZE				48
+
+/*
+ * Measurement types
+ */
+#define CIFISP_STAT_AWB				(1 << 0)
+#define CIFISP_STAT_AUTOEXP			(1 << 1)
+#define CIFISP_STAT_AFM_FIN			(1 << 2)
+#define CIFISP_STAT_HIST			(1 << 3)
+#define CIFISP_STAT_EMB_DATA			(1 << 4)
+
+/* ADD DATA */
+#define CIFISP_ADD_DATA_FIFO_SIZE		(2048 * 4)
+
+/* Private v4l2 event */
+#define CIFISP_V4L2_EVENT_STREAM_START	\
+				(V4L2_EVENT_PRIVATE_START + 1)
+#define CIFISP_V4L2_EVENT_STREAM_STOP	\
+				(V4L2_EVENT_PRIVATE_START + 2)
+
+/*
+ * private control id
+ */
+enum cifisp_ctrl_id {
+	CIFISP_CID_EMB_VC = (V4L2_CTRL_CLASS_CAMERA | 0x1001),
+	CIFISP_CID_EMB_DT,
+	CIFISP_CID_LAST
+};
+
+enum cifisp_histogram_mode {
+	CIFISP_HISTOGRAM_MODE_DISABLE,
+	CIFISP_HISTOGRAM_MODE_RGB_COMBINED,
+	CIFISP_HISTOGRAM_MODE_R_HISTOGRAM,
+	CIFISP_HISTOGRAM_MODE_G_HISTOGRAM,
+	CIFISP_HISTOGRAM_MODE_B_HISTOGRAM,
+	CIFISP_HISTOGRAM_MODE_Y_HISTOGRAM
+};
+
+enum cifisp_awb_mode_type {
+	CIFISP_AWB_MODE_MANUAL,
+	CIFISP_AWB_MODE_RGB,
+	CIFISP_AWB_MODE_YCBCR
+};
+
+enum cifisp_flt_mode {
+	CIFISP_FLT_STATIC_MODE,
+	CIFISP_FLT_DYNAMIC_MODE
+};
+
+/**
+ * enum cifisp_exp_ctrl_auotostop - stop modes
+ * @CIFISP_EXP_CTRL_AUTOSTOP_0: continuous measurement
+ * @CIFISP_EXP_CTRL_AUTOSTOP_1: stop measuring after a complete frame
+ */
+enum cifisp_exp_ctrl_auotostop {
+	CIFISP_EXP_CTRL_AUTOSTOP_0 = 0,
+	CIFISP_EXP_CTRL_AUTOSTOP_1 = 1,
+};
+
+/**
+ * enum cifisp_exp_meas_mode - Exposure measure mode
+ * @CIFISP_EXP_MEASURING_MODE_0: Y = 16 + 0.25R + 0.5G + 0.1094B
+ * @CIFISP_EXP_MEASURING_MODE_1: Y = (R + G + B) x (85/256)
+ */
+enum cifisp_exp_meas_mode {
+	CIFISP_EXP_MEASURING_MODE_0,
+	CIFISP_EXP_MEASURING_MODE_1,
+};
+
+/*---------- PART1: Input Parameters ------------*/
+
+struct cifisp_window {
+	unsigned short h_offs;
+	unsigned short v_offs;
+	unsigned short h_size;
+	unsigned short v_size;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_bls_fixed_val - BLS fixed subtraction values
+ *
+ * The values will be subtracted from the sensor
+ * values. Therefore a negative value means addition instead of subtraction!
+ *
+ * @r: Fixed (signed!) subtraction value for Bayer pattern R
+ * @gr: Fixed (signed!) subtraction value for Bayer pattern Gr
+ * @gb: Fixed (signed!) subtraction value for Bayer pattern Gb
+ * @b: Fixed (signed!) subtraction value for Bayer pattern B
+ */
+struct cifisp_bls_fixed_val {
+	signed short r;
+	signed short gr;
+	signed short gb;
+	signed short b;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_bls_config - Configuration used by black level subtraction
+ *
+ * @enable_auto: Automatic mode activated means that the measured values
+ * are subtracted.Otherwise the fixed subtraction
+ * values will be subtracted.
+ * @en_windows: enabled window
+ * @bls_window1: Measurement window 1 size
+ * @bls_window2: Measurement window 2 size
+ * @bls_samples: Set amount of measured pixels for each Bayer position
+ * (A, B,C and D) to 2^bls_samples.
+ * @cifisp_bls_fixed_val: Fixed subtraction values
+ */
+struct cifisp_bls_config {
+	unsigned char enable_auto;
+	unsigned char en_windows;
+	struct cifisp_window bls_window1;
+	struct cifisp_window bls_window2;
+	unsigned char bls_samples;
+	struct cifisp_bls_fixed_val fixed_val;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_dpcc_methods_config - Methods Configuration used by Defect Pixel Cluster Correction
+ *
+ * @method:
+ * @line_thresh:
+ * @line_mad_fac:
+ * @pg_fac:
+ * @rnd_thresh:
+ * @rg_fac:
+ */
+struct cifisp_dpcc_methods_config {
+	unsigned int method;
+	unsigned int line_thresh;
+	unsigned int line_mad_fac;
+	unsigned int pg_fac;
+	unsigned int rnd_thresh;
+	unsigned int rg_fac;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_dpcc_methods_config - Configuration used by Defect Pixel Cluster Correction
+ *
+ * @mode: dpcc output mode
+ * @output_mode: whether use hard coded methods
+ * @set_use: stage1 methods set
+ * @methods: methods config
+ * @ro_limits: rank order limits
+ * @rnd_offs: differential rank offsets for rank neighbor difference
+ */
+struct cifisp_dpcc_config {
+	unsigned int mode;
+	unsigned int output_mode;
+	unsigned int set_use;
+	struct cifisp_dpcc_methods_config methods[CIFISP_DPCC_METHODS_MAX];
+	unsigned int ro_limits;
+	unsigned int rnd_offs;
+} __attribute__ ((packed));
+
+struct cifisp_gamma_corr_curve {
+	unsigned short gamma_y[CIFISP_DEGAMMA_CURVE_SIZE];
+} __attribute__ ((packed));
+
+struct cifisp_gamma_curve_x_axis_pnts {
+	unsigned int gamma_dx0;
+	unsigned int gamma_dx1;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_gamma_corr_curve - Configuration used by sensor degamma
+ *
+ * @curve_x: gamma curve point definition axis for x
+ * @xa_pnts: x increments
+ */
+struct cifisp_sdg_config {
+	struct cifisp_gamma_corr_curve curve_r;
+	struct cifisp_gamma_corr_curve curve_g;
+	struct cifisp_gamma_corr_curve curve_b;
+	struct cifisp_gamma_curve_x_axis_pnts xa_pnts;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_lsc_config - Configuration used by Lens shading correction
+ *
+ * refer to datasheet for details
+ */
+struct cifisp_lsc_config {
+	unsigned int r_data_tbl[CIFISP_LSC_DATA_TBL_SIZE];
+	unsigned int gr_data_tbl[CIFISP_LSC_DATA_TBL_SIZE];
+	unsigned int gb_data_tbl[CIFISP_LSC_DATA_TBL_SIZE];
+	unsigned int b_data_tbl[CIFISP_LSC_DATA_TBL_SIZE];
+
+	unsigned int x_grad_tbl[CIFISP_LSC_GRAD_TBL_SIZE];
+	unsigned int y_grad_tbl[CIFISP_LSC_GRAD_TBL_SIZE];
+
+	unsigned int x_size_tbl[CIFISP_LSC_SIZE_TBL_SIZE];
+	unsigned int y_size_tbl[CIFISP_LSC_SIZE_TBL_SIZE];
+	unsigned short config_width;
+	unsigned short config_height;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_ie_config - Configuration used by image effects
+ *
+ * @eff_mat_1: 3x3 Matrix Coefficients for Emboss Effect 1
+ * @eff_mat_2: 3x3 Matrix Coefficients for Emboss Effect 2
+ * @eff_mat_3: 3x3 Matrix Coefficients for Emboss 3/Sketch 1
+ * @eff_mat_4: 3x3 Matrix Coefficients for Sketch Effect 2
+ * @eff_mat_5: 3x3 Matrix Coefficients for Sketch Effect 3
+ * @eff_tint: Chrominance increment values of tint (used for sepia effect)
+ */
+struct cifisp_ie_config {
+	unsigned short effect;
+	unsigned short color_sel;
+	unsigned short eff_mat_1;
+	unsigned short eff_mat_2;
+	unsigned short eff_mat_3;
+	unsigned short eff_mat_4;
+	unsigned short eff_mat_5;
+	unsigned short eff_tint;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_cproc_config - Configuration used by Color Processing
+ *
+ * @c_out_range: Chrominance pixel clipping range at output. (0 for limit, 1 for full)
+ * @y_in_range: Luminance pixel clipping range at output.
+ * @y_out_range: Luminance pixel clipping range at output.
+ * @contrast: 00~ff, 0.0~1.992
+ * @brightness: 80~7F, -128~+127
+ * @sat: saturation, 00~FF, 0.0~1.992
+ * @hue: 80~7F, -90~+87.188
+ */
+struct cifisp_cproc_config {
+	unsigned char c_out_range;
+	unsigned char y_in_range;
+	unsigned char y_out_range;
+	unsigned char contrast;
+	unsigned char brightness;
+	unsigned char sat;
+	unsigned char hue;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_awb_meas_config - Configuration used by auto white balance
+ *
+ * @awb_wnd: white balance measurement window (in pixels)
+ * @max_y: only pixels values < max_y contribute to awb measurement, set to 0 to disable this feature
+ * @min_y: only pixels values > min_y contribute to awb measurement
+ * @max_csum: Chrominance sum maximum value, only consider pixels with Cb+Cr, smaller than threshold for awb measurements
+ * @min_c: Chrominance minimum value, only consider pixels with Cb/Cr each greater than threshold value for awb measurements
+ * @frames: number of frames - 1 used for mean value calculation(ucFrames=0 means 1 Frame)
+ * @awb_ref_cr: reference Cr value for AWB regulation, target for AWB
+ * @awb_ref_cb: reference Cb value for AWB regulation, target for AWB
+ */
+struct cifisp_awb_meas_config {
+	/*
+	 * Note: currently the h and v offsets are mapped to grid offsets
+	 */
+	struct cifisp_window awb_wnd;
+	enum cifisp_awb_mode_type awb_mode;
+	unsigned char max_y;
+	unsigned char min_y;
+	unsigned char max_csum;
+	unsigned char min_c;
+	unsigned char frames;
+	unsigned char awb_ref_cr;
+	unsigned char awb_ref_cb;
+	bool enable_ymax_cmp;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_awb_gain_config - Configuration used by auto white balance gain
+ *
+ * out_data_x = ( AWB_GEAIN_X * in_data + 128) >> 8
+ */
+struct cifisp_awb_gain_config {
+	unsigned short gain_red;
+	unsigned short gain_green_r;
+	unsigned short gain_blue;
+	unsigned short gain_green_b;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_flt_config - Configuration used by ISP filtering
+ *
+ * @mode: ISP_FILT_MODE register fields
+ * @grn_stage1: ISP_FILT_MODE register fields
+ * @chr_h_mode: ISP_FILT_MODE register fields
+ * @chr_v_mode: ISP_FILT_MODE register fields
+ *
+ * refer to datasheet for details.
+ */
+struct cifisp_flt_config {
+	enum cifisp_flt_mode mode;
+	unsigned char grn_stage1;
+	unsigned char chr_h_mode;
+	unsigned char chr_v_mode;
+	unsigned int thresh_bl0;
+	unsigned int thresh_bl1;
+	unsigned int thresh_sh0;
+	unsigned int thresh_sh1;
+	unsigned int lum_weight;
+	unsigned int fac_sh1;
+	unsigned int fac_sh0;
+	unsigned int fac_mid;
+	unsigned int fac_bl0;
+	unsigned int fac_bl1;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_bdm_config - Configuration used by Bayer DeMosaic
+ *
+ * @demosaic_th: threshod for bayer demosaicing texture detection
+ */
+struct cifisp_bdm_config {
+	unsigned char demosaic_th;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_ctk_config - Configuration used by Cross Talk correction
+ *
+ * @coeff: color correction matrix
+ * @ct_offset_b: offset for the crosstalk correction matrix
+ */
+struct cifisp_ctk_config {
+	unsigned short coeff0;
+	unsigned short coeff1;
+	unsigned short coeff2;
+	unsigned short coeff3;
+	unsigned short coeff4;
+	unsigned short coeff5;
+	unsigned short coeff6;
+	unsigned short coeff7;
+	unsigned short coeff8;
+	unsigned short ct_offset_r;
+	unsigned short ct_offset_g;
+	unsigned short ct_offset_b;
+} __attribute__ ((packed));
+
+enum cifisp_goc_mode {
+	CIFISP_GOC_MODE_LOGARITHMIC,
+	CIFISP_GOC_MODE_EQUIDISTANT
+};
+
+/**
+ * struct cifisp_goc_config - Configuration used by Gamma Out correction
+ *
+ * @mode: goc mode
+ * @gamma_y: gamma out curve y-axis for all color components
+ */
+struct cifisp_goc_config {
+	enum cifisp_goc_mode mode;
+	unsigned short gamma_y[CIFISP_GAMMA_OUT_MAX_SAMPLES];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_hst_config - Configuration used by Histogram
+ *
+ * @mode: histogram mode
+ * @histogram_predivider: process every stepsize pixel, all other pixels are skipped
+ * @meas_window: coordinates of the meas window
+ * @hist_weight: weighting factor for sub-windows
+ */
+struct cifisp_hst_config {
+	enum cifisp_histogram_mode mode;
+	unsigned char histogram_predivider;
+	struct cifisp_window meas_window;
+	unsigned char hist_weight[CIFISP_HISTOGRAM_WEIGHT_GRIDS_SIZE];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_aec_config - Configuration used by Auto Exposure Control
+ *
+ * @mode: Exposure measure mode
+ * @autostop: stop mode (from enum cifisp_exp_ctrl_auotostop)
+ * @meas_window: coordinates of the meas window
+ */
+struct cifisp_aec_config {
+	enum cifisp_exp_meas_mode mode;
+	__u32 autostop;
+	struct cifisp_window meas_window;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_afc_config - Configuration used by Auto Focus Control
+ *
+ * @num_afm_win: max CIFISP_AFM_MAX_WINDOWS
+ * @afm_win: coordinates of the meas window
+ * @thres: threshold used for minimizing the influence of noise
+ * @var_shift: the number of bits for the shift operation at the end of the calculation chain.
+ */
+struct cifisp_afc_config {
+	unsigned char num_afm_win;
+	struct cifisp_window afm_win[CIFISP_AFM_MAX_WINDOWS];
+	unsigned int thres;
+	unsigned int var_shift;
+} __attribute__ ((packed));
+
+/**
+ * enum cifisp_dpf_gain_usage - dpf gain usage
+ * @CIFISP_DPF_GAIN_USAGE_DISABLED: don't use any gains in preprocessing stage
+ * @CIFISP_DPF_GAIN_USAGE_NF_GAINS: use only the noise function gains from registers DPF_NF_GAIN_R, ...
+ * @CIFISP_DPF_GAIN_USAGE_LSC_GAINS:  use only the gains from LSC module
+ * @CIFISP_DPF_GAIN_USAGE_NF_LSC_GAINS: use the noise function gains and the gains from LSC module
+ * @CIFISP_DPF_GAIN_USAGE_AWB_GAINS: use only the gains from AWB module
+ * @CIFISP_DPF_GAIN_USAGE_AWB_LSC_GAINS: use the gains from AWB and LSC module
+ * @CIFISP_DPF_GAIN_USAGE_MAX: upper border (only for an internal evaluation)
+ */
+enum cifisp_dpf_gain_usage {
+	CIFISP_DPF_GAIN_USAGE_DISABLED,
+	CIFISP_DPF_GAIN_USAGE_NF_GAINS,
+	CIFISP_DPF_GAIN_USAGE_LSC_GAINS,
+	CIFISP_DPF_GAIN_USAGE_NF_LSC_GAINS,
+	CIFISP_DPF_GAIN_USAGE_AWB_GAINS,
+	CIFISP_DPF_GAIN_USAGE_AWB_LSC_GAINS,
+	CIFISP_DPF_GAIN_USAGE_MAX
+};
+
+/**
+ * enum cifisp_dpf_gain_usage - dpf gain usage
+ * @CIFISP_DPF_RB_FILTERSIZE_13x9: red and blue filter kernel size 13x9 (means 7x5 active pixel)
+ * @CIFISP_DPF_RB_FILTERSIZE_9x9: red and blue filter kernel size 9x9 (means 5x5 active pixel)
+ */
+enum cifisp_dpf_rb_filtersize {
+	CIFISP_DPF_RB_FILTERSIZE_13x9,
+	CIFISP_DPF_RB_FILTERSIZE_9x9,
+};
+
+/**
+ * enum cifisp_dpf_nll_scale_mode - dpf noise level scale mode
+ * @CIFISP_NLL_SCALE_LINEAR: use a linear scaling
+ * @CIFISP_NLL_SCALE_LOGARITHMIC: use a logarithmic scaling
+ */
+enum cifisp_dpf_nll_scale_mode {
+	CIFISP_NLL_SCALE_LINEAR,
+	CIFISP_NLL_SCALE_LOGARITHMIC,
+};
+
+struct cifisp_dpf_nll {
+	unsigned short coeff[CIFISP_DPF_MAX_NLF_COEFFS];
+	enum cifisp_dpf_nll_scale_mode scale_mode;
+} __attribute__ ((packed));
+
+struct cifisp_dpf_rb_flt {
+	enum cifisp_dpf_rb_filtersize fltsize;
+	unsigned char spatial_coeff[CIFISP_DPF_MAX_SPATIAL_COEFFS];
+	bool r_enable;
+	bool b_enable;
+} __attribute__ ((packed));
+
+struct cifisp_dpf_g_flt {
+	unsigned char spatial_coeff[CIFISP_DPF_MAX_SPATIAL_COEFFS];
+	bool gr_enable;
+	bool gb_enable;
+} __attribute__ ((packed));
+
+struct cifisp_dpf_gain {
+	enum cifisp_dpf_gain_usage mode;
+	unsigned short nf_r_gain;
+	unsigned short nf_b_gain;
+	unsigned short nf_gr_gain;
+	unsigned short nf_gb_gain;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_dpf_config - Configuration used by De-noising pre-filter
+ *
+ * @gain: noise function gain
+ * @g_flt: green filter config
+ * @rb_flt: red blue filter config
+ * @nll: noise level lookup
+ */
+struct cifisp_dpf_config {
+	struct cifisp_dpf_gain gain;
+	struct cifisp_dpf_g_flt g_flt;
+	struct cifisp_dpf_rb_flt rb_flt;
+	struct cifisp_dpf_nll nll;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_dpf_strength_config - strength of the filter
+ *
+ * @r: filter strength of the RED filter
+ * @g: filter strength of the GREEN filter
+ * @b: filter strength of the BLUE filter
+ */
+struct cifisp_dpf_strength_config {
+	unsigned char r;
+	unsigned char g;
+	unsigned char b;
+} __attribute__ ((packed));
+
+/**
+ * enum cifisp_wdr_mode - wdr mode
+ * @CIFISP_WDR_MODE_BLOCK: use a linear scaling
+ * @CIFISP_WDR_MODE_GLOBAL: use a logarithmic scaling
+ */
+enum cifisp_wdr_mode {
+	CIFISP_WDR_MODE_BLOCK,
+	CIFISP_WDR_MODE_GLOBAL
+};
+
+/**
+ * struct cifisp_wdr_config - Gamma Out correction
+ */
+struct cifisp_wdr_config {
+	enum cifisp_wdr_mode mode;
+	unsigned int c_wdr[CIFISP_WDR_SIZE];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_demosaiclp_config - rk demosiac low pass
+ */
+struct cifisp_demosaiclp_config {
+	unsigned char rb_filter_en;
+	unsigned char hp_filter_en;
+	unsigned char lu_divided[4];
+	unsigned char thgrad_divided[5];
+	unsigned char thdiff_divided[5];
+	unsigned char thcsc_divided[5];
+	unsigned short thvar_divided[5];
+	unsigned char th_grad;
+	unsigned char th_diff;
+	unsigned char th_csc;
+	unsigned short th_var;
+	unsigned char th_var_en;
+	unsigned char th_csc_en;
+	unsigned char th_diff_en;
+	unsigned char th_grad_en;
+	unsigned char use_old_lp;
+	unsigned char similarity_th;
+	unsigned char flat_level_sel;
+	unsigned char pattern_level_sel;
+	unsigned char edge_level_sel;
+	unsigned char thgrad_r_fct;
+	unsigned char thdiff_r_fct;
+	unsigned char thvar_r_fct;
+	unsigned char thgrad_b_fct;
+	unsigned char thdiff_b_fct;
+	unsigned char thvar_b_fct;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_rkiesharp_config - rk ie sharp
+ */
+struct cifisp_rkiesharp_config {
+	unsigned char coring_thr;
+	unsigned char full_range;
+	unsigned char switch_avg;
+	unsigned char yavg_thr[4];
+	unsigned char delta1[5];
+	unsigned char delta2[5];
+	unsigned char maxnumber[5];
+	unsigned char minnumber[5];
+	unsigned char gauss_flat_coe[9];
+	unsigned char gauss_noise_coe[9];
+	unsigned char gauss_other_coe[9];
+	unsigned char line1_filter_coe[6];
+	unsigned char line2_filter_coe[9];
+	unsigned char line3_filter_coe[6];
+	unsigned short grad_seq[4];
+	unsigned char sharp_factor[5];
+	unsigned char uv_gauss_flat_coe[15];
+	unsigned char uv_gauss_noise_coe[15];
+	unsigned char uv_gauss_other_coe[15];
+	unsigned char lap_mat_coe[9];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_isp_other_cfg - Parameters for some blocks in rockchip isp1
+ *
+ * @dpcc_config: Defect Pixel Cluster Correction config
+ * @bls_config: Black Level Subtraction config
+ * @sdg_config: sensor degamma config
+ * @lsc_config: Lens Shade config
+ * @awb_gain_config: Auto White balance gain config
+ * @flt_config: filter config
+ * @bdm_config: demosaic config
+ * @ctk_config: cross talk config
+ * @goc_config: gamma out config
+ * @bls_config: black level suntraction config
+ * @dpf_config: De-noising pre-filter config
+ * @dpf_strength_config: dpf strength config
+ * @cproc_config: color process config
+ * @ie_config: image effects config
+ */
+struct cifisp_isp_other_cfg {
+	struct cifisp_dpcc_config dpcc_config;
+	struct cifisp_bls_config bls_config;
+	struct cifisp_sdg_config sdg_config;
+	struct cifisp_lsc_config lsc_config;
+	struct cifisp_awb_gain_config awb_gain_config;
+	struct cifisp_flt_config flt_config;
+	struct cifisp_bdm_config bdm_config;
+	struct cifisp_ctk_config ctk_config;
+	struct cifisp_goc_config goc_config;
+	struct cifisp_dpf_config dpf_config;
+	struct cifisp_dpf_strength_config dpf_strength_config;
+	struct cifisp_cproc_config cproc_config;
+	struct cifisp_ie_config ie_config;
+	struct cifisp_wdr_config wdr_config;
+	struct cifisp_demosaiclp_config demosaiclp_config;
+	struct cifisp_rkiesharp_config rkiesharp_config;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_isp_meas_cfg - Rockchip ISP1 Measure Parameters
+ *
+ * @awb_meas_config: auto white balance config
+ * @hst_config: histogram config
+ * @aec_config: auto exposure config
+ * @afc_config: auto focus config
+ */
+struct cifisp_isp_meas_cfg {
+	struct cifisp_awb_meas_config awb_meas_config;
+	struct cifisp_hst_config hst_config;
+	struct cifisp_aec_config aec_config;
+	struct cifisp_afc_config afc_config;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp1_isp_params_cfg - Rockchip ISP1 Input Parameters Meta Data
+ *
+ * @module_en_update: mask the enable bits of which module  should be updated
+ * @module_ens: mask the enable value of each module, only update the module
+ * which correspond bit was set in module_en_update
+ * @module_cfg_update: mask the config bits of which module  should be updated
+ * @meas: measurement config
+ * @others: other config
+ */
+struct rkisp1_isp_params_cfg {
+	unsigned int module_en_update;
+	unsigned int module_ens;
+	unsigned int module_cfg_update;
+
+	struct cifisp_isp_meas_cfg meas;
+	struct cifisp_isp_other_cfg others;
+} __attribute__ ((packed));
+
+/*---------- PART2: Measurement Statistics ------------*/
+
+/**
+ * struct cifisp_bls_meas_val - AWB measured values
+ *
+ * @cnt: White pixel count, number of "white pixels" found during laster measurement
+ * @mean_y_or_g: Mean value of Y within window and frames, Green if RGB is selected.
+ * @mean_cb_or_b: Mean value of Cb within window and frames, Blue if RGB is selected.
+ * @mean_cr_or_r: Mean value of Cr within window and frames, Red if RGB is selected.
+ */
+struct cifisp_awb_meas {
+	unsigned int cnt;
+	unsigned char mean_y_or_g;
+	unsigned char mean_cb_or_b;
+	unsigned char mean_cr_or_r;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_awb_stat - statistics automatic white balance data
+ *
+ * @awb_mean: Mean measured data
+ */
+struct cifisp_awb_stat {
+	struct cifisp_awb_meas awb_mean[CIFISP_AWB_MAX_GRID];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_bls_meas_val - BLS measured values
+ *
+ * @meas_r: Mean measured value for Bayer pattern R
+ * @meas_gr: Mean measured value for Bayer pattern Gr
+ * @meas_gb: Mean measured value for Bayer pattern Gb
+ * @meas_b: Mean measured value for Bayer pattern B
+ */
+struct cifisp_bls_meas_val {
+	unsigned short meas_r;
+	unsigned short meas_gr;
+	unsigned short meas_gb;
+	unsigned short meas_b;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_ae_stat - statistics auto exposure data
+ *
+ * @exp_mean: Mean luminance value of block xx
+ * @bls_val: available wit exposure results
+ *
+ * Image is divided into 5x5 blocks.
+ */
+struct cifisp_ae_stat {
+	unsigned char exp_mean[CIFISP_AE_MEAN_MAX];
+	struct cifisp_bls_meas_val bls_val;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_af_meas_val - AF measured values
+ *
+ * @sum: sharpness, refer to datasheet for definition
+ * @lum: luminance, refer to datasheet for definition
+ */
+struct cifisp_af_meas_val {
+	unsigned int sum;
+	unsigned int lum;
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_af_stat - statistics auto focus data
+ *
+ * @window: AF measured value of window x
+ *
+ * The module measures the sharpness in 3 windows of selectable size via
+ * register settings(ISP_AFM_*_A/B/C)
+ */
+struct cifisp_af_stat {
+	struct cifisp_af_meas_val window[CIFISP_AFM_MAX_WINDOWS];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_hist_stat - statistics histogram data
+ *
+ * @hist_bins: measured bin counters
+ *
+ * Measurement window divided into 25 sub-windows, set
+ * with ISP_HIST_XXX
+ */
+struct cifisp_hist_stat {
+	unsigned int hist_bins[CIFISP_HIST_BIN_N_MAX];
+} __attribute__ ((packed));
+
+/**
+ * struct cifisp_embedded_data - embedded data
+ *
+ * @data: embedded data
+ *
+ */
+struct cifisp_embedded_data {
+	unsigned char data[CIFISP_ADD_DATA_FIFO_SIZE];
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp1_stat_buffer - Rockchip ISP1 Statistics Data
+ *
+ * @cifisp_awb_stat: statistics data for automatic white balance
+ * @cifisp_ae_stat: statistics data for auto exposure
+ * @cifisp_af_stat: statistics data for auto focus
+ * @cifisp_hist_stat: statistics histogram data
+ */
+struct cifisp_stat {
+	struct cifisp_awb_stat awb;
+	struct cifisp_ae_stat ae;
+	struct cifisp_af_stat af;
+	struct cifisp_hist_stat hist;
+	struct cifisp_embedded_data emd;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp1_stat_buffer - Rockchip ISP1 Statistics Meta Data
+ *
+ * @meas_type: measurement types (CIFISP_STAT_ definitions)
+ * @frame_id: frame ID for sync
+ * @params: statistics data
+ */
+struct rkisp1_stat_buffer {
+	unsigned int meas_type;
+	unsigned int frame_id;
+	struct cifisp_stat params;
+} __attribute__ ((packed));
+
+#endif /* _UAPI_RKISP1_CONFIG_H */
diff --git a/include/uapi/linux/rkisp2-config.h b/include/uapi/linux/rkisp2-config.h
new file mode 100644
index 000000000..9d41f9e8a
--- /dev/null
+++ b/include/uapi/linux/rkisp2-config.h
@@ -0,0 +1,1853 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT)
+ *
+ * Rockchip isp2 driver
+ * Copyright (C) 2017 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKISP2_CONFIG_H
+#define _UAPI_RKISP2_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+
+#define RKISP_API_VERSION		KERNEL_VERSION(1, 8, 0)
+
+/****************ISP SUBDEV IOCTL*****************************/
+
+#define RKISP_CMD_TRIGGER_READ_BACK \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 0, struct isp2x_csi_trigger)
+
+#define RKISP_CMD_GET_SHARED_BUF \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 2, struct rkisp_thunderboot_resmem)
+
+#define RKISP_CMD_FREE_SHARED_BUF \
+	_IO('V', BASE_VIDIOC_PRIVATE + 3)
+
+#define RKISP_CMD_GET_LDCHBUF_INFO \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 4, struct rkisp_ldchbuf_info)
+
+#define RKISP_CMD_SET_LDCHBUF_SIZE \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 5, struct rkisp_ldchbuf_size)
+
+#define RKISP_CMD_GET_SHM_BUFFD \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct rkisp_thunderboot_shmem)
+
+#define RKISP_CMD_GET_FBCBUF_FD \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 7, struct isp2x_buf_idxfd)
+
+#define RKISP_CMD_GET_MESHBUF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct rkisp_meshbuf_info)
+
+#define RKISP_CMD_SET_MESHBUF_SIZE \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 9, struct rkisp_meshbuf_size)
+
+/****************ISP VIDEO IOCTL******************************/
+
+#define RKISP_CMD_GET_CSI_MEMORY_MODE \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 100, int)
+
+#define RKISP_CMD_SET_CSI_MEMORY_MODE \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 101, int)
+
+#define RKISP_CMD_GET_CMSK \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 102, struct rkisp_cmsk_cfg)
+
+#define RKISP_CMD_SET_CMSK \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 103, struct rkisp_cmsk_cfg)
+
+/*************************************************************/
+
+#define ISP2X_ID_DPCC			(0)
+#define ISP2X_ID_BLS			(1)
+#define ISP2X_ID_SDG			(2)
+#define ISP2X_ID_SIHST			(3)
+#define ISP2X_ID_LSC			(4)
+#define ISP2X_ID_AWB_GAIN		(5)
+#define ISP2X_ID_BDM			(7)
+#define ISP2X_ID_CCM			(8)
+#define ISP2X_ID_GOC			(9)
+#define ISP2X_ID_CPROC			(10)
+#define ISP2X_ID_SIAF			(11)
+#define ISP2X_ID_SIAWB			(12)
+#define ISP2X_ID_IE			(13)
+#define ISP2X_ID_YUVAE			(14)
+#define ISP2X_ID_WDR			(15)
+#define ISP2X_ID_RK_IESHARP		(16)
+#define ISP2X_ID_RAWAF			(17)
+#define ISP2X_ID_RAWAE0			(18)
+#define ISP2X_ID_RAWAE1			(19)
+#define ISP2X_ID_RAWAE2			(20)
+#define ISP2X_ID_RAWAE3			(21)
+#define ISP2X_ID_RAWAWB			(22)
+#define ISP2X_ID_RAWHIST0		(23)
+#define ISP2X_ID_RAWHIST1		(24)
+#define ISP2X_ID_RAWHIST2		(25)
+#define ISP2X_ID_RAWHIST3		(26)
+#define ISP2X_ID_HDRMGE			(27)
+#define ISP2X_ID_RAWNR			(28)
+#define ISP2X_ID_HDRTMO			(29)
+#define ISP2X_ID_GIC			(30)
+#define ISP2X_ID_DHAZ			(31)
+#define ISP2X_ID_3DLUT			(32)
+#define ISP2X_ID_LDCH			(33)
+#define ISP2X_ID_GAIN			(34)
+#define ISP2X_ID_DEBAYER		(35)
+#define ISP2X_ID_MAX			(36)
+
+#define ISP2X_MODULE_DPCC		BIT_ULL(ISP2X_ID_DPCC)
+#define ISP2X_MODULE_BLS		BIT_ULL(ISP2X_ID_BLS)
+#define ISP2X_MODULE_SDG		BIT_ULL(ISP2X_ID_SDG)
+#define ISP2X_MODULE_SIHST		BIT_ULL(ISP2X_ID_SIHST)
+#define ISP2X_MODULE_LSC		BIT_ULL(ISP2X_ID_LSC)
+#define ISP2X_MODULE_AWB_GAIN		BIT_ULL(ISP2X_ID_AWB_GAIN)
+#define ISP2X_MODULE_BDM		BIT_ULL(ISP2X_ID_BDM)
+#define ISP2X_MODULE_CCM		BIT_ULL(ISP2X_ID_CCM)
+#define ISP2X_MODULE_GOC		BIT_ULL(ISP2X_ID_GOC)
+#define ISP2X_MODULE_CPROC		BIT_ULL(ISP2X_ID_CPROC)
+#define ISP2X_MODULE_SIAF		BIT_ULL(ISP2X_ID_SIAF)
+#define ISP2X_MODULE_SIAWB		BIT_ULL(ISP2X_ID_SIAWB)
+#define ISP2X_MODULE_IE			BIT_ULL(ISP2X_ID_IE)
+#define ISP2X_MODULE_YUVAE		BIT_ULL(ISP2X_ID_YUVAE)
+#define ISP2X_MODULE_WDR		BIT_ULL(ISP2X_ID_WDR)
+#define ISP2X_MODULE_RK_IESHARP		BIT_ULL(ISP2X_ID_RK_IESHARP)
+#define ISP2X_MODULE_RAWAF		BIT_ULL(ISP2X_ID_RAWAF)
+#define ISP2X_MODULE_RAWAE0		BIT_ULL(ISP2X_ID_RAWAE0)
+#define ISP2X_MODULE_RAWAE1		BIT_ULL(ISP2X_ID_RAWAE1)
+#define ISP2X_MODULE_RAWAE2		BIT_ULL(ISP2X_ID_RAWAE2)
+#define ISP2X_MODULE_RAWAE3		BIT_ULL(ISP2X_ID_RAWAE3)
+#define ISP2X_MODULE_RAWAWB		BIT_ULL(ISP2X_ID_RAWAWB)
+#define ISP2X_MODULE_RAWHIST0		BIT_ULL(ISP2X_ID_RAWHIST0)
+#define ISP2X_MODULE_RAWHIST1		BIT_ULL(ISP2X_ID_RAWHIST1)
+#define ISP2X_MODULE_RAWHIST2		BIT_ULL(ISP2X_ID_RAWHIST2)
+#define ISP2X_MODULE_RAWHIST3		BIT_ULL(ISP2X_ID_RAWHIST3)
+#define ISP2X_MODULE_HDRMGE		BIT_ULL(ISP2X_ID_HDRMGE)
+#define ISP2X_MODULE_RAWNR		BIT_ULL(ISP2X_ID_RAWNR)
+#define ISP2X_MODULE_HDRTMO		BIT_ULL(ISP2X_ID_HDRTMO)
+#define ISP2X_MODULE_GIC		BIT_ULL(ISP2X_ID_GIC)
+#define ISP2X_MODULE_DHAZ		BIT_ULL(ISP2X_ID_DHAZ)
+#define ISP2X_MODULE_3DLUT		BIT_ULL(ISP2X_ID_3DLUT)
+#define ISP2X_MODULE_LDCH		BIT_ULL(ISP2X_ID_LDCH)
+#define ISP2X_MODULE_GAIN		BIT_ULL(ISP2X_ID_GAIN)
+#define ISP2X_MODULE_DEBAYER		BIT_ULL(ISP2X_ID_DEBAYER)
+
+/*
+ * Measurement types
+ */
+#define ISP2X_STAT_SIAWB		BIT(0)
+#define ISP2X_STAT_YUVAE		BIT(1)
+#define ISP2X_STAT_SIAF			BIT(2)
+#define ISP2X_STAT_SIHST		BIT(3)
+#define ISP2X_STAT_EMB_DATA		BIT(4)
+#define ISP2X_STAT_RAWAWB		BIT(5)
+#define ISP2X_STAT_RAWAF		BIT(6)
+#define ISP2X_STAT_RAWAE0		BIT(7)
+#define ISP2X_STAT_RAWAE1		BIT(8)
+#define ISP2X_STAT_RAWAE2		BIT(9)
+#define ISP2X_STAT_RAWAE3		BIT(10)
+#define ISP2X_STAT_RAWHST0		BIT(11)
+#define ISP2X_STAT_RAWHST1		BIT(12)
+#define ISP2X_STAT_RAWHST2		BIT(13)
+#define ISP2X_STAT_RAWHST3		BIT(14)
+#define ISP2X_STAT_BLS			BIT(15)
+#define ISP2X_STAT_HDRTMO		BIT(16)
+#define ISP2X_STAT_DHAZ			BIT(17)
+
+#define ISP2X_LSC_GRAD_TBL_SIZE		8
+#define ISP2X_LSC_SIZE_TBL_SIZE		8
+#define ISP2X_LSC_DATA_TBL_SIZE		290
+
+#define ISP2X_DEGAMMA_CURVE_SIZE	17
+
+#define ISP2X_GAIN_HDRMGE_GAIN_NUM	3
+#define ISP2X_GAIN_IDX_NUM		15
+#define ISP2X_GAIN_LUT_NUM		17
+
+#define ISP2X_AWB_MAX_GRID		1
+#define ISP2X_RAWAWB_SUM_NUM		7
+#define ISP2X_RAWAWB_MULWD_NUM		8
+#define ISP2X_RAWAWB_RAMDATA_NUM	225
+
+#define ISP2X_RAWAEBIG_SUBWIN_NUM	4
+#define ISP2X_RAWAEBIG_MEAN_NUM		225
+#define ISP2X_RAWAELITE_MEAN_NUM	25
+#define ISP2X_YUVAE_SUBWIN_NUM		4
+#define ISP2X_YUVAE_MEAN_NUM		225
+
+#define ISP2X_RAWHISTBIG_SUBWIN_NUM	225
+#define ISP2X_RAWHISTLITE_SUBWIN_NUM	25
+#define ISP2X_SIHIST_WIN_NUM		1
+#define ISP2X_HIST_WEIGHT_NUM		225
+#define ISP2X_HIST_BIN_N_MAX		256
+#define ISP2X_SIHIST_BIN_N_MAX		32
+
+#define ISP2X_RAWAF_WIN_NUM		2
+#define ISP2X_RAWAF_LINE_NUM		5
+#define ISP2X_RAWAF_GAMMA_NUM		17
+#define ISP2X_RAWAF_SUMDATA_ROW		15
+#define ISP2X_RAWAF_SUMDATA_COLUMN	15
+#define ISP2X_RAWAF_SUMDATA_NUM		225
+#define ISP2X_AFM_MAX_WINDOWS		3
+
+#define ISP2X_DPCC_PDAF_POINT_NUM	16
+
+#define ISP2X_HDRMGE_L_CURVE_NUM	17
+#define ISP2X_HDRMGE_E_CURVE_NUM	17
+
+#define ISP2X_RAWNR_LUMA_RATION_NUM	8
+
+#define ISP2X_HDRTMO_MINMAX_NUM		32
+
+#define ISP2X_GIC_SIGMA_Y_NUM		15
+
+#define ISP2X_CCM_CURVE_NUM		17
+
+/* WDR */
+#define ISP2X_WDR_SIZE			48
+
+#define ISP2X_DHAZ_CONV_COEFF_NUM	6
+#define ISP2X_DHAZ_HIST_IIR_NUM		64
+
+#define ISP2X_GAMMA_OUT_MAX_SAMPLES	45
+
+#define ISP2X_MIPI_LUMA_MEAN_MAX	16
+#define ISP2X_MIPI_RAW_MAX		3
+#define ISP2X_RAW0_Y_STATE		(1 << 0)
+#define ISP2X_RAW1_Y_STATE		(1 << 1)
+#define ISP2X_RAW2_Y_STATE		(1 << 2)
+
+#define ISP2X_3DLUT_DATA_NUM		729
+
+#define ISP2X_LDCH_MESH_XY_NUM		0x80000
+#define ISP2X_LDCH_BUF_NUM		2
+
+#define ISP2X_THUNDERBOOT_VIDEO_BUF_NUM	30
+
+#define ISP2X_FBCBUF_FD_NUM		64
+
+#define ISP2X_MESH_BUF_NUM		2
+
+enum isp2x_mesh_buf_stat {
+	MESH_BUF_INIT = 0,
+	MESH_BUF_WAIT2CHIP,
+	MESH_BUF_CHIPINUSE,
+};
+
+struct rkisp_meshbuf_info {
+	u64 module_id;
+	u32 unite_isp_id;
+	s32 buf_fd[ISP2X_MESH_BUF_NUM];
+	u32 buf_size[ISP2X_MESH_BUF_NUM];
+} __attribute__ ((packed));
+
+struct rkisp_meshbuf_size {
+	u64 module_id;
+	u32 unite_isp_id;
+	u32 meas_width;
+	u32 meas_height;
+} __attribute__ ((packed));
+
+struct isp2x_mesh_head {
+	enum isp2x_mesh_buf_stat stat;
+	u32 data_oft;
+} __attribute__ ((packed));
+
+#define RKISP_CMSK_WIN_MAX 8
+#define RKISP_CMSK_MOSAIC_MODE 0
+#define RKISP_CMSK_COVER_MODE 1
+
+/* struct rkisp_cmsk_win
+ * Priacy Mask Window configture, support 8 windows, and
+ * support for mainpath and selfpath output stream channel.
+ *
+ * mode: 0:mosaic mode, 1:cover mode
+ * win_index: window index 0~7. windows overlap, priority win7 > win0.
+ * cover_color_y: cover mode effective, share for stream channel when same win_index.
+ * cover_color_u: cover mode effective, share for stream channel when same win_index.
+ * cover_color_v: cover mode effective, share for stream channel when same win_index.
+ *
+ * h_offs: window horizontal offset, share for stream channel when same win_index. 2 align.
+ * v_offs: window vertical offset, share for stream channel when same win_index. 2 align.
+ * h_size: window horizontal size, share for stream channel when same win_index. 8 align.
+ * v_size: window vertical size, share for stream channel when same win_index. 8 align.
+ */
+struct rkisp_cmsk_win {
+	unsigned char mode;
+	unsigned char win_en;
+
+	unsigned char cover_color_y;
+	unsigned char cover_color_u;
+	unsigned char cover_color_v;
+
+	unsigned short h_offs;
+	unsigned short v_offs;
+	unsigned short h_size;
+	unsigned short v_size;
+} __attribute__ ((packed));
+
+/* struct rkisp_cmsk_cfg
+ * win: priacy mask window
+ * width_ro: isp full resolution, h_offs + h_size <= width_ro.
+ * height_ro: isp full resolution, v_offs + v_size <= height_ro.
+ */
+struct rkisp_cmsk_cfg {
+	struct rkisp_cmsk_win win[RKISP_CMSK_WIN_MAX];
+	unsigned int width_ro;
+	unsigned int height_ro;
+} __attribute__ ((packed));
+
+/* trigger event mode
+ * T_TRY: trigger maybe with retry
+ * T_TRY_YES: trigger to retry
+ * T_TRY_NO: trigger no to retry
+ *
+ * T_START_X1: isp read one frame
+ * T_START_X2: isp read hdr two frame
+ * T_START_X3: isp read hdr three frame
+ */
+enum isp2x_trigger_mode {
+	T_TRY = BIT(0),
+	T_TRY_YES = BIT(1),
+	T_TRY_NO = BIT(2),
+
+	T_START_X1 = BIT(4),
+	T_START_X2 = BIT(5),
+	T_START_X3 = BIT(6),
+};
+
+struct isp2x_csi_trigger {
+	/* timestamp in ns */
+	u64 sof_timestamp;
+	u64 frame_timestamp;
+	u32 frame_id;
+	int times;
+	enum isp2x_trigger_mode mode;
+} __attribute__ ((packed));
+
+/* isp csi dmatx/dmarx memory mode
+ * 0: raw12/raw10/raw8 8bit memory compact
+ * 1: raw12/raw10 16bit memory one pixel
+ *    big endian for rv1126/rv1109
+ *    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *    | 3| 2| 1| 0| -| -| -| -|11|10| 9| 8| 7| 6| 5| 4|
+ *    little align for rk356x
+ *    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *    | -| -| -| -|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ * 2: raw12/raw10 16bit memory one pixel
+ *    big align for rv1126/rv1109/rk356x
+ *    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ *    |11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0| -| -| -| -|
+ */
+enum isp_csi_memory {
+	CSI_MEM_COMPACT = 0,
+	CSI_MEM_WORD_BIG_END = 1,
+	CSI_MEM_WORD_LITTLE_ALIGN = 1,
+	CSI_MEM_WORD_BIG_ALIGN = 2,
+};
+
+struct isp2x_ispgain_buf {
+	u32 gain_dmaidx;
+	u32 mfbc_dmaidx;
+	u32 gain_size;
+	u32 mfbc_size;
+	u32 frame_id;
+} __attribute__ ((packed));
+
+struct isp2x_buf_idxfd {
+	u32 buf_num;
+	u32 index[ISP2X_FBCBUF_FD_NUM];
+	s32 dmafd[ISP2X_FBCBUF_FD_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_window {
+	u16 h_offs;
+	u16 v_offs;
+	u16 h_size;
+	u16 v_size;
+} __attribute__ ((packed));
+
+struct isp2x_bls_fixed_val {
+	s16 r;
+	s16 gr;
+	s16 gb;
+	s16 b;
+} __attribute__ ((packed));
+
+struct isp2x_bls_cfg {
+	u8 enable_auto;
+	u8 en_windows;
+	struct isp2x_window bls_window1;
+	struct isp2x_window bls_window2;
+	u8 bls_samples;
+	struct isp2x_bls_fixed_val fixed_val;
+} __attribute__ ((packed));
+
+struct isp2x_bls_stat {
+	u16 meas_r;
+	u16 meas_gr;
+	u16 meas_gb;
+	u16 meas_b;
+} __attribute__ ((packed));
+
+struct isp2x_dpcc_pdaf_point {
+	u8 y;
+	u8 x;
+} __attribute__ ((packed));
+
+struct isp2x_dpcc_cfg {
+	//mode 0x0000
+	u8 stage1_enable;
+	u8 grayscale_mode;
+
+	//output_mode 0x0004
+	u8 sw_rk_out_sel;
+	u8 sw_dpcc_output_sel;
+	u8 stage1_rb_3x3;
+	u8 stage1_g_3x3;
+	u8 stage1_incl_rb_center;
+	u8 stage1_incl_green_center;
+
+	//set_use 0x0008
+	u8 stage1_use_fix_set;
+	u8 stage1_use_set_3;
+	u8 stage1_use_set_2;
+	u8 stage1_use_set_1;
+
+	//methods_set_1 0x000c
+	u8 sw_rk_red_blue1_en;
+	u8 rg_red_blue1_enable;
+	u8 rnd_red_blue1_enable;
+	u8 ro_red_blue1_enable;
+	u8 lc_red_blue1_enable;
+	u8 pg_red_blue1_enable;
+	u8 sw_rk_green1_en;
+	u8 rg_green1_enable;
+	u8 rnd_green1_enable;
+	u8 ro_green1_enable;
+	u8 lc_green1_enable;
+	u8 pg_green1_enable;
+
+	//methods_set_2 0x0010
+	u8 sw_rk_red_blue2_en;
+	u8 rg_red_blue2_enable;
+	u8 rnd_red_blue2_enable;
+	u8 ro_red_blue2_enable;
+	u8 lc_red_blue2_enable;
+	u8 pg_red_blue2_enable;
+	u8 sw_rk_green2_en;
+	u8 rg_green2_enable;
+	u8 rnd_green2_enable;
+	u8 ro_green2_enable;
+	u8 lc_green2_enable;
+	u8 pg_green2_enable;
+
+	//methods_set_3 0x0014
+	u8 sw_rk_red_blue3_en;
+	u8 rg_red_blue3_enable;
+	u8 rnd_red_blue3_enable;
+	u8 ro_red_blue3_enable;
+	u8 lc_red_blue3_enable;
+	u8 pg_red_blue3_enable;
+	u8 sw_rk_green3_en;
+	u8 rg_green3_enable;
+	u8 rnd_green3_enable;
+	u8 ro_green3_enable;
+	u8 lc_green3_enable;
+	u8 pg_green3_enable;
+
+	//line_thresh_1 0x0018
+	u8 sw_mindis1_rb;
+	u8 sw_mindis1_g;
+	u8 line_thr_1_rb;
+	u8 line_thr_1_g;
+
+	//line_mad_fac_1 0x001c
+	u8 sw_dis_scale_min1;
+	u8 sw_dis_scale_max1;
+	u8 line_mad_fac_1_rb;
+	u8 line_mad_fac_1_g;
+
+	//pg_fac_1 0x0020
+	u8 pg_fac_1_rb;
+	u8 pg_fac_1_g;
+
+	//rnd_thresh_1 0x0024
+	u8 rnd_thr_1_rb;
+	u8 rnd_thr_1_g;
+
+	//rg_fac_1 0x0028
+	u8 rg_fac_1_rb;
+	u8 rg_fac_1_g;
+
+	//line_thresh_2 0x002c
+	u8 sw_mindis2_rb;
+	u8 sw_mindis2_g;
+	u8 line_thr_2_rb;
+	u8 line_thr_2_g;
+
+	//line_mad_fac_2 0x0030
+	u8 sw_dis_scale_min2;
+	u8 sw_dis_scale_max2;
+	u8 line_mad_fac_2_rb;
+	u8 line_mad_fac_2_g;
+
+	//pg_fac_2 0x0034
+	u8 pg_fac_2_rb;
+	u8 pg_fac_2_g;
+
+	//rnd_thresh_2 0x0038
+	u8 rnd_thr_2_rb;
+	u8 rnd_thr_2_g;
+
+	//rg_fac_2 0x003c
+	u8 rg_fac_2_rb;
+	u8 rg_fac_2_g;
+
+	//line_thresh_3 0x0040
+	u8 sw_mindis3_rb;
+	u8 sw_mindis3_g;
+	u8 line_thr_3_rb;
+	u8 line_thr_3_g;
+
+	//line_mad_fac_3 0x0044
+	u8 sw_dis_scale_min3;
+	u8 sw_dis_scale_max3;
+	u8 line_mad_fac_3_rb;
+	u8 line_mad_fac_3_g;
+
+	//pg_fac_3 0x0048
+	u8 pg_fac_3_rb;
+	u8 pg_fac_3_g;
+
+	//rnd_thresh_3 0x004c
+	u8 rnd_thr_3_rb;
+	u8 rnd_thr_3_g;
+
+	//rg_fac_3 0x0050
+	u8 rg_fac_3_rb;
+	u8 rg_fac_3_g;
+
+	//ro_limits 0x0054
+	u8 ro_lim_3_rb;
+	u8 ro_lim_3_g;
+	u8 ro_lim_2_rb;
+	u8 ro_lim_2_g;
+	u8 ro_lim_1_rb;
+	u8 ro_lim_1_g;
+
+	//rnd_offs 0x0058
+	u8 rnd_offs_3_rb;
+	u8 rnd_offs_3_g;
+	u8 rnd_offs_2_rb;
+	u8 rnd_offs_2_g;
+	u8 rnd_offs_1_rb;
+	u8 rnd_offs_1_g;
+
+	//bpt_ctrl 0x005c
+	u8 bpt_rb_3x3;
+	u8 bpt_g_3x3;
+	u8 bpt_incl_rb_center;
+	u8 bpt_incl_green_center;
+	u8 bpt_use_fix_set;
+	u8 bpt_use_set_3;
+	u8 bpt_use_set_2;
+	u8 bpt_use_set_1;
+	u8 bpt_cor_en;
+	u8 bpt_det_en;
+
+	//bpt_number 0x0060
+	u16 bp_number;
+
+	//bpt_addr 0x0064
+	u16 bp_table_addr;
+
+	//bpt_data 0x0068
+	u16 bpt_v_addr;
+	u16 bpt_h_addr;
+
+	//bp_cnt 0x006c
+	u32 bp_cnt;
+
+	//pdaf_en 0x0070
+	u8 sw_pdaf_en;
+
+	//pdaf_point_en 0x0074
+	u8 pdaf_point_en[ISP2X_DPCC_PDAF_POINT_NUM];
+
+	//pdaf_offset 0x0078
+	u16 pdaf_offsety;
+	u16 pdaf_offsetx;
+
+	//pdaf_wrap 0x007c
+	u16 pdaf_wrapy;
+	u16 pdaf_wrapx;
+
+	//pdaf_scope 0x0080
+	u16 pdaf_wrapy_num;
+	u16 pdaf_wrapx_num;
+
+	//pdaf_point_0 0x0084
+	struct isp2x_dpcc_pdaf_point point[ISP2X_DPCC_PDAF_POINT_NUM];
+
+	//pdaf_forward_med 0x00a4
+	u8 pdaf_forward_med;
+} __attribute__ ((packed));
+
+struct isp2x_hdrmge_curve {
+	u16 curve_1[ISP2X_HDRMGE_L_CURVE_NUM];
+	u16 curve_0[ISP2X_HDRMGE_L_CURVE_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_hdrmge_cfg {
+	u8 mode;
+
+	u16 gain0_inv;
+	u16 gain0;
+
+	u16 gain1_inv;
+	u16 gain1;
+
+	u8 gain2;
+
+	u8 lm_dif_0p15;
+	u8 lm_dif_0p9;
+	u8 ms_diff_0p15;
+	u8 ms_dif_0p8;
+
+	struct isp2x_hdrmge_curve curve;
+	u16 e_y[ISP2X_HDRMGE_E_CURVE_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawnr_cfg {
+	u8 gauss_en;
+	u8 log_bypass;
+
+	u16 filtpar0;
+	u16 filtpar1;
+	u16 filtpar2;
+
+	u32 dgain0;
+	u32 dgain1;
+	u32 dgain2;
+
+	u16 luration[ISP2X_RAWNR_LUMA_RATION_NUM];
+	u16 lulevel[ISP2X_RAWNR_LUMA_RATION_NUM];
+
+	u32 gauss;
+	u16 sigma;
+	u16 pix_diff;
+
+	u32 thld_diff;
+
+	u8 gas_weig_scl2;
+	u8 gas_weig_scl1;
+	u16 thld_chanelw;
+
+	u16 lamda;
+
+	u16 fixw0;
+	u16 fixw1;
+	u16 fixw2;
+	u16 fixw3;
+
+	u32 wlamda0;
+	u32 wlamda1;
+	u32 wlamda2;
+
+	u16 rgain_filp;
+	u16 bgain_filp;
+} __attribute__ ((packed));
+
+struct isp2x_lsc_cfg {
+	u16 r_data_tbl[ISP2X_LSC_DATA_TBL_SIZE];
+	u16 gr_data_tbl[ISP2X_LSC_DATA_TBL_SIZE];
+	u16 gb_data_tbl[ISP2X_LSC_DATA_TBL_SIZE];
+	u16 b_data_tbl[ISP2X_LSC_DATA_TBL_SIZE];
+
+	u16 x_grad_tbl[ISP2X_LSC_GRAD_TBL_SIZE];
+	u16 y_grad_tbl[ISP2X_LSC_GRAD_TBL_SIZE];
+
+	u16 x_size_tbl[ISP2X_LSC_SIZE_TBL_SIZE];
+	u16 y_size_tbl[ISP2X_LSC_SIZE_TBL_SIZE];
+} __attribute__ ((packed));
+
+enum isp2x_goc_mode {
+	ISP2X_GOC_MODE_LOGARITHMIC,
+	ISP2X_GOC_MODE_EQUIDISTANT
+};
+
+struct isp2x_goc_cfg {
+	enum isp2x_goc_mode mode;
+	u8 gamma_y[17];
+} __attribute__ ((packed));
+
+struct isp2x_hdrtmo_predict {
+	u8 global_tmo;
+	s32 iir_max;
+	s32 global_tmo_strength;
+
+	u8 scene_stable;
+	s32 k_rolgmean;
+	s32 iir;
+} __attribute__ ((packed));
+
+struct isp2x_hdrtmo_cfg {
+	u16 cnt_vsize;
+	u8 gain_ld_off2;
+	u8 gain_ld_off1;
+	u8 big_en;
+	u8 nobig_en;
+	u8 newhst_en;
+	u8 cnt_mode;
+
+	u16 expl_lgratio;
+	u8 lgscl_ratio;
+	u8 cfg_alpha;
+
+	u16 set_gainoff;
+	u16 set_palpha;
+
+	u16 set_lgmax;
+	u16 set_lgmin;
+
+	u8 set_weightkey;
+	u16 set_lgmean;
+
+	u16 set_lgrange1;
+	u16 set_lgrange0;
+
+	u16 set_lgavgmax;
+
+	u8 clipgap1_i;
+	u8 clipgap0_i;
+	u8 clipratio1;
+	u8 clipratio0;
+	u8 ratiol;
+
+	u16 lgscl_inv;
+	u16 lgscl;
+
+	u16 lgmax;
+
+	u16 hist_low;
+	u16 hist_min;
+
+	u8 hist_shift;
+	u16 hist_0p3;
+	u16 hist_high;
+
+	u16 palpha_lwscl;
+	u16 palpha_lw0p5;
+	u16 palpha_0p18;
+
+	u16 maxgain;
+	u16 maxpalpha;
+
+	struct isp2x_hdrtmo_predict predict;
+} __attribute__ ((packed));
+
+struct isp2x_hdrtmo_stat {
+	u16 lglow;
+	u16 lgmin;
+	u16 lghigh;
+	u16 lgmax;
+	u16 weightkey;
+	u16 lgmean;
+	u16 lgrange1;
+	u16 lgrange0;
+	u16 palpha;
+	u16 lgavgmax;
+	u16 linecnt;
+	u32 min_max[ISP2X_HDRTMO_MINMAX_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_gic_cfg {
+	u8 edge_open;
+
+	u16 regmingradthrdark2;
+	u16 regmingradthrdark1;
+	u16 regminbusythre;
+
+	u16 regdarkthre;
+	u16 regmaxcorvboth;
+	u16 regdarktthrehi;
+
+	u8 regkgrad2dark;
+	u8 regkgrad1dark;
+	u8 regstrengthglobal_fix;
+	u8 regdarkthrestep;
+	u8 regkgrad2;
+	u8 regkgrad1;
+	u8 reggbthre;
+
+	u16 regmaxcorv;
+	u16 regmingradthr2;
+	u16 regmingradthr1;
+
+	u8 gr_ratio;
+	u16 dnloscale;
+	u16 dnhiscale;
+	u8 reglumapointsstep;
+
+	u16 gvaluelimitlo;
+	u16 gvaluelimithi;
+	u8 fusionratiohilimt1;
+
+	u8 regstrength_fix;
+
+	u16 sigma_y[ISP2X_GIC_SIGMA_Y_NUM];
+
+	u8 noise_cut_en;
+	u16 noise_coe_a;
+
+	u16 noise_coe_b;
+	u16 diff_clip;
+} __attribute__ ((packed));
+
+struct isp2x_debayer_cfg {
+	u8 filter_c_en;
+	u8 filter_g_en;
+
+	u8 thed1;
+	u8 thed0;
+	u8 dist_scale;
+	u8 max_ratio;
+	u8 clip_en;
+
+	s8 filter1_coe5;
+	s8 filter1_coe4;
+	s8 filter1_coe3;
+	s8 filter1_coe2;
+	s8 filter1_coe1;
+
+	s8 filter2_coe5;
+	s8 filter2_coe4;
+	s8 filter2_coe3;
+	s8 filter2_coe2;
+	s8 filter2_coe1;
+
+	u16 hf_offset;
+	u8 gain_offset;
+	u8 offset;
+
+	u8 shift_num;
+	u8 order_max;
+	u8 order_min;
+} __attribute__ ((packed));
+
+struct isp2x_ccm_cfg {
+	s16 coeff0_r;
+	s16 coeff1_r;
+	s16 coeff2_r;
+	s16 offset_r;
+
+	s16 coeff0_g;
+	s16 coeff1_g;
+	s16 coeff2_g;
+	s16 offset_g;
+
+	s16 coeff0_b;
+	s16 coeff1_b;
+	s16 coeff2_b;
+	s16 offset_b;
+
+	u16 coeff0_y;
+	u16 coeff1_y;
+	u16 coeff2_y;
+
+	u16 alp_y[ISP2X_CCM_CURVE_NUM];
+
+	u8 bound_bit;
+} __attribute__ ((packed));
+
+struct isp2x_gammaout_cfg {
+	u8 equ_segm;
+	u16 offset;
+	u16 gamma_y[ISP2X_GAMMA_OUT_MAX_SAMPLES];
+} __attribute__ ((packed));
+
+enum isp2x_wdr_mode {
+	ISP2X_WDR_MODE_BLOCK,
+	ISP2X_WDR_MODE_GLOBAL
+};
+
+struct isp2x_wdr_cfg {
+	enum isp2x_wdr_mode mode;
+	unsigned int c_wdr[ISP2X_WDR_SIZE];
+} __attribute__ ((packed));
+
+struct isp2x_dhaz_cfg {
+	u8 enhance_en;
+	u8 hist_chn;
+	u8 hpara_en;
+	u8 hist_en;
+	u8 dc_en;
+	u8 big_en;
+	u8 nobig_en;
+
+	u8 yblk_th;
+	u8 yhist_th;
+	u8 dc_max_th;
+	u8 dc_min_th;
+
+	u16 wt_max;
+	u8 bright_max;
+	u8 bright_min;
+
+	u8 tmax_base;
+	u8 dark_th;
+	u8 air_max;
+	u8 air_min;
+
+	u16 tmax_max;
+	u16 tmax_off;
+
+	u8 hist_th_off;
+	u8 hist_gratio;
+
+	u16 hist_min;
+	u16 hist_k;
+
+	u16 enhance_value;
+	u16 hist_scale;
+
+	u16 iir_wt_sigma;
+	u16 iir_sigma;
+	u16 stab_fnum;
+
+	u16 iir_tmax_sigma;
+	u16 iir_air_sigma;
+
+	u16 cfg_wt;
+	u16 cfg_air;
+	u16 cfg_alpha;
+
+	u16 cfg_gratio;
+	u16 cfg_tmax;
+
+	u16 dc_weitcur;
+	u16 dc_thed;
+
+	u8 sw_dhaz_dc_bf_h3;
+	u8 sw_dhaz_dc_bf_h2;
+	u8 sw_dhaz_dc_bf_h1;
+	u8 sw_dhaz_dc_bf_h0;
+
+	u8 sw_dhaz_dc_bf_h5;
+	u8 sw_dhaz_dc_bf_h4;
+
+	u16 air_weitcur;
+	u16 air_thed;
+
+	u8 air_bf_h2;
+	u8 air_bf_h1;
+	u8 air_bf_h0;
+
+	u8 gaus_h2;
+	u8 gaus_h1;
+	u8 gaus_h0;
+
+	u8 conv_t0[ISP2X_DHAZ_CONV_COEFF_NUM];
+	u8 conv_t1[ISP2X_DHAZ_CONV_COEFF_NUM];
+	u8 conv_t2[ISP2X_DHAZ_CONV_COEFF_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_dhaz_stat {
+	u16 dhaz_adp_air_base;
+	u16 dhaz_adp_wt;
+
+	u16 dhaz_adp_gratio;
+	u16 dhaz_adp_tmax;
+
+	u16 h_r_iir[ISP2X_DHAZ_HIST_IIR_NUM];
+	u16 h_g_iir[ISP2X_DHAZ_HIST_IIR_NUM];
+	u16 h_b_iir[ISP2X_DHAZ_HIST_IIR_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_cproc_cfg {
+	u8 c_out_range;
+	u8 y_in_range;
+	u8 y_out_range;
+	u8 contrast;
+	u8 brightness;
+	u8 sat;
+	u8 hue;
+} __attribute__ ((packed));
+
+struct isp2x_ie_cfg {
+	u16 effect;
+	u16 color_sel;
+	u16 eff_mat_1;
+	u16 eff_mat_2;
+	u16 eff_mat_3;
+	u16 eff_mat_4;
+	u16 eff_mat_5;
+	u16 eff_tint;
+} __attribute__ ((packed));
+
+struct isp2x_rkiesharp_cfg {
+	u8 coring_thr;
+	u8 full_range;
+	u8 switch_avg;
+	u8 yavg_thr[4];
+	u8 delta1[5];
+	u8 delta2[5];
+	u8 maxnumber[5];
+	u8 minnumber[5];
+	u8 gauss_flat_coe[9];
+	u8 gauss_noise_coe[9];
+	u8 gauss_other_coe[9];
+	u8 line1_filter_coe[6];
+	u8 line2_filter_coe[9];
+	u8 line3_filter_coe[6];
+	u16 grad_seq[4];
+	u8 sharp_factor[5];
+	u8 uv_gauss_flat_coe[15];
+	u8 uv_gauss_noise_coe[15];
+	u8 uv_gauss_other_coe[15];
+	u8 lap_mat_coe[9];
+} __attribute__ ((packed));
+
+struct isp2x_superimp_cfg {
+	u8 transparency_mode;
+	u8 ref_image;
+
+	u16 offset_x;
+	u16 offset_y;
+
+	u8 y_comp;
+	u8 cb_comp;
+	u8 cr_comp;
+} __attribute__ ((packed));
+
+struct isp2x_gamma_corr_curve {
+	u16 gamma_y[ISP2X_DEGAMMA_CURVE_SIZE];
+} __attribute__ ((packed));
+
+struct isp2x_gamma_curve_x_axis_pnts {
+	u32 gamma_dx0;
+	u32 gamma_dx1;
+} __attribute__ ((packed));
+
+struct isp2x_sdg_cfg {
+	struct isp2x_gamma_corr_curve curve_r;
+	struct isp2x_gamma_corr_curve curve_g;
+	struct isp2x_gamma_corr_curve curve_b;
+	struct isp2x_gamma_curve_x_axis_pnts xa_pnts;
+} __attribute__ ((packed));
+
+struct isp2x_bdm_config {
+	unsigned char demosaic_th;
+} __attribute__ ((packed));
+
+struct isp2x_gain_cfg {
+	u8 dhaz_en;
+	u8 wdr_en;
+	u8 tmo_en;
+	u8 lsc_en;
+	u8 mge_en;
+
+	u32 mge_gain[ISP2X_GAIN_HDRMGE_GAIN_NUM];
+	u16 idx[ISP2X_GAIN_IDX_NUM];
+	u16 lut[ISP2X_GAIN_LUT_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_3dlut_cfg {
+	u8 bypass_en;
+	u32 actual_size;	// word unit
+	u16 lut_r[ISP2X_3DLUT_DATA_NUM];
+	u16 lut_g[ISP2X_3DLUT_DATA_NUM];
+	u16 lut_b[ISP2X_3DLUT_DATA_NUM];
+} __attribute__ ((packed));
+
+enum isp2x_ldch_buf_stat {
+	LDCH_BUF_INIT = 0,
+	LDCH_BUF_WAIT2CHIP,
+	LDCH_BUF_CHIPINUSE,
+};
+
+struct rkisp_ldchbuf_info {
+	s32 buf_fd[ISP2X_LDCH_BUF_NUM];
+	u32 buf_size[ISP2X_LDCH_BUF_NUM];
+} __attribute__ ((packed));
+
+struct rkisp_ldchbuf_size {
+	u32 meas_width;
+	u32 meas_height;
+} __attribute__ ((packed));
+
+struct isp2x_ldch_head {
+	enum isp2x_ldch_buf_stat stat;
+	u32 data_oft;
+} __attribute__ ((packed));
+
+struct isp2x_ldch_cfg {
+	u32 hsize;
+	u32 vsize;
+	s32 buf_fd;
+} __attribute__ ((packed));
+
+struct isp2x_awb_gain_cfg {
+	u16 gain_red;
+	u16 gain_green_r;
+	u16 gain_blue;
+	u16 gain_green_b;
+} __attribute__ ((packed));
+
+struct isp2x_siawb_meas_cfg {
+	struct isp2x_window awb_wnd;
+	u8 awb_mode;
+	u8 max_y;
+	u8 min_y;
+	u8 max_csum;
+	u8 min_c;
+	u8 frames;
+	u8 awb_ref_cr;
+	u8 awb_ref_cb;
+	u8 enable_ymax_cmp;
+} __attribute__ ((packed));
+
+struct isp2x_rawawb_meas_cfg {
+	u8 rawawb_sel;
+	u8 sw_rawawb_light_num;			//CTRL
+	u8 sw_rawawb_wind_size;			//CTRL
+	u8 sw_rawawb_c_range;			//CTRL
+	u8 sw_rawawb_y_range;			//CTRL
+	u8 sw_rawawb_3dyuv_ls_idx3;		//CTRL
+	u8 sw_rawawb_3dyuv_ls_idx2;		//CTRL
+	u8 sw_rawawb_3dyuv_ls_idx1;		//CTRL
+	u8 sw_rawawb_3dyuv_ls_idx0;		//CTRL
+	u8 sw_rawawb_xy_en;			//CTRL
+	u8 sw_rawawb_uv_en;			//CTRL
+	u8 sw_rawlsc_bypass_en;			//CTRL
+	u8 sw_rawawb_blk_measure_mode;		//BLK_CTRL
+	u8 sw_rawawb_store_wp_flag_ls_idx2;	//BLK_CTRL
+	u8 sw_rawawb_store_wp_flag_ls_idx1;	//BLK_CTRL
+	u8 sw_rawawb_store_wp_flag_ls_idx0;	//BLK_CTRL
+	u16 sw_rawawb_store_wp_th0;		//BLK_CTRL
+	u16 sw_rawawb_store_wp_th1;		//BLK_CTRL
+	u16 sw_rawawb_store_wp_th2;		//RAW_CTRL
+	u16 sw_rawawb_v_offs;			//WIN_OFFS
+	u16 sw_rawawb_h_offs;			//WIN_OFFS
+	u16 sw_rawawb_v_size;			//WIN_SIZE
+	u16 sw_rawawb_h_size;			//WIN_SIZE
+	u16 sw_rawawb_g_max;			//LIMIT_RG_MAX
+	u16 sw_rawawb_r_max;			//LIMIT_RG_MAX
+	u16 sw_rawawb_y_max;			//LIMIT_BY_MAX
+	u16 sw_rawawb_b_max;			//LIMIT_BY_MAX
+	u16 sw_rawawb_g_min;			//LIMIT_RG_MIN
+	u16 sw_rawawb_r_min;			//LIMIT_RG_MIN
+	u16 sw_rawawb_y_min;			//LIMIT_BY_MIN
+	u16 sw_rawawb_b_min;			//LIMIT_BY_MIN
+	u16 sw_rawawb_coeff_y_g;		//RGB2Y_0
+	u16 sw_rawawb_coeff_y_r;		//RGB2Y_0
+	u16 sw_rawawb_coeff_y_b;		//RGB2Y_1
+	u16 sw_rawawb_coeff_u_g;		//RGB2U_0
+	u16 sw_rawawb_coeff_u_r;		//RGB2U_0
+	u16 sw_rawawb_coeff_u_b;		//RGB2U_1
+	u16 sw_rawawb_coeff_v_g;		//RGB2V_0
+	u16 sw_rawawb_coeff_v_r;		//RGB2V_0
+	u16 sw_rawawb_coeff_v_b;		//RGB2V_1
+	u16 sw_rawawb_vertex0_v_0;		//UV_DETC_VERTEX0_0
+	u16 sw_rawawb_vertex0_u_0;		//UV_DETC_VERTEX0_0
+	u16 sw_rawawb_vertex1_v_0;		//UV_DETC_VERTEX1_0
+	u16 sw_rawawb_vertex1_u_0;		//UV_DETC_VERTEX1_0
+	u16 sw_rawawb_vertex2_v_0;		//UV_DETC_VERTEX2_0
+	u16 sw_rawawb_vertex2_u_0;		//UV_DETC_VERTEX2_0
+	u16 sw_rawawb_vertex3_v_0;		//UV_DETC_VERTEX3_0
+	u16 sw_rawawb_vertex3_u_0;		//UV_DETC_VERTEX3_0
+	u32 sw_rawawb_islope01_0;		//UV_DETC_ISLOPE01_0
+	u32 sw_rawawb_islope12_0;		//UV_DETC_ISLOPE12_0
+	u32 sw_rawawb_islope23_0;		//UV_DETC_ISLOPE23_0
+	u32 sw_rawawb_islope30_0;		//UV_DETC_ISLOPE30_0
+	u16 sw_rawawb_vertex0_v_1;		//UV_DETC_VERTEX0_1
+	u16 sw_rawawb_vertex0_u_1;		//UV_DETC_VERTEX0_1
+	u16 sw_rawawb_vertex1_v_1;		//UV_DETC_VERTEX1_1
+	u16 sw_rawawb_vertex1_u_1;		//UV_DETC_VERTEX1_1
+	u16 sw_rawawb_vertex2_v_1;		//UV_DETC_VERTEX2_1
+	u16 sw_rawawb_vertex2_u_1;		//UV_DETC_VERTEX2_1
+	u16 sw_rawawb_vertex3_v_1;		//UV_DETC_VERTEX3_1
+	u16 sw_rawawb_vertex3_u_1;		//UV_DETC_VERTEX3_1
+	u32 sw_rawawb_islope01_1;		//UV_DETC_ISLOPE01_1
+	u32 sw_rawawb_islope12_1;		//UV_DETC_ISLOPE12_1
+	u32 sw_rawawb_islope23_1;		//UV_DETC_ISLOPE23_1
+	u32 sw_rawawb_islope30_1;		//UV_DETC_ISLOPE30_1
+	u16 sw_rawawb_vertex0_v_2;		//UV_DETC_VERTEX0_2
+	u16 sw_rawawb_vertex0_u_2;		//UV_DETC_VERTEX0_2
+	u16 sw_rawawb_vertex1_v_2;		//UV_DETC_VERTEX1_2
+	u16 sw_rawawb_vertex1_u_2;		//UV_DETC_VERTEX1_2
+	u16 sw_rawawb_vertex2_v_2;		//UV_DETC_VERTEX2_2
+	u16 sw_rawawb_vertex2_u_2;		//UV_DETC_VERTEX2_2
+	u16 sw_rawawb_vertex3_v_2;		//UV_DETC_VERTEX3_2
+	u16 sw_rawawb_vertex3_u_2;		//UV_DETC_VERTEX3_2
+	u32 sw_rawawb_islope01_2;		//UV_DETC_ISLOPE01_2
+	u32 sw_rawawb_islope12_2;		//UV_DETC_ISLOPE12_2
+	u32 sw_rawawb_islope23_2;		//UV_DETC_ISLOPE23_2
+	u32 sw_rawawb_islope30_2;		//UV_DETC_ISLOPE30_2
+	u16 sw_rawawb_vertex0_v_3;		//UV_DETC_VERTEX0_3
+	u16 sw_rawawb_vertex0_u_3;		//UV_DETC_VERTEX0_3
+	u16 sw_rawawb_vertex1_v_3;		//UV_DETC_VERTEX1_3
+	u16 sw_rawawb_vertex1_u_3;		//UV_DETC_VERTEX1_3
+	u16 sw_rawawb_vertex2_v_3;		//UV_DETC_VERTEX2_3
+	u16 sw_rawawb_vertex2_u_3;		//UV_DETC_VERTEX2_3
+	u16 sw_rawawb_vertex3_v_3;		//UV_DETC_VERTEX3_3
+	u16 sw_rawawb_vertex3_u_3;		//UV_DETC_VERTEX3_3
+	u32 sw_rawawb_islope01_3;		//UV_DETC_ISLOPE01_3
+	u32 sw_rawawb_islope12_3;		//UV_DETC_ISLOPE12_3
+	u32 sw_rawawb_islope23_3;		//UV_DETC_ISLOPE23_3
+	u32 sw_rawawb_islope30_3;		//UV_DETC_ISLOPE30_3
+	u16 sw_rawawb_vertex0_v_4;		//UV_DETC_VERTEX0_4
+	u16 sw_rawawb_vertex0_u_4;		//UV_DETC_VERTEX0_4
+	u16 sw_rawawb_vertex1_v_4;		//UV_DETC_VERTEX1_4
+	u16 sw_rawawb_vertex1_u_4;		//UV_DETC_VERTEX1_4
+	u16 sw_rawawb_vertex2_v_4;		//UV_DETC_VERTEX2_4
+	u16 sw_rawawb_vertex2_u_4;		//UV_DETC_VERTEX2_4
+	u16 sw_rawawb_vertex3_v_4;		//UV_DETC_VERTEX3_4
+	u16 sw_rawawb_vertex3_u_4;		//UV_DETC_VERTEX3_4
+	u32 sw_rawawb_islope01_4;		//UV_DETC_ISLOPE01_4
+	u32 sw_rawawb_islope12_4;		//UV_DETC_ISLOPE12_4
+	u32 sw_rawawb_islope23_4;		//UV_DETC_ISLOPE23_4
+	u32 sw_rawawb_islope30_4;		//UV_DETC_ISLOPE30_4
+	u16 sw_rawawb_vertex0_v_5;		//UV_DETC_VERTEX0_5
+	u16 sw_rawawb_vertex0_u_5;		//UV_DETC_VERTEX0_5
+	u16 sw_rawawb_vertex1_v_5;		//UV_DETC_VERTEX1_5
+	u16 sw_rawawb_vertex1_u_5;		//UV_DETC_VERTEX1_5
+	u16 sw_rawawb_vertex2_v_5;		//UV_DETC_VERTEX2_5
+	u16 sw_rawawb_vertex2_u_5;		//UV_DETC_VERTEX2_5
+	u16 sw_rawawb_vertex3_v_5;		//UV_DETC_VERTEX3_5
+	u16 sw_rawawb_vertex3_u_5;		//UV_DETC_VERTEX3_5
+	u32 sw_rawawb_islope01_5;		//UV_DETC_ISLOPE01_5
+	u32 sw_rawawb_islope12_5;		//UV_DETC_ISLOPE10_5
+	u32 sw_rawawb_islope23_5;		//UV_DETC_ISLOPE23_5
+	u32 sw_rawawb_islope30_5;		//UV_DETC_ISLOPE30_5
+	u16 sw_rawawb_vertex0_v_6;		//UV_DETC_VERTEX0_6
+	u16 sw_rawawb_vertex0_u_6;		//UV_DETC_VERTEX0_6
+	u16 sw_rawawb_vertex1_v_6;		//UV_DETC_VERTEX1_6
+	u16 sw_rawawb_vertex1_u_6;		//UV_DETC_VERTEX1_6
+	u16 sw_rawawb_vertex2_v_6;		//UV_DETC_VERTEX2_6
+	u16 sw_rawawb_vertex2_u_6;		//UV_DETC_VERTEX2_6
+	u16 sw_rawawb_vertex3_v_6;		//UV_DETC_VERTEX3_6
+	u16 sw_rawawb_vertex3_u_6;		//UV_DETC_VERTEX3_6
+	u32 sw_rawawb_islope01_6;		//UV_DETC_ISLOPE01_6
+	u32 sw_rawawb_islope12_6;		//UV_DETC_ISLOPE10_6
+	u32 sw_rawawb_islope23_6;		//UV_DETC_ISLOPE23_6
+	u32 sw_rawawb_islope30_6;		//UV_DETC_ISLOPE30_6
+	u32 sw_rawawb_b_uv_0;			//YUV_DETC_B_UV_0
+	u32 sw_rawawb_slope_vtcuv_0;		//YUV_DETC_SLOPE_VTCUV_0
+	u32 sw_rawawb_inv_dslope_0;		//YUV_DETC_INV_DSLOPE_0
+	u32 sw_rawawb_slope_ydis_0;		//YUV_DETC_SLOPE_YDIS_0
+	u32 sw_rawawb_b_ydis_0;			//YUV_DETC_B_YDIS_0
+	u32 sw_rawawb_b_uv_1;			//YUV_DETC_B_UV_1
+	u32 sw_rawawb_slope_vtcuv_1;		//YUV_DETC_SLOPE_VTCUV_1
+	u32 sw_rawawb_inv_dslope_1;		//YUV_DETC_INV_DSLOPE_1
+	u32 sw_rawawb_slope_ydis_1;		//YUV_DETC_SLOPE_YDIS_1
+	u32 sw_rawawb_b_ydis_1;			//YUV_DETC_B_YDIS_1
+	u32 sw_rawawb_b_uv_2;			//YUV_DETC_B_UV_2
+	u32 sw_rawawb_slope_vtcuv_2;		//YUV_DETC_SLOPE_VTCUV_2
+	u32 sw_rawawb_inv_dslope_2;		//YUV_DETC_INV_DSLOPE_2
+	u32 sw_rawawb_slope_ydis_2;		//YUV_DETC_SLOPE_YDIS_2
+	u32 sw_rawawb_b_ydis_2;			//YUV_DETC_B_YDIS_2
+	u32 sw_rawawb_b_uv_3;			//YUV_DETC_B_UV_3
+	u32 sw_rawawb_slope_vtcuv_3;		//YUV_DETC_SLOPE_VTCUV_3
+	u32 sw_rawawb_inv_dslope_3;		//YUV_DETC_INV_DSLOPE_3
+	u32 sw_rawawb_slope_ydis_3;		//YUV_DETC_SLOPE_YDIS_3
+	u32 sw_rawawb_b_ydis_3;			//YUV_DETC_B_YDIS_3
+	u32 sw_rawawb_ref_u;			//YUV_DETC_REF_U
+	u8 sw_rawawb_ref_v_3;			//YUV_DETC_REF_V_1
+	u8 sw_rawawb_ref_v_2;			//YUV_DETC_REF_V_1
+	u8 sw_rawawb_ref_v_1;			//YUV_DETC_REF_V_1
+	u8 sw_rawawb_ref_v_0;			//YUV_DETC_REF_V_1
+	u16 sw_rawawb_dis1_0;			//YUV_DETC_DIS01_0
+	u16 sw_rawawb_dis0_0;			//YUV_DETC_DIS01_0
+	u16 sw_rawawb_dis3_0;			//YUV_DETC_DIS23_0
+	u16 sw_rawawb_dis2_0;			//YUV_DETC_DIS23_0
+	u16 sw_rawawb_dis5_0;			//YUV_DETC_DIS45_0
+	u16 sw_rawawb_dis4_0;			//YUV_DETC_DIS45_0
+	u8 sw_rawawb_th3_0;			//YUV_DETC_TH03_0
+	u8 sw_rawawb_th2_0;			//YUV_DETC_TH03_0
+	u8 sw_rawawb_th1_0;			//YUV_DETC_TH03_0
+	u8 sw_rawawb_th0_0;			//YUV_DETC_TH03_0
+	u8 sw_rawawb_th5_0;			//YUV_DETC_TH45_0
+	u8 sw_rawawb_th4_0;			//YUV_DETC_TH45_0
+	u16 sw_rawawb_dis1_1;			//YUV_DETC_DIS01_1
+	u16 sw_rawawb_dis0_1;			//YUV_DETC_DIS01_1
+	u16 sw_rawawb_dis3_1;			//YUV_DETC_DIS23_1
+	u16 sw_rawawb_dis2_1;			//YUV_DETC_DIS23_1
+	u16 sw_rawawb_dis5_1;			//YUV_DETC_DIS45_1
+	u16 sw_rawawb_dis4_1;			//YUV_DETC_DIS45_1
+	u8 sw_rawawb_th3_1;			//YUV_DETC_TH03_1
+	u8 sw_rawawb_th2_1;			//YUV_DETC_TH03_1
+	u8 sw_rawawb_th1_1;			//YUV_DETC_TH03_1
+	u8 sw_rawawb_th0_1;			//YUV_DETC_TH03_1
+	u8 sw_rawawb_th5_1;			//YUV_DETC_TH45_1
+	u8 sw_rawawb_th4_1;			//YUV_DETC_TH45_1
+	u16 sw_rawawb_dis1_2;			//YUV_DETC_DIS01_2
+	u16 sw_rawawb_dis0_2;			//YUV_DETC_DIS01_2
+	u16 sw_rawawb_dis3_2;			//YUV_DETC_DIS23_2
+	u16 sw_rawawb_dis2_2;			//YUV_DETC_DIS23_2
+	u16 sw_rawawb_dis5_2;			//YUV_DETC_DIS45_2
+	u16 sw_rawawb_dis4_2;			//YUV_DETC_DIS45_2
+	u8 sw_rawawb_th3_2;			//YUV_DETC_TH03_2
+	u8 sw_rawawb_th2_2;			//YUV_DETC_TH03_2
+	u8 sw_rawawb_th1_2;			//YUV_DETC_TH03_2
+	u8 sw_rawawb_th0_2;			//YUV_DETC_TH03_2
+	u8 sw_rawawb_th5_2;			//YUV_DETC_TH45_2
+	u8 sw_rawawb_th4_2;			//YUV_DETC_TH45_2
+	u16 sw_rawawb_dis1_3;			//YUV_DETC_DIS01_3
+	u16 sw_rawawb_dis0_3;			//YUV_DETC_DIS01_3
+	u16 sw_rawawb_dis3_3;			//YUV_DETC_DIS23_3
+	u16 sw_rawawb_dis2_3;			//YUV_DETC_DIS23_3
+	u16 sw_rawawb_dis5_3;			//YUV_DETC_DIS45_3
+	u16 sw_rawawb_dis4_3;			//YUV_DETC_DIS45_3
+	u8 sw_rawawb_th3_3;			//YUV_DETC_TH03_3
+	u8 sw_rawawb_th2_3;			//YUV_DETC_TH03_3
+	u8 sw_rawawb_th1_3;			//YUV_DETC_TH03_3
+	u8 sw_rawawb_th0_3;			//YUV_DETC_TH03_3
+	u8 sw_rawawb_th5_3;			//YUV_DETC_TH45_3
+	u8 sw_rawawb_th4_3;			//YUV_DETC_TH45_3
+	u16 sw_rawawb_wt1;			//RGB2XY_WT01
+	u16 sw_rawawb_wt0;			//RGB2XY_WT01
+	u16 sw_rawawb_wt2;			//RGB2XY_WT2
+	u16 sw_rawawb_mat0_y;			//RGB2XY_MAT0_XY
+	u16 sw_rawawb_mat0_x;			//RGB2XY_MAT0_XY
+	u16 sw_rawawb_mat1_y;			//RGB2XY_MAT1_XY
+	u16 sw_rawawb_mat1_x;			//RGB2XY_MAT1_XY
+	u16 sw_rawawb_mat2_y;			//RGB2XY_MAT2_XY
+	u16 sw_rawawb_mat2_x;			//RGB2XY_MAT2_XY
+	u16 sw_rawawb_nor_x1_0;			//XY_DETC_NOR_X_0
+	u16 sw_rawawb_nor_x0_0;			//XY_DETC_NOR_X_0
+	u16 sw_rawawb_nor_y1_0;			//XY_DETC_NOR_Y_0
+	u16 sw_rawawb_nor_y0_0;			//XY_DETC_NOR_Y_0
+	u16 sw_rawawb_big_x1_0;			//XY_DETC_BIG_X_0
+	u16 sw_rawawb_big_x0_0;			//XY_DETC_BIG_X_0
+	u16 sw_rawawb_big_y1_0;			//XY_DETC_BIG_Y_0
+	u16 sw_rawawb_big_y0_0;			//XY_DETC_BIG_Y_0
+	u16 sw_rawawb_sma_x1_0;			//XY_DETC_SMA_X_0
+	u16 sw_rawawb_sma_x0_0;			//XY_DETC_SMA_X_0
+	u16 sw_rawawb_sma_y1_0;			//XY_DETC_SMA_Y_0
+	u16 sw_rawawb_sma_y0_0;			//XY_DETC_SMA_Y_0
+	u16 sw_rawawb_nor_x1_1;			//XY_DETC_NOR_X_1
+	u16 sw_rawawb_nor_x0_1;			//XY_DETC_NOR_X_1
+	u16 sw_rawawb_nor_y1_1;			//XY_DETC_NOR_Y_1
+	u16 sw_rawawb_nor_y0_1;			//XY_DETC_NOR_Y_1
+	u16 sw_rawawb_big_x1_1;			//XY_DETC_BIG_X_1
+	u16 sw_rawawb_big_x0_1;			//XY_DETC_BIG_X_1
+	u16 sw_rawawb_big_y1_1;			//XY_DETC_BIG_Y_1
+	u16 sw_rawawb_big_y0_1;			//XY_DETC_BIG_Y_1
+	u16 sw_rawawb_sma_x1_1;			//XY_DETC_SMA_X_1
+	u16 sw_rawawb_sma_x0_1;			//XY_DETC_SMA_X_1
+	u16 sw_rawawb_sma_y1_1;			//XY_DETC_SMA_Y_1
+	u16 sw_rawawb_sma_y0_1;			//XY_DETC_SMA_Y_1
+	u16 sw_rawawb_nor_x1_2;			//XY_DETC_NOR_X_2
+	u16 sw_rawawb_nor_x0_2;			//XY_DETC_NOR_X_2
+	u16 sw_rawawb_nor_y1_2;			//XY_DETC_NOR_Y_2
+	u16 sw_rawawb_nor_y0_2;			//XY_DETC_NOR_Y_2
+	u16 sw_rawawb_big_x1_2;			//XY_DETC_BIG_X_2
+	u16 sw_rawawb_big_x0_2;			//XY_DETC_BIG_X_2
+	u16 sw_rawawb_big_y1_2;			//XY_DETC_BIG_Y_2
+	u16 sw_rawawb_big_y0_2;			//XY_DETC_BIG_Y_2
+	u16 sw_rawawb_sma_x1_2;			//XY_DETC_SMA_X_2
+	u16 sw_rawawb_sma_x0_2;			//XY_DETC_SMA_X_2
+	u16 sw_rawawb_sma_y1_2;			//XY_DETC_SMA_Y_2
+	u16 sw_rawawb_sma_y0_2;			//XY_DETC_SMA_Y_2
+	u16 sw_rawawb_nor_x1_3;			//XY_DETC_NOR_X_3
+	u16 sw_rawawb_nor_x0_3;			//XY_DETC_NOR_X_3
+	u16 sw_rawawb_nor_y1_3;			//XY_DETC_NOR_Y_3
+	u16 sw_rawawb_nor_y0_3;			//XY_DETC_NOR_Y_3
+	u16 sw_rawawb_big_x1_3;			//XY_DETC_BIG_X_3
+	u16 sw_rawawb_big_x0_3;			//XY_DETC_BIG_X_3
+	u16 sw_rawawb_big_y1_3;			//XY_DETC_BIG_Y_3
+	u16 sw_rawawb_big_y0_3;			//XY_DETC_BIG_Y_3
+	u16 sw_rawawb_sma_x1_3;			//XY_DETC_SMA_X_3
+	u16 sw_rawawb_sma_x0_3;			//XY_DETC_SMA_X_3
+	u16 sw_rawawb_sma_y1_3;			//XY_DETC_SMA_Y_3
+	u16 sw_rawawb_sma_y0_3;			//XY_DETC_SMA_Y_3
+	u16 sw_rawawb_nor_x1_4;			//XY_DETC_NOR_X_4
+	u16 sw_rawawb_nor_x0_4;			//XY_DETC_NOR_X_4
+	u16 sw_rawawb_nor_y1_4;			//XY_DETC_NOR_Y_4
+	u16 sw_rawawb_nor_y0_4;			//XY_DETC_NOR_Y_4
+	u16 sw_rawawb_big_x1_4;			//XY_DETC_BIG_X_4
+	u16 sw_rawawb_big_x0_4;			//XY_DETC_BIG_X_4
+	u16 sw_rawawb_big_y1_4;			//XY_DETC_BIG_Y_4
+	u16 sw_rawawb_big_y0_4;			//XY_DETC_BIG_Y_4
+	u16 sw_rawawb_sma_x1_4;			//XY_DETC_SMA_X_4
+	u16 sw_rawawb_sma_x0_4;			//XY_DETC_SMA_X_4
+	u16 sw_rawawb_sma_y1_4;			//XY_DETC_SMA_Y_4
+	u16 sw_rawawb_sma_y0_4;			//XY_DETC_SMA_Y_4
+	u16 sw_rawawb_nor_x1_5;			//XY_DETC_NOR_X_5
+	u16 sw_rawawb_nor_x0_5;			//XY_DETC_NOR_X_5
+	u16 sw_rawawb_nor_y1_5;			//XY_DETC_NOR_Y_5
+	u16 sw_rawawb_nor_y0_5;			//XY_DETC_NOR_Y_5
+	u16 sw_rawawb_big_x1_5;			//XY_DETC_BIG_X_5
+	u16 sw_rawawb_big_x0_5;			//XY_DETC_BIG_X_5
+	u16 sw_rawawb_big_y1_5;			//XY_DETC_BIG_Y_5
+	u16 sw_rawawb_big_y0_5;			//XY_DETC_BIG_Y_5
+	u16 sw_rawawb_sma_x1_5;			//XY_DETC_SMA_X_5
+	u16 sw_rawawb_sma_x0_5;			//XY_DETC_SMA_X_5
+	u16 sw_rawawb_sma_y1_5;			//XY_DETC_SMA_Y_5
+	u16 sw_rawawb_sma_y0_5;			//XY_DETC_SMA_Y_5
+	u16 sw_rawawb_nor_x1_6;			//XY_DETC_NOR_X_6
+	u16 sw_rawawb_nor_x0_6;			//XY_DETC_NOR_X_6
+	u16 sw_rawawb_nor_y1_6;			//XY_DETC_NOR_Y_6
+	u16 sw_rawawb_nor_y0_6;			//XY_DETC_NOR_Y_6
+	u16 sw_rawawb_big_x1_6;			//XY_DETC_BIG_X_6
+	u16 sw_rawawb_big_x0_6;			//XY_DETC_BIG_X_6
+	u16 sw_rawawb_big_y1_6;			//XY_DETC_BIG_Y_6
+	u16 sw_rawawb_big_y0_6;			//XY_DETC_BIG_Y_6
+	u16 sw_rawawb_sma_x1_6;			//XY_DETC_SMA_X_6
+	u16 sw_rawawb_sma_x0_6;			//XY_DETC_SMA_X_6
+	u16 sw_rawawb_sma_y1_6;			//XY_DETC_SMA_Y_6
+	u16 sw_rawawb_sma_y0_6;			//XY_DETC_SMA_Y_6
+	u8 sw_rawawb_multiwindow_en;		//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region6_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region6_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region6_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region5_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region5_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region5_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region4_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region4_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region4_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region3_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region3_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region3_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region2_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region2_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region2_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region1_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region1_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region1_excen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region0_domain;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region0_measen;	//MULTIWINDOW_EXC_CTRL
+	u8 sw_rawawb_exc_wp_region0_excen;	//MULTIWINDOW_EXC_CTRL
+	u16 sw_rawawb_multiwindow0_v_offs;	//MULTIWINDOW0_OFFS
+	u16 sw_rawawb_multiwindow0_h_offs;	//MULTIWINDOW0_OFFS
+	u16 sw_rawawb_multiwindow0_v_size;	//MULTIWINDOW0_SIZE
+	u16 sw_rawawb_multiwindow0_h_size;	//MULTIWINDOW0_SIZE
+	u16 sw_rawawb_multiwindow1_v_offs;	//MULTIWINDOW1_OFFS
+	u16 sw_rawawb_multiwindow1_h_offs;	//MULTIWINDOW1_OFFS
+	u16 sw_rawawb_multiwindow1_v_size;	//MULTIWINDOW1_SIZE
+	u16 sw_rawawb_multiwindow1_h_size;	//MULTIWINDOW1_SIZE
+	u16 sw_rawawb_multiwindow2_v_offs;	//MULTIWINDOW2_OFFS
+	u16 sw_rawawb_multiwindow2_h_offs;	//MULTIWINDOW2_OFFS
+	u16 sw_rawawb_multiwindow2_v_size;	//MULTIWINDOW2_SIZE
+	u16 sw_rawawb_multiwindow2_h_size;	//MULTIWINDOW2_SIZE
+	u16 sw_rawawb_multiwindow3_v_offs;	//MULTIWINDOW3_OFFS
+	u16 sw_rawawb_multiwindow3_h_offs;	//MULTIWINDOW3_OFFS
+	u16 sw_rawawb_multiwindow3_v_size;	//MULTIWINDOW3_SIZE
+	u16 sw_rawawb_multiwindow3_h_size;	//MULTIWINDOW3_SIZE
+	u16 sw_rawawb_multiwindow4_v_offs;	//MULTIWINDOW4_OFFS
+	u16 sw_rawawb_multiwindow4_h_offs;	//MULTIWINDOW4_OFFS
+	u16 sw_rawawb_multiwindow4_v_size;	//MULTIWINDOW4_SIZE
+	u16 sw_rawawb_multiwindow4_h_size;	//MULTIWINDOW4_SIZE
+	u16 sw_rawawb_multiwindow5_v_offs;	//MULTIWINDOW5_OFFS
+	u16 sw_rawawb_multiwindow5_h_offs;	//MULTIWINDOW5_OFFS
+	u16 sw_rawawb_multiwindow5_v_size;	//MULTIWINDOW5_SIZE
+	u16 sw_rawawb_multiwindow5_h_size;	//MULTIWINDOW5_SIZE
+	u16 sw_rawawb_multiwindow6_v_offs;	//MULTIWINDOW6_OFFS
+	u16 sw_rawawb_multiwindow6_h_offs;	//MULTIWINDOW6_OFFS
+	u16 sw_rawawb_multiwindow6_v_size;	//MULTIWINDOW6_SIZE
+	u16 sw_rawawb_multiwindow6_h_size;	//MULTIWINDOW6_SIZE
+	u16 sw_rawawb_multiwindow7_v_offs;	//MULTIWINDOW7_OFFS
+	u16 sw_rawawb_multiwindow7_h_offs;	//MULTIWINDOW7_OFFS
+	u16 sw_rawawb_multiwindow7_v_size;	//MULTIWINDOW7_SIZE
+	u16 sw_rawawb_multiwindow7_h_size;	//MULTIWINDOW7_SIZE
+	u16 sw_rawawb_exc_wp_region0_xu1;	//EXC_WP_REGION0_XU
+	u16 sw_rawawb_exc_wp_region0_xu0;	//EXC_WP_REGION0_XU
+	u16 sw_rawawb_exc_wp_region0_yv1;	//EXC_WP_REGION0_YV
+	u16 sw_rawawb_exc_wp_region0_yv0;	//EXC_WP_REGION0_YV
+	u16 sw_rawawb_exc_wp_region1_xu1;	//EXC_WP_REGION1_XU
+	u16 sw_rawawb_exc_wp_region1_xu0;	//EXC_WP_REGION1_XU
+	u16 sw_rawawb_exc_wp_region1_yv1;	//EXC_WP_REGION1_YV
+	u16 sw_rawawb_exc_wp_region1_yv0;	//EXC_WP_REGION1_YV
+	u16 sw_rawawb_exc_wp_region2_xu1;	//EXC_WP_REGION2_XU
+	u16 sw_rawawb_exc_wp_region2_xu0;	//EXC_WP_REGION2_XU
+	u16 sw_rawawb_exc_wp_region2_yv1;	//EXC_WP_REGION2_YV
+	u16 sw_rawawb_exc_wp_region2_yv0;	//EXC_WP_REGION2_YV
+	u16 sw_rawawb_exc_wp_region3_xu1;	//EXC_WP_REGION3_XU
+	u16 sw_rawawb_exc_wp_region3_xu0;	//EXC_WP_REGION3_XU
+	u16 sw_rawawb_exc_wp_region3_yv1;	//EXC_WP_REGION3_YV
+	u16 sw_rawawb_exc_wp_region3_yv0;	//EXC_WP_REGION3_YV
+	u16 sw_rawawb_exc_wp_region4_xu1;	//EXC_WP_REGION4_XU
+	u16 sw_rawawb_exc_wp_region4_xu0;	//EXC_WP_REGION4_XU
+	u16 sw_rawawb_exc_wp_region4_yv1;	//EXC_WP_REGION4_YV
+	u16 sw_rawawb_exc_wp_region4_yv0;	//EXC_WP_REGION4_YV
+	u16 sw_rawawb_exc_wp_region5_xu1;	//EXC_WP_REGION5_XU
+	u16 sw_rawawb_exc_wp_region5_xu0;	//EXC_WP_REGION5_XU
+	u16 sw_rawawb_exc_wp_region5_yv1;	//EXC_WP_REGION5_YV
+	u16 sw_rawawb_exc_wp_region5_yv0;	//EXC_WP_REGION5_YV
+	u16 sw_rawawb_exc_wp_region6_xu1;	//EXC_WP_REGION6_XU
+	u16 sw_rawawb_exc_wp_region6_xu0;	//EXC_WP_REGION6_XU
+	u16 sw_rawawb_exc_wp_region6_yv1;	//EXC_WP_REGION6_YV
+	u16 sw_rawawb_exc_wp_region6_yv0;	//EXC_WP_REGION6_YV
+} __attribute__ ((packed));
+
+struct isp2x_rawaebig_meas_cfg {
+	u8 rawae_sel;
+	u8 wnd_num;
+	u8 subwin_en[ISP2X_RAWAEBIG_SUBWIN_NUM];
+	struct isp2x_window win;
+	struct isp2x_window subwin[ISP2X_RAWAEBIG_SUBWIN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawaelite_meas_cfg {
+	u8 rawae_sel;
+	u8 wnd_num;
+	struct isp2x_window win;
+} __attribute__ ((packed));
+
+struct isp2x_yuvae_meas_cfg {
+	u8 ysel;
+	u8 wnd_num;
+	u8 subwin_en[ISP2X_YUVAE_SUBWIN_NUM];
+	struct isp2x_window win;
+	struct isp2x_window subwin[ISP2X_YUVAE_SUBWIN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawaf_meas_cfg {
+	u8 rawaf_sel;
+	u8 num_afm_win;
+	u8 gaus_en;
+	u8 gamma_en;
+	struct isp2x_window win[ISP2X_RAWAF_WIN_NUM];
+	u8 line_en[ISP2X_RAWAF_LINE_NUM];
+	u8 line_num[ISP2X_RAWAF_LINE_NUM];
+	u8 gaus_coe_h2;
+	u8 gaus_coe_h1;
+	u8 gaus_coe_h0;
+	u16 afm_thres;
+	u8 lum_var_shift[ISP2X_RAWAF_WIN_NUM];
+	u8 afm_var_shift[ISP2X_RAWAF_WIN_NUM];
+	u16 gamma_y[ISP2X_RAWAF_GAMMA_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_siaf_win_cfg {
+	u8 sum_shift;
+	u8 lum_shift;
+	struct isp2x_window win;
+} __attribute__ ((packed));
+
+struct isp2x_siaf_cfg {
+	u8 num_afm_win;
+	u32 thres;
+	struct isp2x_siaf_win_cfg afm_win[ISP2X_AFM_MAX_WINDOWS];
+} __attribute__ ((packed));
+
+struct isp2x_rawhistbig_cfg {
+	u8 wnd_num;
+	u8 data_sel;
+	u8 waterline;
+	u8 mode;
+	u8 stepsize;
+	u8 off;
+	u8 bcc;
+	u8 gcc;
+	u8 rcc;
+	struct isp2x_window win;
+	u8 weight[ISP2X_RAWHISTBIG_SUBWIN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawhistlite_cfg {
+	u8 data_sel;
+	u8 waterline;
+	u8 mode;
+	u8 stepsize;
+	u8 off;
+	u8 bcc;
+	u8 gcc;
+	u8 rcc;
+	struct isp2x_window win;
+	u8 weight[ISP2X_RAWHISTLITE_SUBWIN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_sihst_win_cfg {
+	u8 data_sel;
+	u8 waterline;
+	u8 auto_stop;
+	u8 mode;
+	u8 stepsize;
+	struct isp2x_window win;
+} __attribute__ ((packed));
+
+struct isp2x_sihst_cfg {
+	u8 wnd_num;
+	struct isp2x_sihst_win_cfg win_cfg[ISP2X_SIHIST_WIN_NUM];
+	u8 hist_weight[ISP2X_HIST_WEIGHT_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_isp_other_cfg {
+	struct isp2x_bls_cfg bls_cfg;
+	struct isp2x_dpcc_cfg dpcc_cfg;
+	struct isp2x_hdrmge_cfg hdrmge_cfg;
+	struct isp2x_rawnr_cfg rawnr_cfg;
+	struct isp2x_lsc_cfg lsc_cfg;
+	struct isp2x_awb_gain_cfg awb_gain_cfg;
+	//struct isp2x_goc_cfg goc_cfg;
+	struct isp2x_gic_cfg gic_cfg;
+	struct isp2x_debayer_cfg debayer_cfg;
+	struct isp2x_ccm_cfg ccm_cfg;
+	struct isp2x_gammaout_cfg gammaout_cfg;
+	struct isp2x_wdr_cfg wdr_cfg;
+	struct isp2x_cproc_cfg cproc_cfg;
+	struct isp2x_ie_cfg ie_cfg;
+	struct isp2x_rkiesharp_cfg rkiesharp_cfg;
+	struct isp2x_superimp_cfg superimp_cfg;
+	struct isp2x_sdg_cfg sdg_cfg;
+	struct isp2x_bdm_config bdm_cfg;
+	struct isp2x_hdrtmo_cfg hdrtmo_cfg;
+	struct isp2x_dhaz_cfg dhaz_cfg;
+	struct isp2x_gain_cfg gain_cfg;
+	struct isp2x_3dlut_cfg isp3dlut_cfg;
+	struct isp2x_ldch_cfg ldch_cfg;
+} __attribute__ ((packed));
+
+struct isp2x_isp_meas_cfg {
+	struct isp2x_siawb_meas_cfg siawb;
+	struct isp2x_rawawb_meas_cfg rawawb;
+	struct isp2x_rawaelite_meas_cfg rawae0;
+	struct isp2x_rawaebig_meas_cfg rawae1;
+	struct isp2x_rawaebig_meas_cfg rawae2;
+	struct isp2x_rawaebig_meas_cfg rawae3;
+	struct isp2x_yuvae_meas_cfg yuvae;
+	struct isp2x_rawaf_meas_cfg rawaf;
+	struct isp2x_siaf_cfg siaf;
+	struct isp2x_rawhistlite_cfg rawhist0;
+	struct isp2x_rawhistbig_cfg rawhist1;
+	struct isp2x_rawhistbig_cfg rawhist2;
+	struct isp2x_rawhistbig_cfg rawhist3;
+	struct isp2x_sihst_cfg sihst;
+} __attribute__ ((packed));
+
+struct sensor_exposure_s {
+	u32 fine_integration_time;
+	u32 coarse_integration_time;
+	u32 analog_gain_code_global;
+	u32 digital_gain_global;
+	u32 isp_digital_gain;
+} __attribute__ ((packed));
+
+struct sensor_exposure_cfg {
+	struct sensor_exposure_s linear_exp;
+	struct sensor_exposure_s hdr_exp[3];
+} __attribute__ ((packed));
+
+struct isp2x_isp_params_cfg {
+	u64 module_en_update;
+	u64 module_ens;
+	u64 module_cfg_update;
+
+	u32 frame_id;
+	struct isp2x_isp_meas_cfg meas;
+	struct isp2x_isp_other_cfg others;
+	struct sensor_exposure_cfg exposure;
+} __attribute__ ((packed));
+
+struct isp2x_siawb_meas {
+	u32 cnt;
+	u8 mean_y_or_g;
+	u8 mean_cb_or_b;
+	u8 mean_cr_or_r;
+} __attribute__ ((packed));
+
+struct isp2x_siawb_stat {
+	struct isp2x_siawb_meas awb_mean[ISP2X_AWB_MAX_GRID];
+} __attribute__ ((packed));
+
+struct isp2x_rawawb_ramdata {
+	u32 wp;
+	u32 r;
+	u32 g;
+	u32 b;
+};
+
+struct isp2x_rawawb_meas_stat {
+	u32 ro_rawawb_sum_r_nor[ISP2X_RAWAWB_SUM_NUM];		//SUM_R_NOR_0
+	u32 ro_rawawb_sum_g_nor[ISP2X_RAWAWB_SUM_NUM];		//SUM_G_NOR_0
+	u32 ro_rawawb_sum_b_nor[ISP2X_RAWAWB_SUM_NUM];		//SUM_B_NOR_0
+	u32 ro_rawawb_wp_num_nor[ISP2X_RAWAWB_SUM_NUM];		//WP_NUM_NOR_0
+	u32 ro_rawawb_sum_r_big[ISP2X_RAWAWB_SUM_NUM];		//SUM_R_BIG_0
+	u32 ro_rawawb_sum_g_big[ISP2X_RAWAWB_SUM_NUM];		//SUM_G_BIG_0
+	u32 ro_rawawb_sum_b_big[ISP2X_RAWAWB_SUM_NUM];		//SUM_B_BIG_0
+	u32 ro_rawawb_wp_num_big[ISP2X_RAWAWB_SUM_NUM];		//WP_NUM_BIG_0
+	u32 ro_rawawb_sum_r_sma[ISP2X_RAWAWB_SUM_NUM];		//SUM_R_SMA_0
+	u32 ro_rawawb_sum_g_sma[ISP2X_RAWAWB_SUM_NUM];		//SUM_G_SMA_0
+	u32 ro_rawawb_sum_b_sma[ISP2X_RAWAWB_SUM_NUM];		//SUM_B_SMA_0
+	u32 ro_rawawb_wp_num_sma[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_sum_r_nor_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_R_NOR_MULTIWINDOW_0
+	u32 ro_sum_g_nor_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_G_NOR_MULTIWINDOW_0
+	u32 ro_sum_b_nor_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_B_NOR_MULTIWINDOW_0
+	u32 ro_wp_nm_nor_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//WP_NM_NOR_MULTIWINDOW_0
+	u32 ro_sum_r_big_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_R_BIG_MULTIWINDOW_0
+	u32 ro_sum_g_big_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_G_BIG_MULTIWINDOW_0
+	u32 ro_sum_b_big_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_B_BIG_MULTIWINDOW_0
+	u32 ro_wp_nm_big_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//WP_NM_BIG_MULTIWINDOW_0
+	u32 ro_sum_r_sma_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_R_SMA_MULTIWINDOW_0
+	u32 ro_sum_g_sma_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_G_SMA_MULTIWINDOW_0
+	u32 ro_sum_b_sma_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//SUM_B_SMA_MULTIWINDOW_0
+	u32 ro_wp_nm_sma_multiwindow[ISP2X_RAWAWB_MULWD_NUM];	//WP_NM_SMA_MULTIWINDOW_0
+	u32 ro_sum_r_exc[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_sum_g_exc[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_sum_b_exc[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_wp_nm_exc[ISP2X_RAWAWB_SUM_NUM];
+	struct isp2x_rawawb_ramdata ramdata[ISP2X_RAWAWB_RAMDATA_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawae_meas_data {
+	u16 channelr_xy;
+	u16 channelb_xy;
+	u16 channelg_xy;
+};
+
+struct isp2x_rawaebig_stat {
+	u32 sumr[ISP2X_RAWAEBIG_SUBWIN_NUM];
+	u32 sumg[ISP2X_RAWAEBIG_SUBWIN_NUM];
+	u32 sumb[ISP2X_RAWAEBIG_SUBWIN_NUM];
+	struct isp2x_rawae_meas_data data[ISP2X_RAWAEBIG_MEAN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawaelite_stat {
+	struct isp2x_rawae_meas_data data[ISP2X_RAWAELITE_MEAN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_yuvae_stat {
+	u32 ro_yuvae_sumy[ISP2X_YUVAE_SUBWIN_NUM];
+	u8 mean[ISP2X_YUVAE_MEAN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_rawaf_stat {
+	u32 int_state;
+	u32 afm_sum[ISP2X_RAWAF_WIN_NUM];
+	u32 afm_lum[ISP2X_RAWAF_WIN_NUM];
+	u32 ramdata[ISP2X_RAWAF_SUMDATA_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_siaf_meas_val {
+	u32 sum;
+	u32 lum;
+} __attribute__ ((packed));
+
+struct isp2x_siaf_stat {
+	struct isp2x_siaf_meas_val win[ISP2X_AFM_MAX_WINDOWS];
+} __attribute__ ((packed));
+
+struct isp2x_rawhistbig_stat {
+	u32 hist_bin[ISP2X_HIST_BIN_N_MAX];
+} __attribute__ ((packed));
+
+struct isp2x_rawhistlite_stat {
+	u32 hist_bin[ISP2X_HIST_BIN_N_MAX];
+} __attribute__ ((packed));
+
+struct isp2x_sihst_win_stat {
+	u32 hist_bins[ISP2X_SIHIST_BIN_N_MAX];
+} __attribute__ ((packed));
+
+struct isp2x_sihst_stat {
+	struct isp2x_sihst_win_stat win_stat[ISP2X_SIHIST_WIN_NUM];
+} __attribute__ ((packed));
+
+struct isp2x_stat {
+	struct isp2x_siawb_stat siawb;
+	struct isp2x_rawawb_meas_stat rawawb;
+	struct isp2x_rawaelite_stat rawae0;
+	struct isp2x_rawaebig_stat rawae1;
+	struct isp2x_rawaebig_stat rawae2;
+	struct isp2x_rawaebig_stat rawae3;
+	struct isp2x_yuvae_stat yuvae;
+	struct isp2x_rawaf_stat rawaf;
+	struct isp2x_siaf_stat siaf;
+	struct isp2x_rawhistlite_stat rawhist0;
+	struct isp2x_rawhistbig_stat rawhist1;
+	struct isp2x_rawhistbig_stat rawhist2;
+	struct isp2x_rawhistbig_stat rawhist3;
+	struct isp2x_sihst_stat sihst;
+
+	struct isp2x_bls_stat bls;
+	struct isp2x_hdrtmo_stat hdrtmo;
+	struct isp2x_dhaz_stat dhaz;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_isp2x_stat_buffer - Rockchip ISP2 Statistics Meta Data
+ *
+ * @meas_type: measurement types (CIFISP_STAT_ definitions)
+ * @frame_id: frame ID for sync
+ * @params: statistics data
+ */
+struct rkisp_isp2x_stat_buffer {
+	unsigned int meas_type;
+	unsigned int frame_id;
+	struct isp2x_stat params;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_mipi_luma - statistics mipi y statistic
+ *
+ * @exp_mean: Mean luminance value of block xx
+ *
+ * Image is divided into 5x5 blocks.
+ */
+struct rkisp_mipi_luma {
+	unsigned int exp_mean[ISP2X_MIPI_LUMA_MEAN_MAX];
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_isp2x_luma_buffer - Rockchip ISP1 Statistics Mipi Luma
+ *
+ * @meas_type: measurement types (CIFISP_STAT_ definitions)
+ * @frame_id: frame ID for sync
+ * @params: statistics data
+ */
+struct rkisp_isp2x_luma_buffer {
+	unsigned int meas_type;
+	unsigned int frame_id;
+	struct rkisp_mipi_luma luma[ISP2X_MIPI_RAW_MAX];
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_thunderboot_video_buf
+ */
+struct rkisp_thunderboot_video_buf {
+	u32 index;
+	u32 frame_id;
+	u32 timestamp;
+	u32 time_reg;
+	u32 gain_reg;
+	u32 bufaddr;
+	u32 bufsize;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_thunderboot_resmem_head
+ */
+struct rkisp_thunderboot_resmem_head {
+	u16 enable;
+	u16 complete;
+	u16 frm_total;
+	u16 hdr_mode;
+	u16 width;
+	u16 height;
+	u32 bus_fmt;
+
+	struct rkisp_thunderboot_video_buf l_buf[ISP2X_THUNDERBOOT_VIDEO_BUF_NUM];
+	struct rkisp_thunderboot_video_buf m_buf[ISP2X_THUNDERBOOT_VIDEO_BUF_NUM];
+	struct rkisp_thunderboot_video_buf s_buf[ISP2X_THUNDERBOOT_VIDEO_BUF_NUM];
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_thunderboot_resmem - shared buffer for thunderboot with risc-v side
+ */
+struct rkisp_thunderboot_resmem {
+	u32 resmem_padr;
+	u32 resmem_size;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_thunderboot_shmem
+ */
+struct rkisp_thunderboot_shmem {
+	u32 shm_start;
+	u32 shm_size;
+	s32 shm_fd;
+} __attribute__ ((packed));
+
+#endif /* _UAPI_RKISP2_CONFIG_H */
diff --git a/include/uapi/linux/rkisp21-config.h b/include/uapi/linux/rkisp21-config.h
new file mode 100644
index 000000000..203022b62
--- /dev/null
+++ b/include/uapi/linux/rkisp21-config.h
@@ -0,0 +1,804 @@
+/* SPDX-License-Identifier: (GPL-2.0+ WITH Linux-syscall-note) OR MIT
+ *
+ * Rockchip isp2 driver
+ * Copyright (C) 2020 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKISP21_CONFIG_H
+#define _UAPI_RKISP21_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+#include <linux/rkisp2-config.h>
+
+#define ISP2X_MODULE_BAYNR			BIT_ULL(36)
+#define ISP2X_MODULE_BAY3D			BIT_ULL(37)
+#define ISP2X_MODULE_YNR			BIT_ULL(38)
+#define ISP2X_MODULE_CNR			BIT_ULL(39)
+#define ISP2X_MODULE_SHARP			BIT_ULL(40)
+#define ISP2X_MODULE_DRC			BIT_ULL(41)
+#define ISP2X_MODULE_CSM			BIT_ULL(43)
+
+#define ISP21_DHAZ_ENH_CURVE_NUM		17
+#define ISP21_DHAZ_HIST_IIR_NUM			64
+#define ISP21_RAWAWB_HSTBIN_NUM			8
+#define ISP21_RAWAWB_WEIGHT_NUM			225
+#define ISP21_DRC_Y_NUM				17
+#define ISP21_YNR_XY_NUM			17
+#define ISP21_BAYNR_XY_NUM			16
+#define ISP21_BAY3D_XY_NUM			16
+#define ISP21_SHARP_X_NUM			7
+#define ISP21_SHARP_Y_NUM			8
+#define ISP21_CSM_COEFF_NUM			9
+
+struct isp21_csm_cfg {
+	u8 csm_full_range;
+	u16 csm_y_offset;
+	u16 csm_c_offset;
+
+	u32 csm_coeff[ISP21_CSM_COEFF_NUM];
+} __attribute__ ((packed));
+
+struct isp21_bls_cfg {
+	u8 enable_auto;
+	u8 en_windows;
+	u8 bls1_en;
+	struct isp2x_window bls_window1;
+	struct isp2x_window bls_window2;
+	u8 bls_samples;
+	struct isp2x_bls_fixed_val fixed_val;
+	struct isp2x_bls_fixed_val bls1_val;
+} __attribute__ ((packed));
+
+struct isp21_awb_gain_cfg {
+	u16 gain0_red;
+	u16 gain0_green_r;
+	u16 gain0_blue;
+	u16 gain0_green_b;
+	u16 gain1_red;
+	u16 gain1_green_r;
+	u16 gain1_blue;
+	u16 gain1_green_b;
+	u16 gain2_red;
+	u16 gain2_green_r;
+	u16 gain2_blue;
+	u16 gain2_green_b;
+} __attribute__ ((packed));
+
+struct isp21_gic_cfg {
+	u16 regmingradthrdark2;
+	u16 regmingradthrdark1;
+	u16 regminbusythre;
+
+	u16 regdarkthre;
+	u16 regmaxcorvboth;
+	u16 regdarktthrehi;
+
+	u8 regkgrad2dark;
+	u8 regkgrad1dark;
+	u8 regstrengthglobal_fix;
+	u8 regdarkthrestep;
+	u8 regkgrad2;
+	u8 regkgrad1;
+	u8 reggbthre;
+
+	u16 regmaxcorv;
+	u16 regmingradthr2;
+	u16 regmingradthr1;
+
+	u8 gr_ratio;
+	u8 noise_scale;
+	u16 noise_base;
+	u16 diff_clip;
+
+	u16 sigma_y[ISP2X_GIC_SIGMA_Y_NUM];
+} __attribute__ ((packed));
+
+struct isp21_baynr_cfg {
+	u8 sw_baynr_gauss_en;
+	u8 sw_baynr_log_bypass;
+	u16 sw_baynr_dgain1;
+	u16 sw_baynr_dgain0;
+	u16 sw_baynr_dgain2;
+	u16 sw_baynr_pix_diff;
+	u16 sw_baynr_diff_thld;
+	u16 sw_baynr_softthld;
+	u16 sw_bltflt_streng;
+	u16 sw_baynr_reg_w1;
+	u16 sw_sigma_x[ISP21_BAYNR_XY_NUM];
+	u16 sw_sigma_y[ISP21_BAYNR_XY_NUM];
+	u16 weit_d2;
+	u16 weit_d1;
+	u16 weit_d0;
+} __attribute__ ((packed));
+
+struct isp21_bay3d_cfg {
+	u8 sw_bay3d_exp_sel;
+	u8 sw_bay3d_bypass_en;
+	u8 sw_bay3d_pk_en;
+	u16 sw_bay3d_softwgt;
+	u16 sw_bay3d_sigratio;
+	u32 sw_bay3d_glbpk2;
+	u16 sw_bay3d_exp_str;
+	u16 sw_bay3d_str;
+	u16 sw_bay3d_wgtlmt_h;
+	u16 sw_bay3d_wgtlmt_l;
+	u16 sw_bay3d_sig_x[ISP21_BAY3D_XY_NUM];
+	u16 sw_bay3d_sig_y[ISP21_BAY3D_XY_NUM];
+} __attribute__ ((packed));
+
+struct isp21_ynr_cfg {
+	u8 sw_ynr_thumb_mix_cur_en;
+	u8 sw_ynr_global_gain_alpha;
+	u8 sw_ynr_global_gain;
+	u8 sw_ynr_flt1x1_bypass_sel;
+	u8 sw_ynr_sft5x5_bypass;
+	u8 sw_ynr_flt1x1_bypass;
+	u8 sw_ynr_lgft3x3_bypass;
+	u8 sw_ynr_lbft5x5_bypass;
+	u8 sw_ynr_bft3x3_bypass;
+
+	u16 sw_ynr_rnr_max_r;
+
+	u16 sw_ynr_low_bf_inv1;
+	u16 sw_ynr_low_bf_inv0;
+
+	u16 sw_ynr_low_peak_supress;
+	u16 sw_ynr_low_thred_adj;
+
+	u16 sw_ynr_low_dist_adj;
+	u16 sw_ynr_low_edge_adj_thresh;
+
+	u16 sw_ynr_low_bi_weight;
+	u16 sw_ynr_low_weight;
+	u16 sw_ynr_low_center_weight;
+	u16 sw_ynr_hi_min_adj;
+	u16 sw_ynr_high_thred_adj;
+	u8 sw_ynr_high_retain_weight;
+	u8 sw_ynr_hi_edge_thed;
+	u8 sw_ynr_base_filter_weight2;
+	u8 sw_ynr_base_filter_weight1;
+	u8 sw_ynr_base_filter_weight0;
+	u16 sw_ynr_low_gauss1_coeff2;
+	u16 sw_ynr_low_gauss1_coeff1;
+	u16 sw_ynr_low_gauss1_coeff0;
+	u16 sw_ynr_low_gauss2_coeff2;
+	u16 sw_ynr_low_gauss2_coeff1;
+	u16 sw_ynr_low_gauss2_coeff0;
+	u8 sw_ynr_direction_weight3;
+	u8 sw_ynr_direction_weight2;
+	u8 sw_ynr_direction_weight1;
+	u8 sw_ynr_direction_weight0;
+	u8 sw_ynr_direction_weight7;
+	u8 sw_ynr_direction_weight6;
+	u8 sw_ynr_direction_weight5;
+	u8 sw_ynr_direction_weight4;
+	u16 sw_ynr_luma_points_x[ISP21_YNR_XY_NUM];
+	u16 sw_ynr_lsgm_y[ISP21_YNR_XY_NUM];
+	u16 sw_ynr_hsgm_y[ISP21_YNR_XY_NUM];
+	u8 sw_ynr_rnr_strength3[ISP21_YNR_XY_NUM];
+} __attribute__ ((packed));
+
+struct isp21_cnr_cfg {
+	u8 sw_cnr_thumb_mix_cur_en;
+	u8 sw_cnr_lq_bila_bypass;
+	u8 sw_cnr_hq_bila_bypass;
+	u8 sw_cnr_exgain_bypass;
+	u8 sw_cnr_exgain_mux;
+	u8 sw_cnr_gain_iso;
+	u8 sw_cnr_gain_offset;
+	u8 sw_cnr_gain_1sigma;
+	u8 sw_cnr_gain_uvgain1;
+	u8 sw_cnr_gain_uvgain0;
+	u8 sw_cnr_lmed3_alpha;
+	u8 sw_cnr_lbf5_gain_y;
+	u8 sw_cnr_lbf5_gain_c;
+	u8 sw_cnr_lbf5_weit_d3;
+	u8 sw_cnr_lbf5_weit_d2;
+	u8 sw_cnr_lbf5_weit_d1;
+	u8 sw_cnr_lbf5_weit_d0;
+	u8 sw_cnr_lbf5_weit_d4;
+	u8 sw_cnr_hmed3_alpha;
+	u16 sw_cnr_hbf5_weit_src;
+	u16 sw_cnr_hbf5_min_wgt;
+	u16 sw_cnr_hbf5_sigma;
+	u16 sw_cnr_lbf5_weit_src;
+	u16 sw_cnr_lbf3_sigma;
+} __attribute__ ((packed));
+
+struct isp21_sharp_cfg {
+	u8 sw_sharp_bypass;
+	u8 sw_sharp_sharp_ratio;
+	u8 sw_sharp_bf_ratio;
+	u8 sw_sharp_gaus_ratio;
+	u8 sw_sharp_pbf_ratio;
+	u8 sw_sharp_luma_dx[ISP21_SHARP_X_NUM];
+	u16 sw_sharp_pbf_sigma_inv[ISP21_SHARP_Y_NUM];
+	u16 sw_sharp_bf_sigma_inv[ISP21_SHARP_Y_NUM];
+	u8 sw_sharp_bf_sigma_shift;
+	u8 sw_sharp_pbf_sigma_shift;
+	u16 sw_sharp_ehf_th[ISP21_SHARP_Y_NUM];
+	u16 sw_sharp_clip_hf[ISP21_SHARP_Y_NUM];
+	u8 sw_sharp_pbf_coef_2;
+	u8 sw_sharp_pbf_coef_1;
+	u8 sw_sharp_pbf_coef_0;
+	u8 sw_sharp_bf_coef_2;
+	u8 sw_sharp_bf_coef_1;
+	u8 sw_sharp_bf_coef_0;
+	u8 sw_sharp_gaus_coef_2;
+	u8 sw_sharp_gaus_coef_1;
+	u8 sw_sharp_gaus_coef_0;
+} __attribute__ ((packed));
+
+struct isp21_ccm_cfg {
+	u8 highy_adjust_dis;
+	u8 bound_bit;
+
+	s16 coeff0_r;
+	s16 coeff1_r;
+	s16 coeff2_r;
+	s16 offset_r;
+
+	s16 coeff0_g;
+	s16 coeff1_g;
+	s16 coeff2_g;
+	s16 offset_g;
+
+	s16 coeff0_b;
+	s16 coeff1_b;
+	s16 coeff2_b;
+	s16 offset_b;
+
+	u16 coeff0_y;
+	u16 coeff1_y;
+	u16 coeff2_y;
+
+	u16 alp_y[ISP21_DHAZ_ENH_CURVE_NUM];
+} __attribute__ ((packed));
+
+struct isp21_dhaz_cfg {
+	u8 enhance_en;
+	u8 air_lc_en;
+	u8 hpara_en;
+	u8 hist_en;
+	u8 dc_en;
+
+	u8 yblk_th;
+	u8 yhist_th;
+	u8 dc_max_th;
+	u8 dc_min_th;
+
+	u16 wt_max;
+	u8 bright_max;
+	u8 bright_min;
+
+	u8 tmax_base;
+	u8 dark_th;
+	u8 air_max;
+	u8 air_min;
+
+	u16 tmax_max;
+	u16 tmax_off;
+
+	u8 hist_k;
+	u8 hist_th_off;
+	u16 hist_min;
+
+	u16 hist_gratio;
+	u16 hist_scale;
+
+	u16 enhance_value;
+	u16 enhance_chroma;
+
+	u16 iir_wt_sigma;
+	u16 iir_sigma;
+	u16 stab_fnum;
+
+	u16 iir_tmax_sigma;
+	u16 iir_air_sigma;
+	u8 iir_pre_wet;
+
+	u16 cfg_wt;
+	u16 cfg_air;
+	u16 cfg_alpha;
+
+	u16 cfg_gratio;
+	u16 cfg_tmax;
+
+	u16 range_sima;
+	u8 space_sigma_pre;
+	u8 space_sigma_cur;
+
+	u16 dc_weitcur;
+	u16 bf_weight;
+
+	u16 enh_curve[ISP21_DHAZ_ENH_CURVE_NUM];
+
+	u8 gaus_h2;
+	u8 gaus_h1;
+	u8 gaus_h0;
+} __attribute__ ((packed));
+
+struct isp21_dhaz_stat {
+	u16 dhaz_adp_air_base;
+	u16 dhaz_adp_wt;
+
+	u16 dhaz_adp_gratio;
+	u16 dhaz_adp_tmax;
+
+	u16 h_rgb_iir[ISP21_DHAZ_HIST_IIR_NUM];
+} __attribute__ ((packed));
+
+struct isp21_drc_cfg {
+	u8 sw_drc_offset_pow2;
+	u16 sw_drc_compres_scl;
+	u16 sw_drc_position;
+	u16 sw_drc_delta_scalein;
+	u16 sw_drc_hpdetail_ratio;
+	u16 sw_drc_lpdetail_ratio;
+	u8 sw_drc_weicur_pix;
+	u8 sw_drc_weipre_frame;
+	u16 sw_drc_force_sgm_inv0;
+	u8 sw_drc_motion_scl;
+	u8 sw_drc_edge_scl;
+	u16 sw_drc_space_sgm_inv1;
+	u16 sw_drc_space_sgm_inv0;
+	u16 sw_drc_range_sgm_inv1;
+	u16 sw_drc_range_sgm_inv0;
+	u8 sw_drc_weig_maxl;
+	u8 sw_drc_weig_bilat;
+	u16 sw_drc_gain_y[ISP21_DRC_Y_NUM];
+	u16 sw_drc_compres_y[ISP21_DRC_Y_NUM];
+	u16 sw_drc_scale_y[ISP21_DRC_Y_NUM];
+	u16 sw_drc_iir_weight;
+	u16 sw_drc_min_ogain;
+} __attribute__ ((packed));
+
+struct isp21_rawawb_meas_cfg {
+	u8 rawawb_sel;
+	u8 sw_rawawb_xy_en0;
+	u8 sw_rawawb_uv_en0;
+	u8 sw_rawawb_xy_en1;
+	u8 sw_rawawb_uv_en1;
+	u8 sw_rawawb_3dyuv_en0;
+	u8 sw_rawawb_3dyuv_en1;
+	u8 sw_rawawb_wp_blk_wei_en0;
+	u8 sw_rawawb_wp_blk_wei_en1;
+	u8 sw_rawawb_wp_luma_wei_en0;
+	u8 sw_rawawb_wp_luma_wei_en1;
+	u8 sw_rawlsc_bypass_en;
+	u8 sw_rawawb_blk_measure_enable;
+	u8 sw_rawawb_blk_measure_mode;
+	u8 sw_rawawb_blk_measure_xytype;
+	u8 sw_rawawb_blk_measure_illu_idx;
+	u8 sw_rawawb_wp_hist_xytype;
+	u8 sw_rawawb_light_num;
+	u8 sw_rawawb_wind_size;
+	u8 sw_rawawb_r_max;
+	u8 sw_rawawb_g_max;
+	u8 sw_rawawb_b_max;
+	u8 sw_rawawb_y_max;
+	u8 sw_rawawb_r_min;
+	u8 sw_rawawb_g_min;
+	u8 sw_rawawb_b_min;
+	u8 sw_rawawb_y_min;
+	u8 sw_rawawb_3dyuv_ls_idx0;
+	u8 sw_rawawb_3dyuv_ls_idx1;
+	u8 sw_rawawb_3dyuv_ls_idx2;
+	u8 sw_rawawb_3dyuv_ls_idx3;
+	u8 sw_rawawb_exc_wp_region0_excen0;
+	u8 sw_rawawb_exc_wp_region0_excen1;
+	u8 sw_rawawb_exc_wp_region0_domain;
+	u8 sw_rawawb_exc_wp_region1_excen0;
+	u8 sw_rawawb_exc_wp_region1_excen1;
+	u8 sw_rawawb_exc_wp_region1_domain;
+	u8 sw_rawawb_exc_wp_region2_excen0;
+	u8 sw_rawawb_exc_wp_region2_excen1;
+	u8 sw_rawawb_exc_wp_region2_domain;
+	u8 sw_rawawb_exc_wp_region3_excen0;
+	u8 sw_rawawb_exc_wp_region3_excen1;
+	u8 sw_rawawb_exc_wp_region3_domain;
+	u8 sw_rawawb_exc_wp_region4_excen0;
+	u8 sw_rawawb_exc_wp_region4_excen1;
+	u8 sw_rawawb_exc_wp_region4_domain;
+	u8 sw_rawawb_exc_wp_region5_excen0;
+	u8 sw_rawawb_exc_wp_region5_excen1;
+	u8 sw_rawawb_exc_wp_region5_domain;
+	u8 sw_rawawb_exc_wp_region6_excen0;
+	u8 sw_rawawb_exc_wp_region6_excen1;
+	u8 sw_rawawb_exc_wp_region6_domain;
+	u8 sw_rawawb_wp_luma_weicurve_y0;
+	u8 sw_rawawb_wp_luma_weicurve_y1;
+	u8 sw_rawawb_wp_luma_weicurve_y2;
+	u8 sw_rawawb_wp_luma_weicurve_y3;
+	u8 sw_rawawb_wp_luma_weicurve_y4;
+	u8 sw_rawawb_wp_luma_weicurve_y5;
+	u8 sw_rawawb_wp_luma_weicurve_y6;
+	u8 sw_rawawb_wp_luma_weicurve_y7;
+	u8 sw_rawawb_wp_luma_weicurve_y8;
+	u8 sw_rawawb_wp_luma_weicurve_w0;
+	u8 sw_rawawb_wp_luma_weicurve_w1;
+	u8 sw_rawawb_wp_luma_weicurve_w2;
+	u8 sw_rawawb_wp_luma_weicurve_w3;
+	u8 sw_rawawb_wp_luma_weicurve_w4;
+	u8 sw_rawawb_wp_luma_weicurve_w5;
+	u8 sw_rawawb_wp_luma_weicurve_w6;
+	u8 sw_rawawb_wp_luma_weicurve_w7;
+	u8 sw_rawawb_wp_luma_weicurve_w8;
+	u8 sw_rawawb_rotu0_ls0;
+	u8 sw_rawawb_rotu1_ls0;
+	u8 sw_rawawb_rotu2_ls0;
+	u8 sw_rawawb_rotu3_ls0;
+	u8 sw_rawawb_rotu4_ls0;
+	u8 sw_rawawb_rotu5_ls0;
+	u8 sw_rawawb_dis_x1x2_ls0;
+	u8 sw_rawawb_rotu0_ls1;
+	u8 sw_rawawb_rotu1_ls1;
+	u8 sw_rawawb_rotu2_ls1;
+	u8 sw_rawawb_rotu3_ls1;
+	u8 sw_rawawb_rotu4_ls1;
+	u8 sw_rawawb_rotu5_ls1;
+	u8 sw_rawawb_dis_x1x2_ls1;
+	u8 sw_rawawb_rotu0_ls2;
+	u8 sw_rawawb_rotu1_ls2;
+	u8 sw_rawawb_rotu2_ls2;
+	u8 sw_rawawb_rotu3_ls2;
+	u8 sw_rawawb_rotu4_ls2;
+	u8 sw_rawawb_rotu5_ls2;
+	u8 sw_rawawb_dis_x1x2_ls2;
+	u8 sw_rawawb_rotu0_ls3;
+	u8 sw_rawawb_rotu1_ls3;
+	u8 sw_rawawb_rotu2_ls3;
+	u8 sw_rawawb_rotu3_ls3;
+	u8 sw_rawawb_rotu4_ls3;
+	u8 sw_rawawb_rotu5_ls3;
+	u8 sw_rawawb_dis_x1x2_ls3;
+	u8 sw_rawawb_blk_rtdw_measure_en;
+	u8 sw_rawawb_blk_with_luma_wei_en;
+	u8 sw_rawawb_wp_blk_wei_w[ISP21_RAWAWB_WEIGHT_NUM];
+
+	u16 sw_rawawb_h_offs;
+	u16 sw_rawawb_v_offs;
+	u16 sw_rawawb_h_size;
+	u16 sw_rawawb_v_size;
+	u16 sw_rawawb_vertex0_u_0;
+	u16 sw_rawawb_vertex0_v_0;
+	u16 sw_rawawb_vertex1_u_0;
+	u16 sw_rawawb_vertex1_v_0;
+	u16 sw_rawawb_vertex2_u_0;
+	u16 sw_rawawb_vertex2_v_0;
+	u16 sw_rawawb_vertex3_u_0;
+	u16 sw_rawawb_vertex3_v_0;
+	u16 sw_rawawb_vertex0_u_1;
+	u16 sw_rawawb_vertex0_v_1;
+	u16 sw_rawawb_vertex1_u_1;
+	u16 sw_rawawb_vertex1_v_1;
+	u16 sw_rawawb_vertex2_u_1;
+	u16 sw_rawawb_vertex2_v_1;
+	u16 sw_rawawb_vertex3_u_1;
+	u16 sw_rawawb_vertex3_v_1;
+	u16 sw_rawawb_vertex0_u_2;
+	u16 sw_rawawb_vertex0_v_2;
+	u16 sw_rawawb_vertex1_u_2;
+	u16 sw_rawawb_vertex1_v_2;
+	u16 sw_rawawb_vertex2_u_2;
+	u16 sw_rawawb_vertex2_v_2;
+	u16 sw_rawawb_vertex3_u_2;
+	u16 sw_rawawb_vertex3_v_2;
+	u16 sw_rawawb_vertex0_u_3;
+	u16 sw_rawawb_vertex0_v_3;
+	u16 sw_rawawb_vertex1_u_3;
+	u16 sw_rawawb_vertex1_v_3;
+	u16 sw_rawawb_vertex2_u_3;
+	u16 sw_rawawb_vertex2_v_3;
+	u16 sw_rawawb_vertex3_u_3;
+	u16 sw_rawawb_vertex3_v_3;
+	u16 sw_rawawb_vertex0_u_4;
+	u16 sw_rawawb_vertex0_v_4;
+	u16 sw_rawawb_vertex1_u_4;
+	u16 sw_rawawb_vertex1_v_4;
+	u16 sw_rawawb_vertex2_u_4;
+	u16 sw_rawawb_vertex2_v_4;
+	u16 sw_rawawb_vertex3_u_4;
+	u16 sw_rawawb_vertex3_v_4;
+	u16 sw_rawawb_vertex0_u_5;
+	u16 sw_rawawb_vertex0_v_5;
+	u16 sw_rawawb_vertex1_u_5;
+	u16 sw_rawawb_vertex1_v_5;
+	u16 sw_rawawb_vertex2_u_5;
+	u16 sw_rawawb_vertex2_v_5;
+	u16 sw_rawawb_vertex3_u_5;
+	u16 sw_rawawb_vertex3_v_5;
+	u16 sw_rawawb_vertex0_u_6;
+	u16 sw_rawawb_vertex0_v_6;
+	u16 sw_rawawb_vertex1_u_6;
+	u16 sw_rawawb_vertex1_v_6;
+	u16 sw_rawawb_vertex2_u_6;
+	u16 sw_rawawb_vertex2_v_6;
+	u16 sw_rawawb_vertex3_u_6;
+	u16 sw_rawawb_vertex3_v_6;
+
+	u16 sw_rawawb_wt0;
+	u16 sw_rawawb_wt1;
+	u16 sw_rawawb_wt2;
+	u16 sw_rawawb_mat0_x;
+	u16 sw_rawawb_mat1_x;
+	u16 sw_rawawb_mat2_x;
+	u16 sw_rawawb_mat0_y;
+	u16 sw_rawawb_mat1_y;
+	u16 sw_rawawb_mat2_y;
+	u16 sw_rawawb_nor_x0_0;
+	u16 sw_rawawb_nor_x1_0;
+	u16 sw_rawawb_nor_y0_0;
+	u16 sw_rawawb_nor_y1_0;
+	u16 sw_rawawb_big_x0_0;
+	u16 sw_rawawb_big_x1_0;
+	u16 sw_rawawb_big_y0_0;
+	u16 sw_rawawb_big_y1_0;
+	u16 sw_rawawb_nor_x0_1;
+	u16 sw_rawawb_nor_x1_1;
+	u16 sw_rawawb_nor_y0_1;
+	u16 sw_rawawb_nor_y1_1;
+	u16 sw_rawawb_big_x0_1;
+	u16 sw_rawawb_big_x1_1;
+	u16 sw_rawawb_big_y0_1;
+	u16 sw_rawawb_big_y1_1;
+	u16 sw_rawawb_nor_x0_2;
+	u16 sw_rawawb_nor_x1_2;
+	u16 sw_rawawb_nor_y0_2;
+	u16 sw_rawawb_nor_y1_2;
+	u16 sw_rawawb_big_x0_2;
+	u16 sw_rawawb_big_x1_2;
+	u16 sw_rawawb_big_y0_2;
+	u16 sw_rawawb_big_y1_2;
+	u16 sw_rawawb_nor_x0_3;
+	u16 sw_rawawb_nor_x1_3;
+	u16 sw_rawawb_nor_y0_3;
+	u16 sw_rawawb_nor_y1_3;
+	u16 sw_rawawb_big_x0_3;
+	u16 sw_rawawb_big_x1_3;
+	u16 sw_rawawb_big_y0_3;
+	u16 sw_rawawb_big_y1_3;
+	u16 sw_rawawb_nor_x0_4;
+	u16 sw_rawawb_nor_x1_4;
+	u16 sw_rawawb_nor_y0_4;
+	u16 sw_rawawb_nor_y1_4;
+	u16 sw_rawawb_big_x0_4;
+	u16 sw_rawawb_big_x1_4;
+	u16 sw_rawawb_big_y0_4;
+	u16 sw_rawawb_big_y1_4;
+	u16 sw_rawawb_nor_x0_5;
+	u16 sw_rawawb_nor_x1_5;
+	u16 sw_rawawb_nor_y0_5;
+	u16 sw_rawawb_nor_y1_5;
+	u16 sw_rawawb_big_x0_5;
+	u16 sw_rawawb_big_x1_5;
+	u16 sw_rawawb_big_y0_5;
+	u16 sw_rawawb_big_y1_5;
+	u16 sw_rawawb_nor_x0_6;
+	u16 sw_rawawb_nor_x1_6;
+	u16 sw_rawawb_nor_y0_6;
+	u16 sw_rawawb_nor_y1_6;
+	u16 sw_rawawb_big_x0_6;
+	u16 sw_rawawb_big_x1_6;
+	u16 sw_rawawb_big_y0_6;
+	u16 sw_rawawb_big_y1_6;
+	u16 sw_rawawb_pre_wbgain_inv_r;
+	u16 sw_rawawb_pre_wbgain_inv_g;
+	u16 sw_rawawb_pre_wbgain_inv_b;
+	u16 sw_rawawb_exc_wp_region0_xu0;
+	u16 sw_rawawb_exc_wp_region0_xu1;
+	u16 sw_rawawb_exc_wp_region0_yv0;
+	u16 sw_rawawb_exc_wp_region0_yv1;
+	u16 sw_rawawb_exc_wp_region1_xu0;
+	u16 sw_rawawb_exc_wp_region1_xu1;
+	u16 sw_rawawb_exc_wp_region1_yv0;
+	u16 sw_rawawb_exc_wp_region1_yv1;
+	u16 sw_rawawb_exc_wp_region2_xu0;
+	u16 sw_rawawb_exc_wp_region2_xu1;
+	u16 sw_rawawb_exc_wp_region2_yv0;
+	u16 sw_rawawb_exc_wp_region2_yv1;
+	u16 sw_rawawb_exc_wp_region3_xu0;
+	u16 sw_rawawb_exc_wp_region3_xu1;
+	u16 sw_rawawb_exc_wp_region3_yv0;
+	u16 sw_rawawb_exc_wp_region3_yv1;
+	u16 sw_rawawb_exc_wp_region4_xu0;
+	u16 sw_rawawb_exc_wp_region4_xu1;
+	u16 sw_rawawb_exc_wp_region4_yv0;
+	u16 sw_rawawb_exc_wp_region4_yv1;
+	u16 sw_rawawb_exc_wp_region5_xu0;
+	u16 sw_rawawb_exc_wp_region5_xu1;
+	u16 sw_rawawb_exc_wp_region5_yv0;
+	u16 sw_rawawb_exc_wp_region5_yv1;
+	u16 sw_rawawb_exc_wp_region6_xu0;
+	u16 sw_rawawb_exc_wp_region6_xu1;
+	u16 sw_rawawb_exc_wp_region6_yv0;
+	u16 sw_rawawb_exc_wp_region6_yv1;
+	u16 sw_rawawb_rgb2ryuvmat0_u;
+	u16 sw_rawawb_rgb2ryuvmat1_u;
+	u16 sw_rawawb_rgb2ryuvmat2_u;
+	u16 sw_rawawb_rgb2ryuvofs_u;
+	u16 sw_rawawb_rgb2ryuvmat0_v;
+	u16 sw_rawawb_rgb2ryuvmat1_v;
+	u16 sw_rawawb_rgb2ryuvmat2_v;
+	u16 sw_rawawb_rgb2ryuvofs_v;
+	u16 sw_rawawb_rgb2ryuvmat0_y;
+	u16 sw_rawawb_rgb2ryuvmat1_y;
+	u16 sw_rawawb_rgb2ryuvmat2_y;
+	u16 sw_rawawb_rgb2ryuvofs_y;
+	u16 sw_rawawb_th0_ls0;
+	u16 sw_rawawb_th1_ls0;
+	u16 sw_rawawb_th2_ls0;
+	u16 sw_rawawb_th3_ls0;
+	u16 sw_rawawb_th4_ls0;
+	u16 sw_rawawb_th5_ls0;
+	u16 sw_rawawb_coor_x1_ls0_u;
+	u16 sw_rawawb_coor_x1_ls0_v;
+	u16 sw_rawawb_coor_x1_ls0_y;
+	u16 sw_rawawb_vec_x21_ls0_u;
+	u16 sw_rawawb_vec_x21_ls0_v;
+	u16 sw_rawawb_vec_x21_ls0_y;
+	u16 sw_rawawb_th0_ls1;
+	u16 sw_rawawb_th1_ls1;
+	u16 sw_rawawb_th2_ls1;
+	u16 sw_rawawb_th3_ls1;
+	u16 sw_rawawb_th4_ls1;
+	u16 sw_rawawb_th5_ls1;
+	u16 sw_rawawb_coor_x1_ls1_u;
+	u16 sw_rawawb_coor_x1_ls1_v;
+	u16 sw_rawawb_coor_x1_ls1_y;
+	u16 sw_rawawb_vec_x21_ls1_u;
+	u16 sw_rawawb_vec_x21_ls1_v;
+	u16 sw_rawawb_vec_x21_ls1_y;
+	u16 sw_rawawb_th0_ls2;
+	u16 sw_rawawb_th1_ls2;
+	u16 sw_rawawb_th2_ls2;
+	u16 sw_rawawb_th3_ls2;
+	u16 sw_rawawb_th4_ls2;
+	u16 sw_rawawb_th5_ls2;
+	u16 sw_rawawb_coor_x1_ls2_u;
+	u16 sw_rawawb_coor_x1_ls2_v;
+	u16 sw_rawawb_coor_x1_ls2_y;
+	u16 sw_rawawb_vec_x21_ls2_u;
+	u16 sw_rawawb_vec_x21_ls2_v;
+	u16 sw_rawawb_vec_x21_ls2_y;
+	u16 sw_rawawb_th0_ls3;
+	u16 sw_rawawb_th1_ls3;
+	u16 sw_rawawb_th2_ls3;
+	u16 sw_rawawb_th3_ls3;
+	u16 sw_rawawb_th4_ls3;
+	u16 sw_rawawb_th5_ls3;
+	u16 sw_rawawb_coor_x1_ls3_u;
+	u16 sw_rawawb_coor_x1_ls3_v;
+	u16 sw_rawawb_coor_x1_ls3_y;
+	u16 sw_rawawb_vec_x21_ls3_u;
+	u16 sw_rawawb_vec_x21_ls3_v;
+	u16 sw_rawawb_vec_x21_ls3_y;
+
+	u32 sw_rawawb_islope01_0;
+	u32 sw_rawawb_islope12_0;
+	u32 sw_rawawb_islope23_0;
+	u32 sw_rawawb_islope30_0;
+	u32 sw_rawawb_islope01_1;
+	u32 sw_rawawb_islope12_1;
+	u32 sw_rawawb_islope23_1;
+	u32 sw_rawawb_islope30_1;
+	u32 sw_rawawb_islope01_2;
+	u32 sw_rawawb_islope12_2;
+	u32 sw_rawawb_islope23_2;
+	u32 sw_rawawb_islope30_2;
+	u32 sw_rawawb_islope01_3;
+	u32 sw_rawawb_islope12_3;
+	u32 sw_rawawb_islope23_3;
+	u32 sw_rawawb_islope30_3;
+	u32 sw_rawawb_islope01_4;
+	u32 sw_rawawb_islope12_4;
+	u32 sw_rawawb_islope23_4;
+	u32 sw_rawawb_islope30_4;
+	u32 sw_rawawb_islope01_5;
+	u32 sw_rawawb_islope12_5;
+	u32 sw_rawawb_islope23_5;
+	u32 sw_rawawb_islope30_5;
+	u32 sw_rawawb_islope01_6;
+	u32 sw_rawawb_islope12_6;
+	u32 sw_rawawb_islope23_6;
+	u32 sw_rawawb_islope30_6;
+} __attribute__ ((packed));
+
+struct isp21_isp_other_cfg {
+	struct isp21_bls_cfg bls_cfg;
+	struct isp2x_dpcc_cfg dpcc_cfg;
+	struct isp2x_lsc_cfg lsc_cfg;
+	struct isp21_awb_gain_cfg awb_gain_cfg;
+	struct isp21_gic_cfg gic_cfg;
+	struct isp2x_debayer_cfg debayer_cfg;
+	struct isp21_ccm_cfg ccm_cfg;
+	struct isp2x_gammaout_cfg gammaout_cfg;
+	struct isp2x_cproc_cfg cproc_cfg;
+	struct isp2x_ie_cfg ie_cfg;
+	struct isp2x_sdg_cfg sdg_cfg;
+	struct isp21_drc_cfg drc_cfg;
+	struct isp2x_hdrmge_cfg hdrmge_cfg;
+	struct isp21_dhaz_cfg dhaz_cfg;
+	struct isp2x_3dlut_cfg isp3dlut_cfg;
+	struct isp2x_ldch_cfg ldch_cfg;
+	struct isp21_baynr_cfg baynr_cfg;
+	struct isp21_bay3d_cfg bay3d_cfg;
+	struct isp21_ynr_cfg ynr_cfg;
+	struct isp21_cnr_cfg cnr_cfg;
+	struct isp21_sharp_cfg sharp_cfg;
+	struct isp21_csm_cfg csm_cfg;
+} __attribute__ ((packed));
+
+struct isp21_isp_meas_cfg {
+	struct isp2x_siawb_meas_cfg siawb;
+	struct isp21_rawawb_meas_cfg rawawb;
+	struct isp2x_rawaelite_meas_cfg rawae0;
+	struct isp2x_rawaebig_meas_cfg rawae1;
+	struct isp2x_rawaebig_meas_cfg rawae2;
+	struct isp2x_rawaebig_meas_cfg rawae3;
+	struct isp2x_yuvae_meas_cfg yuvae;
+	struct isp2x_rawaf_meas_cfg rawaf;
+	struct isp2x_siaf_cfg siaf;
+	struct isp2x_rawhistlite_cfg rawhist0;
+	struct isp2x_rawhistbig_cfg rawhist1;
+	struct isp2x_rawhistbig_cfg rawhist2;
+	struct isp2x_rawhistbig_cfg rawhist3;
+	struct isp2x_sihst_cfg sihst;
+} __attribute__ ((packed));
+
+struct isp21_isp_params_cfg {
+	u64 module_en_update;
+	u64 module_ens;
+	u64 module_cfg_update;
+
+	u32 frame_id;
+	struct isp21_isp_meas_cfg meas;
+	struct isp21_isp_other_cfg others;
+} __attribute__ ((packed));
+
+struct isp21_rawawb_meas_stat {
+	u16 ro_yhist_bin[ISP21_RAWAWB_HSTBIN_NUM];
+	u32 ro_rawawb_sum_rgain_nor[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_bgain_nor[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_wp_num_nor[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_rgain_big[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_bgain_big[ISP2X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_wp_num_big[ISP2X_RAWAWB_SUM_NUM];
+	struct isp2x_rawawb_ramdata ramdata[ISP2X_RAWAWB_RAMDATA_NUM];
+} __attribute__ ((packed));
+
+struct isp21_stat {
+	struct isp2x_siawb_stat siawb;
+	struct isp21_rawawb_meas_stat rawawb;
+	struct isp2x_rawaelite_stat rawae0;
+	struct isp2x_rawaebig_stat rawae1;
+	struct isp2x_rawaebig_stat rawae2;
+	struct isp2x_rawaebig_stat rawae3;
+	struct isp2x_yuvae_stat yuvae;
+	struct isp2x_rawaf_stat rawaf;
+	struct isp2x_siaf_stat siaf;
+	struct isp2x_rawhistlite_stat rawhist0;
+	struct isp2x_rawhistbig_stat rawhist1;
+	struct isp2x_rawhistbig_stat rawhist2;
+	struct isp2x_rawhistbig_stat rawhist3;
+	struct isp2x_sihst_stat sihst;
+
+	struct isp2x_bls_stat bls;
+	struct isp21_dhaz_stat dhaz;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp_isp21_stat_buffer - Rockchip ISP2 Statistics Meta Data
+ *
+ * @meas_type: measurement types (CIFISP_STAT_ definitions)
+ * @frame_id: frame ID for sync
+ * @params: statistics data
+ */
+struct rkisp_isp21_stat_buffer {
+	unsigned int meas_type;
+	unsigned int frame_id;
+	struct isp21_stat params;
+} __attribute__ ((packed));
+
+#endif /* _UAPI_RKISP21_CONFIG_H */
diff --git a/include/uapi/linux/rkisp3-config.h b/include/uapi/linux/rkisp3-config.h
new file mode 100644
index 000000000..25bbe1a9a
--- /dev/null
+++ b/include/uapi/linux/rkisp3-config.h
@@ -0,0 +1,1072 @@
+/* SPDX-License-Identifier: (GPL-2.0+ WITH Linux-syscall-note) OR MIT
+ *
+ * Rockchip ISP3
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKISP3_CONFIG_H
+#define _UAPI_RKISP3_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+#include <linux/rkisp21-config.h>
+
+#define ISP3X_MODULE_DPCC		ISP2X_MODULE_DPCC
+#define ISP3X_MODULE_BLS		ISP2X_MODULE_BLS
+#define ISP3X_MODULE_SDG		ISP2X_MODULE_SDG
+#define ISP3X_MODULE_LSC		ISP2X_MODULE_LSC
+#define ISP3X_MODULE_AWB_GAIN		ISP2X_MODULE_AWB_GAIN
+#define ISP3X_MODULE_BDM		ISP2X_MODULE_BDM
+#define ISP3X_MODULE_CCM		ISP2X_MODULE_CCM
+#define ISP3X_MODULE_GOC		ISP2X_MODULE_GOC
+#define ISP3X_MODULE_CPROC		ISP2X_MODULE_CPROC
+#define ISP3X_MODULE_IE			ISP2X_MODULE_IE
+#define ISP3X_MODULE_RAWAF		ISP2X_MODULE_RAWAF
+#define ISP3X_MODULE_RAWAE0		ISP2X_MODULE_RAWAE0
+#define ISP3X_MODULE_RAWAE1		ISP2X_MODULE_RAWAE1
+#define ISP3X_MODULE_RAWAE2		ISP2X_MODULE_RAWAE2
+#define ISP3X_MODULE_RAWAE3		ISP2X_MODULE_RAWAE3
+#define ISP3X_MODULE_RAWAWB		ISP2X_MODULE_RAWAWB
+#define ISP3X_MODULE_RAWHIST0		ISP2X_MODULE_RAWHIST0
+#define ISP3X_MODULE_RAWHIST1		ISP2X_MODULE_RAWHIST1
+#define ISP3X_MODULE_RAWHIST2		ISP2X_MODULE_RAWHIST2
+#define ISP3X_MODULE_RAWHIST3		ISP2X_MODULE_RAWHIST3
+#define ISP3X_MODULE_HDRMGE		ISP2X_MODULE_HDRMGE
+#define ISP3X_MODULE_RAWNR		ISP2X_MODULE_RAWNR
+#define ISP3X_MODULE_GIC		ISP2X_MODULE_GIC
+#define ISP3X_MODULE_DHAZ		ISP2X_MODULE_DHAZ
+#define ISP3X_MODULE_3DLUT		ISP2X_MODULE_3DLUT
+#define ISP3X_MODULE_LDCH		ISP2X_MODULE_LDCH
+#define ISP3X_MODULE_GAIN		ISP2X_MODULE_GAIN
+#define ISP3X_MODULE_DEBAYER		ISP2X_MODULE_DEBAYER
+#define ISP3X_MODULE_BAYNR		ISP2X_MODULE_BAYNR
+#define ISP3X_MODULE_BAY3D		ISP2X_MODULE_BAY3D
+#define ISP3X_MODULE_YNR		ISP2X_MODULE_YNR
+#define ISP3X_MODULE_CNR		ISP2X_MODULE_CNR
+#define ISP3X_MODULE_SHARP		ISP2X_MODULE_SHARP
+#define ISP3X_MODULE_DRC		ISP2X_MODULE_DRC
+#define ISP3X_MODULE_CAC		BIT_ULL(42)
+#define ISP3X_MODULE_CSM		ISP2X_MODULE_CSM
+
+/* Measurement types */
+#define ISP3X_STAT_RAWAWB		ISP2X_STAT_RAWAWB
+#define ISP3X_STAT_RAWAF		ISP2X_STAT_RAWAF
+#define ISP3X_STAT_RAWAE0		ISP2X_STAT_RAWAE0
+#define ISP3X_STAT_RAWAE1		ISP2X_STAT_RAWAE1
+#define ISP3X_STAT_RAWAE2		ISP2X_STAT_RAWAE2
+#define ISP3X_STAT_RAWAE3		ISP2X_STAT_RAWAE3
+#define ISP3X_STAT_RAWHST0		ISP2X_STAT_RAWHST0
+#define ISP3X_STAT_RAWHST1		ISP2X_STAT_RAWHST1
+#define ISP3X_STAT_RAWHST2		ISP2X_STAT_RAWHST2
+#define ISP3X_STAT_RAWHST3		ISP2X_STAT_RAWHST3
+#define ISP3X_STAT_BLS			ISP2X_STAT_BLS
+#define ISP3X_STAT_DHAZ			ISP2X_STAT_DHAZ
+
+#define ISP3X_MESH_BUF_NUM		ISP2X_MESH_BUF_NUM
+
+#define ISP3X_LSC_GRAD_TBL_SIZE		16
+#define ISP3X_LSC_SIZE_TBL_SIZE		16
+#define ISP3X_LSC_DATA_TBL_SIZE		ISP2X_LSC_DATA_TBL_SIZE
+
+#define ISP3X_DEGAMMA_CURVE_SIZE	ISP2X_DEGAMMA_CURVE_SIZE
+
+#define ISP3X_GAIN_IDX_NUM		ISP2X_GAIN_IDX_NUM
+#define ISP3X_GAIN_LUT_NUM		ISP2X_GAIN_LUT_NUM
+
+#define ISP3X_RAWAWB_MULWD_NUM		4
+#define ISP3X_RAWAWB_EXCL_STAT_NUM	4
+#define ISP3X_RAWAWB_HSTBIN_NUM		ISP21_RAWAWB_HSTBIN_NUM
+#define ISP3X_RAWAWB_WEIGHT_NUM		ISP21_RAWAWB_WEIGHT_NUM
+#define ISP3X_RAWAWB_SUM_NUM		ISP2X_RAWAWB_SUM_NUM
+#define ISP3X_RAWAWB_RAMDATA_NUM	ISP2X_RAWAWB_RAMDATA_NUM
+
+#define	ISP3X_RAWAEBIG_SUBWIN_NUM	ISP2X_RAWAEBIG_SUBWIN_NUM
+#define ISP3X_RAWAEBIG_MEAN_NUM		ISP2X_RAWAEBIG_MEAN_NUM
+#define ISP3X_RAWAELITE_MEAN_NUM	ISP2X_RAWAELITE_MEAN_NUM
+
+#define ISP3X_RAWHISTBIG_SUBWIN_NUM	ISP2X_RAWHISTBIG_SUBWIN_NUM
+#define ISP3X_RAWHISTLITE_SUBWIN_NUM	ISP2X_RAWHISTLITE_SUBWIN_NUM
+#define ISP3X_HIST_BIN_N_MAX		ISP2X_HIST_BIN_N_MAX
+
+#define ISP3X_RAWAF_CURVE_NUM		2
+#define ISP3X_RAWAF_HIIR_COE_NUM	6
+#define ISP3X_RAWAF_V1IIR_COE_NUM	9
+#define ISP3X_RAWAF_V2IIR_COE_NUM	3
+#define ISP3X_RAWAF_VFIR_COE_NUM	3
+#define ISP3X_RAWAF_WIN_NUM		ISP2X_RAWAF_WIN_NUM
+#define ISP3X_RAWAF_LINE_NUM		ISP2X_RAWAF_LINE_NUM
+#define ISP3X_RAWAF_GAMMA_NUM		ISP2X_RAWAF_GAMMA_NUM
+#define ISP3X_RAWAF_SUMDATA_NUM		ISP2X_RAWAF_SUMDATA_NUM
+
+#define ISP3X_DPCC_PDAF_POINT_NUM	ISP2X_DPCC_PDAF_POINT_NUM
+
+#define ISP3X_HDRMGE_L_CURVE_NUM	ISP2X_HDRMGE_L_CURVE_NUM
+#define ISP3X_HDRMGE_E_CURVE_NUM	ISP2X_HDRMGE_E_CURVE_NUM
+
+#define ISP3X_GIC_SIGMA_Y_NUM		ISP2X_GIC_SIGMA_Y_NUM
+
+#define ISP3X_CCM_CURVE_NUM		ISP2X_CCM_CURVE_NUM
+
+#define ISP3X_3DLUT_DATA_NUM		ISP2X_3DLUT_DATA_NUM
+
+#define ISP3X_LDCH_MESH_XY_NUM		ISP2X_LDCH_MESH_XY_NUM
+
+#define ISP3X_GAMMA_OUT_MAX_SAMPLES     49
+
+#define ISP3X_DHAZ_SIGMA_IDX_NUM	15
+#define ISP3X_DHAZ_SIGMA_LUT_NUM	17
+#define ISP3X_DHAZ_HIST_WR_NUM		64
+#define ISP3X_DHAZ_ENH_CURVE_NUM	ISP21_DHAZ_ENH_CURVE_NUM
+#define ISP3X_DHAZ_HIST_IIR_NUM		ISP21_DHAZ_HIST_IIR_NUM
+
+#define ISP3X_DRC_Y_NUM			ISP21_DRC_Y_NUM
+
+#define ISP3X_CNR_SIGMA_Y_NUM		13
+
+#define ISP3X_YNR_XY_NUM		ISP21_YNR_XY_NUM
+
+#define ISP3X_BAYNR_XY_NUM		ISP21_BAYNR_XY_NUM
+
+#define ISP3X_BAY3D_XY_NUM		ISP21_BAY3D_XY_NUM
+
+#define ISP3X_SHARP_X_NUM		ISP21_SHARP_X_NUM
+#define ISP3X_SHARP_Y_NUM		ISP21_SHARP_Y_NUM
+#define ISP3X_SHARP_GAUS_COEF_NUM	6
+
+#define ISP3X_CAC_STRENGTH_NUM		22
+
+#define ISP3X_CSM_COEFF_NUM		ISP21_CSM_COEFF_NUM
+
+enum isp3x_unite_id {
+	ISP3_LEFT = 0,
+	ISP3_RIGHT,
+	ISP3_UNITE_MAX,
+};
+
+struct isp3x_gammaout_cfg {
+	u8 equ_segm;
+	u8 finalx4_dense_en;
+	u16 offset;
+	u16 gamma_y[ISP3X_GAMMA_OUT_MAX_SAMPLES];
+} __attribute__ ((packed));
+
+struct isp3x_lsc_cfg {
+	u8 sector_16x16;
+
+	u16 r_data_tbl[ISP3X_LSC_DATA_TBL_SIZE];
+	u16 gr_data_tbl[ISP3X_LSC_DATA_TBL_SIZE];
+	u16 gb_data_tbl[ISP3X_LSC_DATA_TBL_SIZE];
+	u16 b_data_tbl[ISP3X_LSC_DATA_TBL_SIZE];
+
+	u16 x_grad_tbl[ISP3X_LSC_GRAD_TBL_SIZE];
+	u16 y_grad_tbl[ISP3X_LSC_GRAD_TBL_SIZE];
+
+	u16 x_size_tbl[ISP3X_LSC_SIZE_TBL_SIZE];
+	u16 y_size_tbl[ISP3X_LSC_SIZE_TBL_SIZE];
+} __attribute__ ((packed));
+
+struct isp3x_baynr_cfg {
+	u8 lg2_mode;
+	u8 gauss_en;
+	u8 log_bypass;
+
+	u16 dgain1;
+	u16 dgain0;
+	u16 dgain2;
+
+	u16 pix_diff;
+
+	u16 diff_thld;
+	u16 softthld;
+
+	u16 bltflt_streng;
+	u16 reg_w1;
+
+	u16 sigma_x[ISP3X_BAYNR_XY_NUM];
+	u16 sigma_y[ISP3X_BAYNR_XY_NUM];
+
+	u16 weit_d2;
+	u16 weit_d1;
+	u16 weit_d0;
+
+	u16 lg2_lgoff;
+	u16 lg2_off;
+
+	u32 dat_max;
+} __attribute__ ((packed));
+
+struct isp3x_bay3d_cfg {
+	u8 bypass_en;
+	u8 hibypass_en;
+	u8 lobypass_en;
+	u8 himed_bypass_en;
+	u8 higaus_bypass_en;
+	u8 hiabs_possel;
+	u8 hichnsplit_en;
+	u8 lomed_bypass_en;
+	u8 logaus5_bypass_en;
+	u8 logaus3_bypass_en;
+	u8 glbpk_en;
+	u8 loswitch_protect;
+
+	u16 softwgt;
+	u16 hidif_th;
+
+	u32 glbpk2;
+
+	u16 wgtlmt;
+	u16 wgtratio;
+
+	u16 sig0_x[ISP3X_BAY3D_XY_NUM];
+	u16 sig0_y[ISP3X_BAY3D_XY_NUM];
+	u16 sig1_x[ISP3X_BAY3D_XY_NUM];
+	u16 sig1_y[ISP3X_BAY3D_XY_NUM];
+	u16 sig2_x[ISP3X_BAY3D_XY_NUM];
+	u16 sig2_y[ISP3X_BAY3D_XY_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_ynr_cfg {
+	u8 rnr_en;
+	u8 thumb_mix_cur_en;
+	u8 global_gain_alpha;
+	u8 flt1x1_bypass_sel;
+	u8 sft5x5_bypass;
+	u8 flt1x1_bypass;
+	u8 lgft3x3_bypass;
+	u8 lbft5x5_bypass;
+	u8 bft3x3_bypass;
+	u16 global_gain;
+
+	u16 rnr_max_r;
+	u16 local_gainscale;
+
+	u16 rnr_center_coorh;
+	u16 rnr_center_coorv;
+
+	u16 loclagain_adj_thresh;
+	u16 localgain_adj;
+
+	u16 low_bf_inv1;
+	u16 low_bf_inv0;
+
+	u16 low_peak_supress;
+	u16 low_thred_adj;
+
+	u16 low_dist_adj;
+	u16 low_edge_adj_thresh;
+
+	u16 low_bi_weight;
+	u16 low_weight;
+	u16 low_center_weight;
+	u16 hi_min_adj;
+	u16 high_thred_adj;
+	u8 high_retain_weight;
+	u8 hi_edge_thed;
+	u8 base_filter_weight2;
+	u8 base_filter_weight1;
+	u8 base_filter_weight0;
+	u16 frame_full_size;
+	u16 lbf_weight_thres;
+	u16 low_gauss1_coeff2;
+	u16 low_gauss1_coeff1;
+	u16 low_gauss1_coeff0;
+	u16 low_gauss2_coeff2;
+	u16 low_gauss2_coeff1;
+	u16 low_gauss2_coeff0;
+	u8 direction_weight3;
+	u8 direction_weight2;
+	u8 direction_weight1;
+	u8 direction_weight0;
+	u8 direction_weight7;
+	u8 direction_weight6;
+	u8 direction_weight5;
+	u8 direction_weight4;
+	u16 luma_points_x[ISP3X_YNR_XY_NUM];
+	u16 lsgm_y[ISP3X_YNR_XY_NUM];
+	u16 hsgm_y[ISP3X_YNR_XY_NUM];
+	u8 rnr_strength3[ISP3X_YNR_XY_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_cnr_cfg {
+	u8 thumb_mix_cur_en;
+	u8 lq_bila_bypass;
+	u8 hq_bila_bypass;
+	u8 exgain_bypass;
+
+	u8 global_gain_alpha;
+	u16 global_gain;
+
+	u8 gain_iso;
+	u8 gain_offset;
+	u8 gain_1sigma;
+
+	u8 gain_uvgain1;
+	u8 gain_uvgain0;
+
+	u8 lmed3_alpha;
+
+	u8 lbf5_gain_y;
+	u8 lbf5_gain_c;
+
+	u8 lbf5_weit_d3;
+	u8 lbf5_weit_d2;
+	u8 lbf5_weit_d1;
+	u8 lbf5_weit_d0;
+
+	u8 lbf5_weit_d4;
+
+	u8 hmed3_alpha;
+
+	u16 hbf5_weit_src;
+	u16 hbf5_min_wgt;
+	u16 hbf5_sigma;
+
+	u16 lbf5_weit_src;
+	u16 lbf3_sigma;
+
+	u8 sigma_y[ISP3X_CNR_SIGMA_Y_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_sharp_cfg {
+	u8 bypass;
+	u8 center_mode;
+	u8 exgain_bypass;
+
+	u8 sharp_ratio;
+	u8 bf_ratio;
+	u8 gaus_ratio;
+	u8 pbf_ratio;
+
+	u8 luma_dx[ISP3X_SHARP_X_NUM];
+
+	u16 pbf_sigma_inv[ISP3X_SHARP_Y_NUM];
+
+	u16 bf_sigma_inv[ISP3X_SHARP_Y_NUM];
+
+	u8 bf_sigma_shift;
+	u8 pbf_sigma_shift;
+
+	u16 ehf_th[ISP3X_SHARP_Y_NUM];
+
+	u16 clip_hf[ISP3X_SHARP_Y_NUM];
+
+	u8 pbf_coef2;
+	u8 pbf_coef1;
+	u8 pbf_coef0;
+
+	u8 bf_coef2;
+	u8 bf_coef1;
+	u8 bf_coef0;
+
+	u8 gaus_coef[ISP3X_SHARP_GAUS_COEF_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_dhaz_cfg {
+	u8 round_en;
+	u8 soft_wr_en;
+	u8 enhance_en;
+	u8 air_lc_en;
+	u8 hpara_en;
+	u8 hist_en;
+	u8 dc_en;
+
+	u8 yblk_th;
+	u8 yhist_th;
+	u8 dc_max_th;
+	u8 dc_min_th;
+
+	u16 wt_max;
+	u8 bright_max;
+	u8 bright_min;
+
+	u8 tmax_base;
+	u8 dark_th;
+	u8 air_max;
+	u8 air_min;
+
+	u16 tmax_max;
+	u16 tmax_off;
+
+	u8 hist_k;
+	u8 hist_th_off;
+	u16 hist_min;
+
+	u16 hist_gratio;
+	u16 hist_scale;
+
+	u16 enhance_value;
+	u16 enhance_chroma;
+
+	u16 iir_wt_sigma;
+	u16 iir_sigma;
+	u16 stab_fnum;
+
+	u16 iir_tmax_sigma;
+	u16 iir_air_sigma;
+	u8 iir_pre_wet;
+
+	u16 cfg_wt;
+	u16 cfg_air;
+	u16 cfg_alpha;
+
+	u16 cfg_gratio;
+	u16 cfg_tmax;
+
+	u16 range_sima;
+	u8 space_sigma_pre;
+	u8 space_sigma_cur;
+
+	u16 dc_weitcur;
+	u16 bf_weight;
+
+	u16 enh_curve[ISP3X_DHAZ_ENH_CURVE_NUM];
+
+	u8 gaus_h2;
+	u8 gaus_h1;
+	u8 gaus_h0;
+
+	u8 sigma_idx[ISP3X_DHAZ_SIGMA_IDX_NUM];
+	u16 sigma_lut[ISP3X_DHAZ_SIGMA_LUT_NUM];
+
+	u16 adp_wt_wr;
+	u16 adp_air_wr;
+
+	u16 adp_tmax_wr;
+	u16 adp_gratio_wr;
+
+	u16 hist_wr[ISP3X_DHAZ_HIST_WR_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_dhaz_stat {
+	u32 dhaz_pic_sumh;
+
+	u16 dhaz_adp_air_base;
+	u16 dhaz_adp_wt;
+
+	u16 dhaz_adp_gratio;
+	u16 dhaz_adp_tmax;
+
+	u16 h_rgb_iir[ISP3X_DHAZ_HIST_IIR_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_drc_cfg {
+	u8 bypass_en;
+	u8 offset_pow2;
+	u16 compres_scl;
+	u16 position;
+	u16 delta_scalein;
+	u16 hpdetail_ratio;
+	u16 lpdetail_ratio;
+	u8 weicur_pix;
+	u8 weipre_frame;
+	u8 bilat_wt_off;
+	u16 force_sgm_inv0;
+	u8 motion_scl;
+	u8 edge_scl;
+	u16 space_sgm_inv1;
+	u16 space_sgm_inv0;
+	u16 range_sgm_inv1;
+	u16 range_sgm_inv0;
+	u8 weig_maxl;
+	u8 weig_bilat;
+	u8 enable_soft_thd;
+	u16 bilat_soft_thd;
+	u16 gain_y[ISP3X_DRC_Y_NUM];
+	u16 compres_y[ISP3X_DRC_Y_NUM];
+	u16 scale_y[ISP3X_DRC_Y_NUM];
+	u16 wr_cycle;
+	u16 iir_weight;
+	u16 min_ogain;
+} __attribute__ ((packed));
+
+struct isp3x_hdrmge_cfg {
+	u8 s_base;
+	u8 mode;
+
+	u16 gain0_inv;
+	u16 gain0;
+	u16 gain1_inv;
+	u16 gain1;
+	u8 gain2;
+
+	u8 lm_dif_0p15;
+	u8 lm_dif_0p9;
+	u8 ms_diff_0p15;
+	u8 ms_dif_0p8;
+
+	u16 ms_thd1;
+	u16 ms_thd0;
+	u16 ms_scl;
+	u16 lm_thd1;
+	u16 lm_thd0;
+	u16 lm_scl;
+	struct isp2x_hdrmge_curve curve;
+	u16 e_y[ISP3X_HDRMGE_E_CURVE_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_rawawb_meas_cfg {
+	u8 rawawb_sel;
+	u8 sw_rawawb_xy_en0;
+	u8 sw_rawawb_uv_en0;
+	u8 sw_rawawb_xy_en1;
+	u8 sw_rawawb_uv_en1;
+	u8 sw_rawawb_3dyuv_en0;
+	u8 sw_rawawb_3dyuv_en1;
+	u8 sw_rawawb_wp_blk_wei_en0;
+	u8 sw_rawawb_wp_blk_wei_en1;
+	u8 sw_rawawb_wp_luma_wei_en0;
+	u8 sw_rawawb_wp_luma_wei_en1;
+	u8 sw_rawlsc_bypass_en;
+	u8 sw_rawawb_blk_measure_enable;
+	u8 sw_rawawb_blk_measure_mode;
+	u8 sw_rawawb_blk_measure_xytype;
+	u8 sw_rawawb_blk_measure_illu_idx;
+	u8 sw_rawawb_wp_hist_xytype;
+	u8 sw_rawawb_light_num;
+	u8 sw_rawawb_wind_size;
+	u8 sw_rawawb_r_max;
+	u8 sw_rawawb_g_max;
+	u8 sw_rawawb_b_max;
+	u8 sw_rawawb_y_max;
+	u8 sw_rawawb_r_min;
+	u8 sw_rawawb_g_min;
+	u8 sw_rawawb_b_min;
+	u8 sw_rawawb_y_min;
+	u8 sw_rawawb_3dyuv_ls_idx0;
+	u8 sw_rawawb_3dyuv_ls_idx1;
+	u8 sw_rawawb_3dyuv_ls_idx2;
+	u8 sw_rawawb_3dyuv_ls_idx3;
+	u8 sw_rawawb_multiwindow_en;
+	u8 sw_rawawb_exc_wp_region0_excen0;
+	u8 sw_rawawb_exc_wp_region0_excen1;
+	u8 sw_rawawb_exc_wp_region0_measen;
+	u8 sw_rawawb_exc_wp_region0_domain;
+	u8 sw_rawawb_exc_wp_region1_excen0;
+	u8 sw_rawawb_exc_wp_region1_excen1;
+	u8 sw_rawawb_exc_wp_region1_measen;
+	u8 sw_rawawb_exc_wp_region1_domain;
+	u8 sw_rawawb_exc_wp_region2_excen0;
+	u8 sw_rawawb_exc_wp_region2_excen1;
+	u8 sw_rawawb_exc_wp_region2_measen;
+	u8 sw_rawawb_exc_wp_region2_domain;
+	u8 sw_rawawb_exc_wp_region3_excen0;
+	u8 sw_rawawb_exc_wp_region3_excen1;
+	u8 sw_rawawb_exc_wp_region3_measen;
+	u8 sw_rawawb_exc_wp_region3_domain;
+	u8 sw_rawawb_exc_wp_region4_excen0;
+	u8 sw_rawawb_exc_wp_region4_excen1;
+	u8 sw_rawawb_exc_wp_region4_domain;
+	u8 sw_rawawb_exc_wp_region5_excen0;
+	u8 sw_rawawb_exc_wp_region5_excen1;
+	u8 sw_rawawb_exc_wp_region5_domain;
+	u8 sw_rawawb_exc_wp_region6_excen0;
+	u8 sw_rawawb_exc_wp_region6_excen1;
+	u8 sw_rawawb_exc_wp_region6_domain;
+	u8 sw_rawawb_wp_luma_weicurve_y0;
+	u8 sw_rawawb_wp_luma_weicurve_y1;
+	u8 sw_rawawb_wp_luma_weicurve_y2;
+	u8 sw_rawawb_wp_luma_weicurve_y3;
+	u8 sw_rawawb_wp_luma_weicurve_y4;
+	u8 sw_rawawb_wp_luma_weicurve_y5;
+	u8 sw_rawawb_wp_luma_weicurve_y6;
+	u8 sw_rawawb_wp_luma_weicurve_y7;
+	u8 sw_rawawb_wp_luma_weicurve_y8;
+	u8 sw_rawawb_wp_luma_weicurve_w0;
+	u8 sw_rawawb_wp_luma_weicurve_w1;
+	u8 sw_rawawb_wp_luma_weicurve_w2;
+	u8 sw_rawawb_wp_luma_weicurve_w3;
+	u8 sw_rawawb_wp_luma_weicurve_w4;
+	u8 sw_rawawb_wp_luma_weicurve_w5;
+	u8 sw_rawawb_wp_luma_weicurve_w6;
+	u8 sw_rawawb_wp_luma_weicurve_w7;
+	u8 sw_rawawb_wp_luma_weicurve_w8;
+	u8 sw_rawawb_rotu0_ls0;
+	u8 sw_rawawb_rotu1_ls0;
+	u8 sw_rawawb_rotu2_ls0;
+	u8 sw_rawawb_rotu3_ls0;
+	u8 sw_rawawb_rotu4_ls0;
+	u8 sw_rawawb_rotu5_ls0;
+	u8 sw_rawawb_dis_x1x2_ls0;
+	u8 sw_rawawb_rotu0_ls1;
+	u8 sw_rawawb_rotu1_ls1;
+	u8 sw_rawawb_rotu2_ls1;
+	u8 sw_rawawb_rotu3_ls1;
+	u8 sw_rawawb_rotu4_ls1;
+	u8 sw_rawawb_rotu5_ls1;
+	u8 sw_rawawb_dis_x1x2_ls1;
+	u8 sw_rawawb_rotu0_ls2;
+	u8 sw_rawawb_rotu1_ls2;
+	u8 sw_rawawb_rotu2_ls2;
+	u8 sw_rawawb_rotu3_ls2;
+	u8 sw_rawawb_rotu4_ls2;
+	u8 sw_rawawb_rotu5_ls2;
+	u8 sw_rawawb_dis_x1x2_ls2;
+	u8 sw_rawawb_rotu0_ls3;
+	u8 sw_rawawb_rotu1_ls3;
+	u8 sw_rawawb_rotu2_ls3;
+	u8 sw_rawawb_rotu3_ls3;
+	u8 sw_rawawb_rotu4_ls3;
+	u8 sw_rawawb_rotu5_ls3;
+	u8 sw_rawawb_dis_x1x2_ls3;
+	u8 sw_rawawb_blk_rtdw_measure_en;
+	u8 sw_rawawb_blk_with_luma_wei_en;
+	u8 sw_rawawb_wp_blk_wei_w[ISP3X_RAWAWB_WEIGHT_NUM];
+
+	u16 sw_rawawb_h_offs;
+	u16 sw_rawawb_v_offs;
+	u16 sw_rawawb_h_size;
+	u16 sw_rawawb_v_size;
+	u16 sw_rawawb_vertex0_u_0;
+	u16 sw_rawawb_vertex0_v_0;
+	u16 sw_rawawb_vertex1_u_0;
+	u16 sw_rawawb_vertex1_v_0;
+	u16 sw_rawawb_vertex2_u_0;
+	u16 sw_rawawb_vertex2_v_0;
+	u16 sw_rawawb_vertex3_u_0;
+	u16 sw_rawawb_vertex3_v_0;
+	u16 sw_rawawb_vertex0_u_1;
+	u16 sw_rawawb_vertex0_v_1;
+	u16 sw_rawawb_vertex1_u_1;
+	u16 sw_rawawb_vertex1_v_1;
+	u16 sw_rawawb_vertex2_u_1;
+	u16 sw_rawawb_vertex2_v_1;
+	u16 sw_rawawb_vertex3_u_1;
+	u16 sw_rawawb_vertex3_v_1;
+	u16 sw_rawawb_vertex0_u_2;
+	u16 sw_rawawb_vertex0_v_2;
+	u16 sw_rawawb_vertex1_u_2;
+	u16 sw_rawawb_vertex1_v_2;
+	u16 sw_rawawb_vertex2_u_2;
+	u16 sw_rawawb_vertex2_v_2;
+	u16 sw_rawawb_vertex3_u_2;
+	u16 sw_rawawb_vertex3_v_2;
+	u16 sw_rawawb_vertex0_u_3;
+	u16 sw_rawawb_vertex0_v_3;
+	u16 sw_rawawb_vertex1_u_3;
+	u16 sw_rawawb_vertex1_v_3;
+	u16 sw_rawawb_vertex2_u_3;
+	u16 sw_rawawb_vertex2_v_3;
+	u16 sw_rawawb_vertex3_u_3;
+	u16 sw_rawawb_vertex3_v_3;
+	u16 sw_rawawb_vertex0_u_4;
+	u16 sw_rawawb_vertex0_v_4;
+	u16 sw_rawawb_vertex1_u_4;
+	u16 sw_rawawb_vertex1_v_4;
+	u16 sw_rawawb_vertex2_u_4;
+	u16 sw_rawawb_vertex2_v_4;
+	u16 sw_rawawb_vertex3_u_4;
+	u16 sw_rawawb_vertex3_v_4;
+	u16 sw_rawawb_vertex0_u_5;
+	u16 sw_rawawb_vertex0_v_5;
+	u16 sw_rawawb_vertex1_u_5;
+	u16 sw_rawawb_vertex1_v_5;
+	u16 sw_rawawb_vertex2_u_5;
+	u16 sw_rawawb_vertex2_v_5;
+	u16 sw_rawawb_vertex3_u_5;
+	u16 sw_rawawb_vertex3_v_5;
+	u16 sw_rawawb_vertex0_u_6;
+	u16 sw_rawawb_vertex0_v_6;
+	u16 sw_rawawb_vertex1_u_6;
+	u16 sw_rawawb_vertex1_v_6;
+	u16 sw_rawawb_vertex2_u_6;
+	u16 sw_rawawb_vertex2_v_6;
+	u16 sw_rawawb_vertex3_u_6;
+	u16 sw_rawawb_vertex3_v_6;
+
+	u16 sw_rawawb_wt0;
+	u16 sw_rawawb_wt1;
+	u16 sw_rawawb_wt2;
+	u16 sw_rawawb_mat0_x;
+	u16 sw_rawawb_mat1_x;
+	u16 sw_rawawb_mat2_x;
+	u16 sw_rawawb_mat0_y;
+	u16 sw_rawawb_mat1_y;
+	u16 sw_rawawb_mat2_y;
+	u16 sw_rawawb_nor_x0_0;
+	u16 sw_rawawb_nor_x1_0;
+	u16 sw_rawawb_nor_y0_0;
+	u16 sw_rawawb_nor_y1_0;
+	u16 sw_rawawb_big_x0_0;
+	u16 sw_rawawb_big_x1_0;
+	u16 sw_rawawb_big_y0_0;
+	u16 sw_rawawb_big_y1_0;
+	u16 sw_rawawb_nor_x0_1;
+	u16 sw_rawawb_nor_x1_1;
+	u16 sw_rawawb_nor_y0_1;
+	u16 sw_rawawb_nor_y1_1;
+	u16 sw_rawawb_big_x0_1;
+	u16 sw_rawawb_big_x1_1;
+	u16 sw_rawawb_big_y0_1;
+	u16 sw_rawawb_big_y1_1;
+	u16 sw_rawawb_nor_x0_2;
+	u16 sw_rawawb_nor_x1_2;
+	u16 sw_rawawb_nor_y0_2;
+	u16 sw_rawawb_nor_y1_2;
+	u16 sw_rawawb_big_x0_2;
+	u16 sw_rawawb_big_x1_2;
+	u16 sw_rawawb_big_y0_2;
+	u16 sw_rawawb_big_y1_2;
+	u16 sw_rawawb_nor_x0_3;
+	u16 sw_rawawb_nor_x1_3;
+	u16 sw_rawawb_nor_y0_3;
+	u16 sw_rawawb_nor_y1_3;
+	u16 sw_rawawb_big_x0_3;
+	u16 sw_rawawb_big_x1_3;
+	u16 sw_rawawb_big_y0_3;
+	u16 sw_rawawb_big_y1_3;
+	u16 sw_rawawb_nor_x0_4;
+	u16 sw_rawawb_nor_x1_4;
+	u16 sw_rawawb_nor_y0_4;
+	u16 sw_rawawb_nor_y1_4;
+	u16 sw_rawawb_big_x0_4;
+	u16 sw_rawawb_big_x1_4;
+	u16 sw_rawawb_big_y0_4;
+	u16 sw_rawawb_big_y1_4;
+	u16 sw_rawawb_nor_x0_5;
+	u16 sw_rawawb_nor_x1_5;
+	u16 sw_rawawb_nor_y0_5;
+	u16 sw_rawawb_nor_y1_5;
+	u16 sw_rawawb_big_x0_5;
+	u16 sw_rawawb_big_x1_5;
+	u16 sw_rawawb_big_y0_5;
+	u16 sw_rawawb_big_y1_5;
+	u16 sw_rawawb_nor_x0_6;
+	u16 sw_rawawb_nor_x1_6;
+	u16 sw_rawawb_nor_y0_6;
+	u16 sw_rawawb_nor_y1_6;
+	u16 sw_rawawb_big_x0_6;
+	u16 sw_rawawb_big_x1_6;
+	u16 sw_rawawb_big_y0_6;
+	u16 sw_rawawb_big_y1_6;
+	u16 sw_rawawb_pre_wbgain_inv_r;
+	u16 sw_rawawb_pre_wbgain_inv_g;
+	u16 sw_rawawb_pre_wbgain_inv_b;
+	u16 sw_rawawb_multiwindow0_v_offs;
+	u16 sw_rawawb_multiwindow0_h_offs;
+	u16 sw_rawawb_multiwindow0_v_size;
+	u16 sw_rawawb_multiwindow0_h_size;
+	u16 sw_rawawb_multiwindow1_v_offs;
+	u16 sw_rawawb_multiwindow1_h_offs;
+	u16 sw_rawawb_multiwindow1_v_size;
+	u16 sw_rawawb_multiwindow1_h_size;
+	u16 sw_rawawb_multiwindow2_v_offs;
+	u16 sw_rawawb_multiwindow2_h_offs;
+	u16 sw_rawawb_multiwindow2_v_size;
+	u16 sw_rawawb_multiwindow2_h_size;
+	u16 sw_rawawb_multiwindow3_v_offs;
+	u16 sw_rawawb_multiwindow3_h_offs;
+	u16 sw_rawawb_multiwindow3_v_size;
+	u16 sw_rawawb_multiwindow3_h_size;
+	u16 sw_rawawb_exc_wp_region0_xu0;
+	u16 sw_rawawb_exc_wp_region0_xu1;
+	u16 sw_rawawb_exc_wp_region0_yv0;
+	u16 sw_rawawb_exc_wp_region0_yv1;
+	u16 sw_rawawb_exc_wp_region1_xu0;
+	u16 sw_rawawb_exc_wp_region1_xu1;
+	u16 sw_rawawb_exc_wp_region1_yv0;
+	u16 sw_rawawb_exc_wp_region1_yv1;
+	u16 sw_rawawb_exc_wp_region2_xu0;
+	u16 sw_rawawb_exc_wp_region2_xu1;
+	u16 sw_rawawb_exc_wp_region2_yv0;
+	u16 sw_rawawb_exc_wp_region2_yv1;
+	u16 sw_rawawb_exc_wp_region3_xu0;
+	u16 sw_rawawb_exc_wp_region3_xu1;
+	u16 sw_rawawb_exc_wp_region3_yv0;
+	u16 sw_rawawb_exc_wp_region3_yv1;
+	u16 sw_rawawb_exc_wp_region4_xu0;
+	u16 sw_rawawb_exc_wp_region4_xu1;
+	u16 sw_rawawb_exc_wp_region4_yv0;
+	u16 sw_rawawb_exc_wp_region4_yv1;
+	u16 sw_rawawb_exc_wp_region5_xu0;
+	u16 sw_rawawb_exc_wp_region5_xu1;
+	u16 sw_rawawb_exc_wp_region5_yv0;
+	u16 sw_rawawb_exc_wp_region5_yv1;
+	u16 sw_rawawb_exc_wp_region6_xu0;
+	u16 sw_rawawb_exc_wp_region6_xu1;
+	u16 sw_rawawb_exc_wp_region6_yv0;
+	u16 sw_rawawb_exc_wp_region6_yv1;
+	u16 sw_rawawb_rgb2ryuvmat0_u;
+	u16 sw_rawawb_rgb2ryuvmat1_u;
+	u16 sw_rawawb_rgb2ryuvmat2_u;
+	u16 sw_rawawb_rgb2ryuvofs_u;
+	u16 sw_rawawb_rgb2ryuvmat0_v;
+	u16 sw_rawawb_rgb2ryuvmat1_v;
+	u16 sw_rawawb_rgb2ryuvmat2_v;
+	u16 sw_rawawb_rgb2ryuvofs_v;
+	u16 sw_rawawb_rgb2ryuvmat0_y;
+	u16 sw_rawawb_rgb2ryuvmat1_y;
+	u16 sw_rawawb_rgb2ryuvmat2_y;
+	u16 sw_rawawb_rgb2ryuvofs_y;
+	u16 sw_rawawb_th0_ls0;
+	u16 sw_rawawb_th1_ls0;
+	u16 sw_rawawb_th2_ls0;
+	u16 sw_rawawb_th3_ls0;
+	u16 sw_rawawb_th4_ls0;
+	u16 sw_rawawb_th5_ls0;
+	u16 sw_rawawb_coor_x1_ls0_u;
+	u16 sw_rawawb_coor_x1_ls0_v;
+	u16 sw_rawawb_coor_x1_ls0_y;
+	u16 sw_rawawb_vec_x21_ls0_u;
+	u16 sw_rawawb_vec_x21_ls0_v;
+	u16 sw_rawawb_vec_x21_ls0_y;
+	u16 sw_rawawb_th0_ls1;
+	u16 sw_rawawb_th1_ls1;
+	u16 sw_rawawb_th2_ls1;
+	u16 sw_rawawb_th3_ls1;
+	u16 sw_rawawb_th4_ls1;
+	u16 sw_rawawb_th5_ls1;
+	u16 sw_rawawb_coor_x1_ls1_u;
+	u16 sw_rawawb_coor_x1_ls1_v;
+	u16 sw_rawawb_coor_x1_ls1_y;
+	u16 sw_rawawb_vec_x21_ls1_u;
+	u16 sw_rawawb_vec_x21_ls1_v;
+	u16 sw_rawawb_vec_x21_ls1_y;
+	u16 sw_rawawb_th0_ls2;
+	u16 sw_rawawb_th1_ls2;
+	u16 sw_rawawb_th2_ls2;
+	u16 sw_rawawb_th3_ls2;
+	u16 sw_rawawb_th4_ls2;
+	u16 sw_rawawb_th5_ls2;
+	u16 sw_rawawb_coor_x1_ls2_u;
+	u16 sw_rawawb_coor_x1_ls2_v;
+	u16 sw_rawawb_coor_x1_ls2_y;
+	u16 sw_rawawb_vec_x21_ls2_u;
+	u16 sw_rawawb_vec_x21_ls2_v;
+	u16 sw_rawawb_vec_x21_ls2_y;
+	u16 sw_rawawb_th0_ls3;
+	u16 sw_rawawb_th1_ls3;
+	u16 sw_rawawb_th2_ls3;
+	u16 sw_rawawb_th3_ls3;
+	u16 sw_rawawb_th4_ls3;
+	u16 sw_rawawb_th5_ls3;
+	u16 sw_rawawb_coor_x1_ls3_u;
+	u16 sw_rawawb_coor_x1_ls3_v;
+	u16 sw_rawawb_coor_x1_ls3_y;
+	u16 sw_rawawb_vec_x21_ls3_u;
+	u16 sw_rawawb_vec_x21_ls3_v;
+	u16 sw_rawawb_vec_x21_ls3_y;
+
+	u32 sw_rawawb_islope01_0;
+	u32 sw_rawawb_islope12_0;
+	u32 sw_rawawb_islope23_0;
+	u32 sw_rawawb_islope30_0;
+	u32 sw_rawawb_islope01_1;
+	u32 sw_rawawb_islope12_1;
+	u32 sw_rawawb_islope23_1;
+	u32 sw_rawawb_islope30_1;
+	u32 sw_rawawb_islope01_2;
+	u32 sw_rawawb_islope12_2;
+	u32 sw_rawawb_islope23_2;
+	u32 sw_rawawb_islope30_2;
+	u32 sw_rawawb_islope01_3;
+	u32 sw_rawawb_islope12_3;
+	u32 sw_rawawb_islope23_3;
+	u32 sw_rawawb_islope30_3;
+	u32 sw_rawawb_islope01_4;
+	u32 sw_rawawb_islope12_4;
+	u32 sw_rawawb_islope23_4;
+	u32 sw_rawawb_islope30_4;
+	u32 sw_rawawb_islope01_5;
+	u32 sw_rawawb_islope12_5;
+	u32 sw_rawawb_islope23_5;
+	u32 sw_rawawb_islope30_5;
+	u32 sw_rawawb_islope01_6;
+	u32 sw_rawawb_islope12_6;
+	u32 sw_rawawb_islope23_6;
+	u32 sw_rawawb_islope30_6;
+} __attribute__ ((packed));
+
+struct isp3x_rawawb_meas_stat {
+	u16 ro_yhist_bin[ISP3X_RAWAWB_HSTBIN_NUM];
+	u32 ro_rawawb_sum_rgain_nor[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_bgain_nor[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_wp_num_nor[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_rgain_big[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_sum_bgain_big[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_rawawb_wp_num_big[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_wp_num2[ISP3X_RAWAWB_SUM_NUM];
+	u32 ro_sum_r_nor_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_sum_b_nor_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_wp_nm_nor_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_sum_r_big_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_sum_b_big_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_wp_nm_big_multiwindow[ISP3X_RAWAWB_MULWD_NUM];
+	u32 ro_sum_r_exc[ISP3X_RAWAWB_EXCL_STAT_NUM];
+	u32 ro_sum_b_exc[ISP3X_RAWAWB_EXCL_STAT_NUM];
+	u32 ro_wp_nm_exc[ISP3X_RAWAWB_EXCL_STAT_NUM];
+	struct isp2x_rawawb_ramdata ramdata[ISP3X_RAWAWB_RAMDATA_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_rawaf_curve {
+	u8 ldg_lumth;
+	u8 ldg_gain;
+	u16 ldg_gslp;
+} __attribute__ ((packed));
+
+struct isp3x_rawaf_meas_cfg {
+	u8 rawaf_sel;
+	u8 num_afm_win;
+	/* CTRL */
+	u8 gamma_en;
+	u8 gaus_en;
+	u8 v1_fir_sel;
+	u8 hiir_en;
+	u8 viir_en;
+	u8 accu_8bit_mode;
+	u8 ldg_en;
+	u8 h1_fv_mode;
+	u8 h2_fv_mode;
+	u8 v1_fv_mode;
+	u8 v2_fv_mode;
+	u8 ae_mode;
+	u8 y_mode;
+	/* WINA_B */
+	struct isp2x_window win[ISP3X_RAWAF_WIN_NUM];
+	/* INT_LINE */
+	u8 line_num[ISP3X_RAWAF_LINE_NUM];
+	u8 line_en[ISP3X_RAWAF_LINE_NUM];
+	/* THRES */
+	u16 afm_thres;
+	/* VAR_SHIFT */
+	u8 afm_var_shift[ISP3X_RAWAF_WIN_NUM];
+	u8 lum_var_shift[ISP3X_RAWAF_WIN_NUM];
+	/* HVIIR_VAR_SHIFT */
+	u8 h1iir_var_shift;
+	u8 h2iir_var_shift;
+	u8 v1iir_var_shift;
+	u8 v2iir_var_shift;
+	/* GAMMA_Y */
+	u16 gamma_y[ISP3X_RAWAF_GAMMA_NUM];
+	/* HIIR_THRESH */
+	u16 h_fv_thresh;
+	u16 v_fv_thresh;
+	struct isp3x_rawaf_curve curve_h[ISP3X_RAWAF_CURVE_NUM];
+	struct isp3x_rawaf_curve curve_v[ISP3X_RAWAF_CURVE_NUM];
+	s16 h1iir1_coe[ISP3X_RAWAF_HIIR_COE_NUM];
+	s16 h1iir2_coe[ISP3X_RAWAF_HIIR_COE_NUM];
+	s16 h2iir1_coe[ISP3X_RAWAF_HIIR_COE_NUM];
+	s16 h2iir2_coe[ISP3X_RAWAF_HIIR_COE_NUM];
+	s16 v1iir_coe[ISP3X_RAWAF_V1IIR_COE_NUM];
+	s16 v2iir_coe[ISP3X_RAWAF_V2IIR_COE_NUM];
+	s16 v1fir_coe[ISP3X_RAWAF_VFIR_COE_NUM];
+	s16 v2fir_coe[ISP3X_RAWAF_VFIR_COE_NUM];
+	u16 highlit_thresh;
+} __attribute__ ((packed));
+
+struct isp3x_rawaf_ramdata {
+	u32 v1;
+	u32 v2;
+	u32 h1;
+	u32 h2;
+} __attribute__ ((packed));
+
+struct isp3x_rawaf_stat {
+	u32 int_state;
+	u32 afm_sum_b;
+	u32 afm_lum_b;
+	u32 highlit_cnt_winb;
+	struct isp3x_rawaf_ramdata ramdata[ISP3X_RAWAF_SUMDATA_NUM];
+} __attribute__ ((packed));
+
+struct isp3x_cac_cfg {
+	u8 bypass_en;
+	u8 center_en;
+
+	u8 psf_sft_bit;
+	u16 cfg_num;
+
+	u16 center_width;
+	u16 center_height;
+
+	u16 strength[ISP3X_CAC_STRENGTH_NUM];
+
+	u32 hsize;
+	u32 vsize;
+	s32 buf_fd;
+} __attribute__ ((packed));
+
+struct isp3x_gain_cfg {
+	u32 g0;
+	u16 g1;
+	u16 g2;
+} __attribute__ ((packed));
+
+struct isp3x_isp_other_cfg {
+	struct isp21_bls_cfg bls_cfg;
+	struct isp2x_dpcc_cfg dpcc_cfg;
+	struct isp3x_lsc_cfg lsc_cfg;
+	struct isp21_awb_gain_cfg awb_gain_cfg;
+	struct isp21_gic_cfg gic_cfg;
+	struct isp2x_debayer_cfg debayer_cfg;
+	struct isp21_ccm_cfg ccm_cfg;
+	struct isp3x_gammaout_cfg gammaout_cfg;
+	struct isp2x_cproc_cfg cproc_cfg;
+	struct isp2x_ie_cfg ie_cfg;
+	struct isp2x_sdg_cfg sdg_cfg;
+	struct isp3x_drc_cfg drc_cfg;
+	struct isp3x_hdrmge_cfg hdrmge_cfg;
+	struct isp3x_dhaz_cfg dhaz_cfg;
+	struct isp2x_3dlut_cfg isp3dlut_cfg;
+	struct isp2x_ldch_cfg ldch_cfg;
+	struct isp3x_baynr_cfg baynr_cfg;
+	struct isp3x_bay3d_cfg bay3d_cfg;
+	struct isp3x_ynr_cfg ynr_cfg;
+	struct isp3x_cnr_cfg cnr_cfg;
+	struct isp3x_sharp_cfg sharp_cfg;
+	struct isp3x_cac_cfg cac_cfg;
+	struct isp3x_gain_cfg gain_cfg;
+	struct isp21_csm_cfg csm_cfg;
+} __attribute__ ((packed));
+
+struct isp3x_isp_meas_cfg {
+	struct isp3x_rawaf_meas_cfg rawaf;
+	struct isp3x_rawawb_meas_cfg rawawb;
+	struct isp2x_rawaelite_meas_cfg rawae0;
+	struct isp2x_rawaebig_meas_cfg rawae1;
+	struct isp2x_rawaebig_meas_cfg rawae2;
+	struct isp2x_rawaebig_meas_cfg rawae3;
+	struct isp2x_rawhistlite_cfg rawhist0;
+	struct isp2x_rawhistbig_cfg rawhist1;
+	struct isp2x_rawhistbig_cfg rawhist2;
+	struct isp2x_rawhistbig_cfg rawhist3;
+} __attribute__ ((packed));
+
+struct isp3x_isp_params_cfg {
+	u64 module_en_update;
+	u64 module_ens;
+	u64 module_cfg_update;
+
+	u32 frame_id;
+	struct isp3x_isp_meas_cfg meas;
+	struct isp3x_isp_other_cfg others;
+} __attribute__ ((packed));
+
+struct isp3x_stat {
+	struct isp2x_rawaebig_stat rawae3;
+	struct isp2x_rawaebig_stat rawae1;
+	struct isp2x_rawaebig_stat rawae2;
+	struct isp2x_rawaelite_stat rawae0;
+	struct isp2x_rawhistbig_stat rawhist3;
+	struct isp2x_rawhistlite_stat rawhist0;
+	struct isp2x_rawhistbig_stat rawhist1;
+	struct isp2x_rawhistbig_stat rawhist2;
+	struct isp3x_rawaf_stat rawaf;
+	struct isp3x_rawawb_meas_stat rawawb;
+	struct isp3x_dhaz_stat dhaz;
+	struct isp2x_bls_stat bls;
+} __attribute__ ((packed));
+
+/**
+ * struct rkisp3x_isp_stat_buffer - Rockchip ISP3 Statistics Meta Data
+ *
+ * @meas_type: measurement types (ISP3X_STAT_ definitions)
+ * @frame_id: frame ID for sync
+ * @params: statistics data
+ */
+struct rkisp3x_isp_stat_buffer {
+	u32 meas_type;
+	u32 frame_id;
+	struct isp3x_stat params;
+} __attribute__ ((packed));
+
+#endif /* _UAPI_RKISP3_CONFIG_H */
diff --git a/include/uapi/linux/rkispp-config.h b/include/uapi/linux/rkispp-config.h
new file mode 100644
index 000000000..b4a27f74f
--- /dev/null
+++ b/include/uapi/linux/rkispp-config.h
@@ -0,0 +1,370 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT)
+ *
+ * Copyright (C) 2019 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef _UAPI_RKISPP_CONFIG_H
+#define _UAPI_RKISPP_CONFIG_H
+
+#include <linux/types.h>
+#include <linux/v4l2-controls.h>
+
+#define ISPP_API_VERSION		KERNEL_VERSION(1, 8, 0)
+
+#define ISPP_ID_TNR			(0)
+#define ISPP_ID_NR			(1)
+#define ISPP_ID_SHP			(2)
+#define ISPP_ID_FEC			(3)
+#define ISPP_ID_ORB			(4)
+#define ISPP_ID_MAX			(5)
+
+#define ISPP_MODULE_TNR			BIT(ISPP_ID_TNR)//2TO1
+#define ISPP_MODULE_NR			BIT(ISPP_ID_NR)
+#define ISPP_MODULE_SHP			BIT(ISPP_ID_SHP)
+#define ISPP_MODULE_FEC			BIT(ISPP_ID_FEC)//CALIBRATION
+#define ISPP_MODULE_ORB			BIT(ISPP_ID_ORB)
+//extra function
+#define ISPP_MODULE_TNR_3TO1		(BIT(16) | ISPP_MODULE_TNR)
+#define ISPP_MODULE_FEC_ST		(BIT(17) | ISPP_MODULE_FEC)//STABILIZATION
+
+#define TNR_SIGMA_CURVE_SIZE		17
+#define TNR_LUMA_CURVE_SIZE		6
+#define TNR_GFCOEF6_SIZE		6
+#define TNR_GFCOEF3_SIZE		3
+#define TNR_SCALE_YG_SIZE		4
+#define TNR_SCALE_YL_SIZE		3
+#define TNR_SCALE_CG_SIZE		3
+#define TNR_SCALE_Y2CG_SIZE		3
+#define TNR_SCALE_CL_SIZE		2
+#define TNR_SCALE_Y2CL_SIZE		3
+#define TNR_WEIGHT_Y_SIZE		3
+
+#define NR_UVNR_UVGAIN_SIZE		2
+#define NR_UVNR_T1FLT_WTQ_SIZE		8
+#define NR_UVNR_T2GEN_WTQ_SIZE		4
+#define NR_UVNR_T2FLT_WT_SIZE		3
+#define NR_YNR_SGM_DX_SIZE		16
+#define NR_YNR_SGM_Y_SIZE		17
+#define NR_YNR_HWEIT_D_SIZE		20
+#define NR_YNR_HGRAD_Y_SIZE		24
+#define NR_YNR_HSTV_Y_SIZE		17
+#define NR_YNR_CI_SIZE			4
+#define NR_YNR_LGAIN_MIN_SIZE		4
+#define NR_YNR_LWEIT_FLT_SIZE		4
+#define NR_YNR_HGAIN_SGM_SIZE		4
+#define NR_YNR_HWEIT_SIZE		4
+#define NR_YNR_LWEIT_CMP_SIZE		2
+#define NR_YNR_ST_SCALE_SIZE		3
+
+#define SHP_PBF_KERNEL_SIZE		3
+#define SHP_MRF_KERNEL_SIZE		6
+#define SHP_MBF_KERNEL_SIZE		12
+#define SHP_HRF_KERNEL_SIZE		6
+#define SHP_HBF_KERNEL_SIZE		3
+#define SHP_EDGE_COEF_SIZE		3
+#define SHP_EDGE_SMOTH_SIZE		3
+#define SHP_EDGE_GAUS_SIZE		6
+#define SHP_DOG_KERNEL_SIZE		6
+#define SHP_LUM_POINT_SIZE		6
+#define SHP_SIGMA_SIZE			8
+#define SHP_LUM_CLP_SIZE		8
+#define SHP_LUM_MIN_SIZE		8
+#define SHP_EDGE_LUM_THED_SIZE		8
+#define SHP_CLAMP_SIZE			8
+#define SHP_DETAIL_ALPHA_SIZE		8
+
+#define ORB_DATA_NUM			10000
+#define ORB_BRIEF_NUM			15
+#define ORB_DUMMY_NUM			13
+
+#define FEC_MESH_XY_POINT_SIZE		6
+#define FEC_MESH_XY_NUM			131072
+#define FEC_MESH_BUF_NUM		2
+
+#define TNR_BUF_IDXFD_NUM		64
+
+/************VIDIOC_PRIVATE*************/
+#define RKISPP_CMD_GET_FECBUF_INFO	\
+	_IOR('V', BASE_VIDIOC_PRIVATE + 0, struct rkispp_fecbuf_info)
+
+#define RKISPP_CMD_SET_FECBUF_SIZE	\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 1, struct rkispp_fecbuf_size)
+
+#define RKISPP_CMD_FEC_IN_OUT \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 10, struct rkispp_fec_in_out)
+
+#define RKISPP_CMD_TRIGGER_YNRRUN       \
+	_IOW('V', BASE_VIDIOC_PRIVATE + 11, struct rkispp_tnr_inf)
+
+#define RKISPP_CMD_GET_TNRBUF_FD \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 12, struct rkispp_buf_idxfd)
+
+#define RKISPP_CMD_TRIGGER_MODE		\
+	_IOW('V', BASE_VIDIOC_PRIVATE + 13, struct rkispp_trigger_mode)
+
+/************EVENT_PRIVATE**************/
+#define RKISPP_V4L2_EVENT_TNR_COMPLETE  \
+	(V4L2_EVENT_PRIVATE_START + 3)
+
+struct rkispp_fec_in_out {
+	int width;
+	int height;
+	int in_fourcc;
+	int out_fourcc;
+	int in_pic_fd;
+	int out_pic_fd;
+	int mesh_xint_fd;
+	int mesh_xfra_fd;
+	int mesh_yint_fd;
+	int mesh_yfra_fd;
+};
+
+struct rkispp_tnr_inf {
+	u32 dev_id;
+	u32 frame_id;
+	u32 gainkg_idx;
+	u32 gainwr_idx;
+	u32 gainkg_size;
+	u32 gainwr_size;
+} __attribute__ ((packed));
+
+struct rkispp_buf_idxfd {
+	u32 buf_num;
+	u32 index[TNR_BUF_IDXFD_NUM];
+	s32 dmafd[TNR_BUF_IDXFD_NUM];
+} __attribute__ ((packed));
+
+struct rkispp_trigger_mode {
+	u32 module;
+	u32 on;
+} __attribute__ ((packed));
+
+struct rkispp_tnr_config {
+	u8 opty_en;
+	u8 optc_en;
+	u8 gain_en;
+	u8 pk0_y;
+	u8 pk1_y;
+	u8 pk0_c;
+	u8 pk1_c;
+	u8 glb_gain_cur_sqrt;
+	u8 sigma_x[TNR_SIGMA_CURVE_SIZE - 1];
+	u8 gfcoef_y0[TNR_GFCOEF6_SIZE];
+	u8 gfcoef_y1[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_y2[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_y3[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_yg0[TNR_GFCOEF6_SIZE];
+	u8 gfcoef_yg1[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_yg2[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_yg3[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_yl0[TNR_GFCOEF6_SIZE];
+	u8 gfcoef_yl1[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_yl2[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_cg0[TNR_GFCOEF6_SIZE];
+	u8 gfcoef_cg1[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_cg2[TNR_GFCOEF3_SIZE];
+	u8 gfcoef_cl0[TNR_GFCOEF6_SIZE];
+	u8 gfcoef_cl1[TNR_GFCOEF3_SIZE];
+	u8 weight_y[TNR_WEIGHT_Y_SIZE];
+
+	u16 glb_gain_cur __attribute__((aligned(2)));
+	u16 glb_gain_nxt;
+	u16 glb_gain_cur_div;
+	u16 txt_th1_y;
+	u16 txt_th0_c;
+	u16 txt_th1_c;
+	u16 txt_thy_dlt;
+	u16 txt_thc_dlt;
+	u16 txt_th0_y;
+	u16 sigma_y[TNR_SIGMA_CURVE_SIZE];
+	u16 luma_curve[TNR_LUMA_CURVE_SIZE];
+	u16 scale_yg[TNR_SCALE_YG_SIZE];
+	u16 scale_yl[TNR_SCALE_YL_SIZE];
+	u16 scale_cg[TNR_SCALE_CG_SIZE];
+	u16 scale_y2cg[TNR_SCALE_Y2CG_SIZE];
+	u16 scale_cl[TNR_SCALE_CL_SIZE];
+	u16 scale_y2cl[TNR_SCALE_Y2CL_SIZE];
+} __attribute__ ((packed));
+
+struct rkispp_nr_config {
+	u8 uvnr_step1_en;
+	u8 uvnr_step2_en;
+	u8 nr_gain_en;
+	u8 uvnr_sd32_self_en;
+	u8 uvnr_nobig_en;
+	u8 uvnr_big_en;
+	u8 uvnr_gain_1sigma;
+	u8 uvnr_gain_offset;
+	u8 uvnr_gain_t2gen;
+	u8 uvnr_gain_iso;
+	u8 uvnr_t1gen_m3alpha;
+	u8 uvnr_t1flt_mode;
+	u8 uvnr_t1flt_wtp;
+	u8 uvnr_t2gen_m3alpha;
+	u8 uvnr_t2gen_wtp;
+	u8 uvnr_gain_uvgain[NR_UVNR_UVGAIN_SIZE];
+	u8 uvnr_t1flt_wtq[NR_UVNR_T1FLT_WTQ_SIZE];
+	u8 uvnr_t2gen_wtq[NR_UVNR_T2GEN_WTQ_SIZE];
+	u8 uvnr_t2flt_wtp;
+	u8 uvnr_t2flt_wt[NR_UVNR_T2FLT_WT_SIZE];
+	u8 ynr_sgm_dx[NR_YNR_SGM_DX_SIZE];
+	u8 ynr_lci[NR_YNR_CI_SIZE];
+	u8 ynr_lgain_min[NR_YNR_LGAIN_MIN_SIZE];
+	u8 ynr_lgain_max;
+	u8 ynr_lmerge_bound;
+	u8 ynr_lmerge_ratio;
+	u8 ynr_lweit_flt[NR_YNR_LWEIT_FLT_SIZE];
+	u8 ynr_hlci[NR_YNR_CI_SIZE];
+	u8 ynr_lhci[NR_YNR_CI_SIZE];
+	u8 ynr_hhci[NR_YNR_CI_SIZE];
+	u8 ynr_hgain_sgm[NR_YNR_HGAIN_SGM_SIZE];
+	u8 ynr_hweit_d[NR_YNR_HWEIT_D_SIZE];
+	u8 ynr_hgrad_y[NR_YNR_HGRAD_Y_SIZE];
+	u8 ynr_hmax_adjust;
+	u8 ynr_hstrength;
+	u8 ynr_lweit_cmp[NR_YNR_LWEIT_CMP_SIZE];
+	u8 ynr_lmaxgain_lv4;
+
+	u16 uvnr_t1flt_msigma __attribute__((aligned(2)));
+	u16 uvnr_t2gen_msigma;
+	u16 uvnr_t2flt_msigma;
+	u16 ynr_lsgm_y[NR_YNR_SGM_Y_SIZE];
+	u16 ynr_hsgm_y[NR_YNR_SGM_Y_SIZE];
+	u16 ynr_hweit[NR_YNR_HWEIT_SIZE];
+	u16 ynr_hstv_y[NR_YNR_HSTV_Y_SIZE];
+	u16 ynr_st_scale[NR_YNR_ST_SCALE_SIZE];
+} __attribute__ ((packed));
+
+struct rkispp_sharp_config {
+	u8 rotation;
+	u8 scl_down_v;
+	u8 scl_down_h;
+	u8 tile_ycnt;
+	u8 tile_xcnt;
+	u8 alpha_adp_en;
+	u8 yin_flt_en;
+	u8 edge_avg_en;
+	u8 ehf_th;
+	u8 pbf_ratio;
+	u8 edge_thed;
+	u8 dir_min;
+	u8 pbf_shf_bits;
+	u8 mbf_shf_bits;
+	u8 hbf_shf_bits;
+	u8 m_ratio;
+	u8 h_ratio;
+	u8 pbf_k[SHP_PBF_KERNEL_SIZE];
+	u8 mrf_k[SHP_MRF_KERNEL_SIZE];
+	u8 mbf_k[SHP_MBF_KERNEL_SIZE];
+	u8 hrf_k[SHP_HRF_KERNEL_SIZE];
+	u8 hbf_k[SHP_HBF_KERNEL_SIZE];
+	s8 eg_coef[SHP_EDGE_COEF_SIZE];
+	u8 eg_smoth[SHP_EDGE_SMOTH_SIZE];
+	u8 eg_gaus[SHP_EDGE_GAUS_SIZE];
+	s8 dog_k[SHP_DOG_KERNEL_SIZE];
+	u8 lum_point[SHP_LUM_POINT_SIZE];
+	u8 pbf_sigma[SHP_SIGMA_SIZE];
+	u8 lum_clp_m[SHP_LUM_CLP_SIZE];
+	s8 lum_min_m[SHP_LUM_MIN_SIZE];
+	u8 mbf_sigma[SHP_SIGMA_SIZE];
+	u8 lum_clp_h[SHP_LUM_CLP_SIZE];
+	u8 hbf_sigma[SHP_SIGMA_SIZE];
+	u8 edge_lum_thed[SHP_EDGE_LUM_THED_SIZE];
+	u8 clamp_pos[SHP_CLAMP_SIZE];
+	u8 clamp_neg[SHP_CLAMP_SIZE];
+	u8 detail_alpha[SHP_DETAIL_ALPHA_SIZE];
+
+	u16 hbf_ratio __attribute__((aligned(2)));
+	u16 smoth_th4;
+	u16 l_alpha;
+	u16 g_alpha;
+	u16 rfl_ratio;
+	u16 rfh_ratio;
+} __attribute__ ((packed));
+
+enum rkispp_fecbuf_stat {
+	FEC_BUF_INIT = 0,
+	FEC_BUF_WAIT2CHIP,
+	FEC_BUF_CHIPINUSE,
+};
+
+struct rkispp_fecbuf_info {
+	s32 buf_fd[FEC_MESH_BUF_NUM];
+	u32 buf_size[FEC_MESH_BUF_NUM];
+} __attribute__ ((packed));
+
+struct rkispp_fecbuf_size {
+	u32 meas_width;
+	u32 meas_height;
+	u32 meas_mode;
+} __attribute__ ((packed));
+
+struct rkispp_fec_head {
+	enum rkispp_fecbuf_stat stat;
+	u32 meshxf_oft;
+	u32 meshyf_oft;
+	u32 meshxi_oft;
+	u32 meshyi_oft;
+} __attribute__ ((packed));
+
+struct rkispp_fec_config {
+	u8 mesh_density;
+	u8 crop_en;
+	u16 crop_width __attribute__((aligned(2)));
+	u16 crop_height;
+	u32 mesh_size __attribute__((aligned(4)));
+	s32 buf_fd;
+} __attribute__ ((packed));
+
+struct rkispp_orb_config {
+	u8 limit_value;
+	u32 max_feature __attribute__((aligned(4)));
+} __attribute__ ((packed));
+
+/**
+ * struct rkispp_params_cfg - Rockchip ISPP Input Parameters Meta Data
+ *
+ * @module_en_update: mask the enable bits of which module  should be updated
+ * @module_ens: mask the enable value of each module, only update the module
+ * which correspond bit was set in module_en_update
+ * @module_cfg_update: mask the config bits of which module  should be updated
+ * @module_init_en: initial enable module function
+ */
+struct rkispp_params_cfg {
+	u32 module_en_update;
+	u32 module_ens;
+	u32 module_cfg_update;
+	u32 module_init_ens;
+
+	u32 frame_id;
+	struct rkispp_tnr_config tnr_cfg;
+	struct rkispp_nr_config nr_cfg;
+	struct rkispp_sharp_config shp_cfg;
+	struct rkispp_fec_config fec_cfg;
+	struct rkispp_orb_config orb_cfg;
+} __attribute__ ((packed));
+
+struct rkispp_orb_data {
+	u8 brief[ORB_BRIEF_NUM];
+	u32 y : 13;
+	u32 x : 13;
+	u32 dmy1 : 6;
+	u8 dmy2[ORB_DUMMY_NUM];
+} __attribute__ ((packed));
+
+/**
+ * struct rkispp_stats_buffer - Rockchip ISPP Statistics
+ *
+ * @meas_type: measurement types
+ * @frame_id: frame ID for sync
+ * @data: statistics data
+ */
+struct rkispp_stats_buffer {
+	struct rkispp_orb_data data[ORB_DATA_NUM];
+
+	u32 total_num __attribute__((aligned(4)));
+	u32 meas_type;
+	u32 frame_id;
+} __attribute__ ((packed));
+
+#endif
diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index f51bc8f36..7e3fe68af 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -30,6 +30,7 @@
  * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+#define UART_IER_PTIME		0x80 /* Enable programmable transmit interrupt mode */
 
 #define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h
index 0f865ae4b..17ce56198 100644
--- a/include/uapi/linux/usb/ch9.h
+++ b/include/uapi/linux/usb/ch9.h
@@ -968,9 +968,22 @@ struct usb_ssp_cap_descriptor {
 	__le32 bmSublinkSpeedAttr[1]; /* list of sublink speed attrib entries */
 #define USB_SSP_SUBLINK_SPEED_SSID	(0xf)		/* sublink speed ID */
 #define USB_SSP_SUBLINK_SPEED_LSE	(0x3 << 4)	/* Lanespeed exponent */
+#define USB_SSP_SUBLINK_SPEED_LSE_BPS		0
+#define USB_SSP_SUBLINK_SPEED_LSE_KBPS		1
+#define USB_SSP_SUBLINK_SPEED_LSE_MBPS		2
+#define USB_SSP_SUBLINK_SPEED_LSE_GBPS		3
+
 #define USB_SSP_SUBLINK_SPEED_ST	(0x3 << 6)	/* Sublink type */
+#define USB_SSP_SUBLINK_SPEED_ST_SYM_RX		0
+#define USB_SSP_SUBLINK_SPEED_ST_ASYM_RX	1
+#define USB_SSP_SUBLINK_SPEED_ST_SYM_TX		2
+#define USB_SSP_SUBLINK_SPEED_ST_ASYM_TX	3
+
 #define USB_SSP_SUBLINK_SPEED_RSVD	(0x3f << 8)	/* Reserved */
 #define USB_SSP_SUBLINK_SPEED_LP	(0x3 << 14)	/* Link protocol */
+#define USB_SSP_SUBLINK_SPEED_LP_SS		0
+#define USB_SSP_SUBLINK_SPEED_LP_SSP		1
+
 #define USB_SSP_SUBLINK_SPEED_LSM	(0xff << 16)	/* Lanespeed mantissa */
 } __attribute__((packed));
 
diff --git a/include/uapi/linux/usb/f_accessory.h b/include/uapi/linux/usb/f_accessory.h
new file mode 100644
index 000000000..0baeb7d0d
--- /dev/null
+++ b/include/uapi/linux/usb/f_accessory.h
@@ -0,0 +1,146 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _UAPI_LINUX_USB_F_ACCESSORY_H
+#define _UAPI_LINUX_USB_F_ACCESSORY_H
+
+/* Use Google Vendor ID when in accessory mode */
+#define USB_ACCESSORY_VENDOR_ID 0x18D1
+
+
+/* Product ID to use when in accessory mode */
+#define USB_ACCESSORY_PRODUCT_ID 0x2D00
+
+/* Product ID to use when in accessory mode and adb is enabled */
+#define USB_ACCESSORY_ADB_PRODUCT_ID 0x2D01
+
+/* Indexes for strings sent by the host via ACCESSORY_SEND_STRING */
+#define ACCESSORY_STRING_MANUFACTURER   0
+#define ACCESSORY_STRING_MODEL          1
+#define ACCESSORY_STRING_DESCRIPTION    2
+#define ACCESSORY_STRING_VERSION        3
+#define ACCESSORY_STRING_URI            4
+#define ACCESSORY_STRING_SERIAL         5
+
+/* Control request for retrieving device's protocol version
+ *
+ *	requestType:    USB_DIR_IN | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_GET_PROTOCOL
+ *	value:          0
+ *	index:          0
+ *	data            version number (16 bits little endian)
+ *                     1 for original accessory support
+ *                     2 adds HID and device to host audio support
+ */
+#define ACCESSORY_GET_PROTOCOL  51
+
+/* Control request for host to send a string to the device
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SEND_STRING
+ *	value:          0
+ *	index:          string ID
+ *	data            zero terminated UTF8 string
+ *
+ *  The device can later retrieve these strings via the
+ *  ACCESSORY_GET_STRING_* ioctls
+ */
+#define ACCESSORY_SEND_STRING   52
+
+/* Control request for starting device in accessory mode.
+ * The host sends this after setting all its strings to the device.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_START
+ *	value:          0
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_START         53
+
+/* Control request for registering a HID device.
+ * Upon registering, a unique ID is sent by the accessory in the
+ * value parameter. This ID will be used for future commands for
+ * the device
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_REGISTER_HID_DEVICE
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          total length of the HID report descriptor
+ *	data            none
+ */
+#define ACCESSORY_REGISTER_HID         54
+
+/* Control request for unregistering a HID device.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_REGISTER_HID
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_UNREGISTER_HID         55
+
+/* Control request for sending the HID report descriptor.
+ * If the HID descriptor is longer than the endpoint zero max packet size,
+ * the descriptor will be sent in multiple ACCESSORY_SET_HID_REPORT_DESC
+ * commands. The data for the descriptor must be sent sequentially
+ * if multiple packets are needed.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SET_HID_REPORT_DESC
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          offset of data in descriptor
+ *                      (needed when HID descriptor is too big for one packet)
+ *	data            the HID report descriptor
+ */
+#define ACCESSORY_SET_HID_REPORT_DESC         56
+
+/* Control request for sending HID events.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SEND_HID_EVENT
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          0
+ *	data            the HID report for the event
+ */
+#define ACCESSORY_SEND_HID_EVENT         57
+
+/* Control request for setting the audio mode.
+ *
+ *	requestType:	USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SET_AUDIO_MODE
+ *	value:          0 - no audio
+ *                     1 - device to host, 44100 16-bit stereo PCM
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_SET_AUDIO_MODE         58
+
+/* ioctls for retrieving strings set by the host */
+#define ACCESSORY_GET_STRING_MANUFACTURER   _IOW('M', 1, char[256])
+#define ACCESSORY_GET_STRING_MODEL          _IOW('M', 2, char[256])
+#define ACCESSORY_GET_STRING_DESCRIPTION    _IOW('M', 3, char[256])
+#define ACCESSORY_GET_STRING_VERSION        _IOW('M', 4, char[256])
+#define ACCESSORY_GET_STRING_URI            _IOW('M', 5, char[256])
+#define ACCESSORY_GET_STRING_SERIAL         _IOW('M', 6, char[256])
+/* returns 1 if there is a start request pending */
+#define ACCESSORY_IS_START_REQUESTED        _IO('M', 7)
+/* returns audio mode (set via the ACCESSORY_SET_AUDIO_MODE control request) */
+#define ACCESSORY_GET_AUDIO_MODE            _IO('M', 8)
+
+#endif /* _UAPI_LINUX_USB_F_ACCESSORY_H */
diff --git a/include/uapi/linux/usb/g_uvc.h b/include/uapi/linux/usb/g_uvc.h
index 652f169a0..428926e35 100644
--- a/include/uapi/linux/usb/g_uvc.h
+++ b/include/uapi/linux/usb/g_uvc.h
@@ -19,7 +19,9 @@
 #define UVC_EVENT_STREAMOFF		(V4L2_EVENT_PRIVATE_START + 3)
 #define UVC_EVENT_SETUP			(V4L2_EVENT_PRIVATE_START + 4)
 #define UVC_EVENT_DATA			(V4L2_EVENT_PRIVATE_START + 5)
-#define UVC_EVENT_LAST			(V4L2_EVENT_PRIVATE_START + 5)
+#define UVC_EVENT_SUSPEND		(V4L2_EVENT_PRIVATE_START + 6)
+#define UVC_EVENT_RESUME		(V4L2_EVENT_PRIVATE_START + 7)
+#define UVC_EVENT_LAST			(V4L2_EVENT_PRIVATE_START + 7)
 
 struct uvc_request_data {
 	__s32 length;
diff --git a/include/uapi/linux/usb/video.h b/include/uapi/linux/usb/video.h
index bfdae12cd..b82436fd9 100644
--- a/include/uapi/linux/usb/video.h
+++ b/include/uapi/linux/usb/video.h
@@ -567,5 +567,63 @@ struct UVC_FRAME_MJPEG(n) {				\
 	__le32 dwFrameInterval[n];			\
 } __attribute__ ((packed))
 
+/* Frame Based Payload - 3.1.1. Frame Based Video Format Descriptor */
+struct uvc_format_framebased {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFormatIndex;
+	__u8  bNumFrameDescriptors;
+	__u8  guidFormat[16];
+	__u8  bBitsPerPixel;
+	__u8  bDefaultFrameIndex;
+	__u8  bAspectRatioX;
+	__u8  bAspectRatioY;
+	__u8  bmInterfaceFlags;
+	__u8  bCopyProtect;
+	__u8  bVariableSize;
+} __attribute__((__packed__));
+
+#define UVC_DT_FORMAT_FRAMEBASED_SIZE			28
+
+/* Frame Based Payload - 3.1.2. Frame Based Video Frame Descriptor */
+struct uvc_frame_framebased {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFrameIndex;
+	__u8  bmCapabilities;
+	__u16 wWidth;
+	__u16 wHeight;
+	__u32 dwMinBitRate;
+	__u32 dwMaxBitRate;
+	__u32 dwDefaultFrameInterval;
+	__u8  bFrameIntervalType;
+	__u32 dwBytesPerLine;
+	__u32 dwFrameInterval[];
+} __attribute__((__packed__));
+
+#define UVC_DT_FRAME_FRAMEBASED_SIZE(n)                        (26+4*(n))
+
+#define UVC_FRAME_FRAMEBASED(n) \
+	uvc_frame_framebased_##n
+
+#define DECLARE_UVC_FRAME_FRAMEBASED(n)		\
+struct UVC_FRAME_FRAMEBASED(n) {		\
+	__u8  bLength;				\
+	__u8  bDescriptorType;			\
+	__u8  bDescriptorSubType;		\
+	__u8  bFrameIndex;			\
+	__u8  bmCapabilities;			\
+	__u16 wWidth;				\
+	__u16 wHeight;				\
+	__u32 dwMinBitRate;			\
+	__u32 dwMaxBitRate;			\
+	__u32 dwDefaultFrameInterval;		\
+	__u8  bFrameIntervalType;		\
+	__u32 dwBytesPerLine;			\
+	__u32 dwFrameInterval[n];		\
+} __attribute__ ((packed))
+
 #endif /* __LINUX_USB_VIDEO_H */
 
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index a184c4939..a3eb68372 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -188,6 +188,12 @@ enum v4l2_colorfx {
  */
 #define V4L2_CID_USER_MAX217X_BASE		(V4L2_CID_USER_BASE + 0x1090)
 
+/*
+ * The base for the tc35874x driver controls.
+ * We reserve 16 controls for this driver.
+ */
+#define V4L2_CID_USER_TC35874X_BASE		(V4L2_CID_USER_BASE + 0x10a0)
+
 /* The base for the imx driver controls.
  * We reserve 16 controls for this driver. */
 #define V4L2_CID_USER_IMX_BASE			(V4L2_CID_USER_BASE + 0x10b0)
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 534eaa4d3..eb01fb549 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -689,6 +689,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
 #define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
 #define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
+#define V4L2_PIX_FMT_H265     v4l2_fourcc('H', '2', '6', '5') /* H265 with start codes */
 #define V4L2_PIX_FMT_H264     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
 #define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
 #define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
diff --git a/include/uapi/misc/rkflash_vendor_storage.h b/include/uapi/misc/rkflash_vendor_storage.h
new file mode 100644
index 000000000..c35a1bbd8
--- /dev/null
+++ b/include/uapi/misc/rkflash_vendor_storage.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+
+/* Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd */
+
+#include <linux/ioctl.h>
+
+#ifndef _RKFLASH_VENDOR_STORAGE
+#define _RKFLASH_VENDOR_STORAGE
+
+struct RK_VENDOR_REQ {
+	__u32 tag;
+	__u16 id;
+	__u16 len;
+	__u8 data[1024];
+};
+
+#define VENDOR_REQ_TAG		0x56524551
+#define VENDOR_READ_IO		_IOW('v', 0x01, __u32)
+#define VENDOR_WRITE_IO		_IOW('v', 0x02, __u32)
+
+#endif
-- 
2.25.1

