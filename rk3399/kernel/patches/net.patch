From 7099268326a5e6890818e484659fce9089cfa7e2 Mon Sep 17 00:00:00 2001
From: jiewangdp <jiewangdp@isoftstone.com>
Date: Sat, 11 Jun 2022 16:18:31 +0800
Subject: [PATCH] net

Change-Id: I207abadfe2697c7556ac65e8f27cc28e167f10a4
---
 net/bluetooth/l2cap_sock.c |  10 +-
 net/bluetooth/sco.c        |  42 +-
 net/rfkill/Kconfig         |   9 +
 net/rfkill/Makefile        |   2 +
 net/rfkill/rfkill-bt.c     | 827 +++++++++++++++++++++++++++++++
 net/rfkill/rfkill-wlan.c   | 978 +++++++++++++++++++++++++++++++++++++
 6 files changed, 1834 insertions(+), 34 deletions(-)
 create mode 100644 net/rfkill/rfkill-bt.c
 create mode 100644 net/rfkill/rfkill-wlan.c

diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index 160c016a5..c99d65ef1 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -1508,9 +1508,6 @@ static void l2cap_sock_close_cb(struct l2cap_chan *chan)
 {
 	struct sock *sk = chan->data;
 
-	if (!sk)
-		return;
-
 	l2cap_sock_kill(sk);
 }
 
@@ -1519,9 +1516,6 @@ static void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)
 	struct sock *sk = chan->data;
 	struct sock *parent;
 
-	if (!sk)
-		return;
-
 	BT_DBG("chan %p state %s", chan, state_to_string(chan->state));
 
 	/* This callback can be called both for server (BT_LISTEN)
@@ -1713,10 +1707,8 @@ static void l2cap_sock_destruct(struct sock *sk)
 {
 	BT_DBG("sk %p", sk);
 
-	if (l2cap_pi(sk)->chan) {
-		l2cap_pi(sk)->chan->data = NULL;
+	if (l2cap_pi(sk)->chan)
 		l2cap_chan_put(l2cap_pi(sk)->chan);
-	}
 
 	if (l2cap_pi(sk)->rx_busy_skb) {
 		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 918df8d0e..7c24a9acb 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -93,10 +93,10 @@ static void sco_sock_timeout(struct work_struct *work)
 
 	BT_DBG("sock %p state %d", sk, sk->sk_state);
 
-	lock_sock(sk);
+	bh_lock_sock(sk);
 	sk->sk_err = ETIMEDOUT;
 	sk->sk_state_change(sk);
-	release_sock(sk);
+	bh_unlock_sock(sk);
 
 	sock_put(sk);
 }
@@ -192,10 +192,10 @@ static void sco_conn_del(struct hci_conn *hcon, int err)
 
 	if (sk) {
 		sock_hold(sk);
-		lock_sock(sk);
+		bh_lock_sock(sk);
 		sco_sock_clear_timer(sk);
 		sco_chan_del(sk, err);
-		release_sock(sk);
+		bh_unlock_sock(sk);
 		sock_put(sk);
 
 		/* Ensure no more work items will run before freeing conn. */
@@ -281,8 +281,7 @@ static int sco_connect(struct hci_dev *hdev, struct sock *sk)
 	return err;
 }
 
-static int sco_send_frame(struct sock *sk, void *buf, int len,
-			  unsigned int msg_flags)
+static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)
 {
 	struct sco_conn *conn = sco_pi(sk)->conn;
 	struct sk_buff *skb;
@@ -294,11 +293,15 @@ static int sco_send_frame(struct sock *sk, void *buf, int len,
 
 	BT_DBG("sk %p len %d", sk, len);
 
-	skb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);
+	skb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		return err;
 
-	memcpy(skb_put(skb, len), buf, len);
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
+		kfree_skb(skb);
+		return -EFAULT;
+	}
+
 	hci_send_sco(conn->hcon, skb);
 
 	return len;
@@ -723,7 +726,6 @@ static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,
 			    size_t len)
 {
 	struct sock *sk = sock->sk;
-	void *buf;
 	int err;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -735,24 +737,14 @@ static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,
 	if (msg->msg_flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
-	buf = kmalloc(len, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (memcpy_from_msg(buf, msg, len)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-
 	lock_sock(sk);
 
 	if (sk->sk_state == BT_CONNECTED)
-		err = sco_send_frame(sk, buf, len, msg->msg_flags);
+		err = sco_send_frame(sk, msg, len);
 	else
 		err = -ENOTCONN;
 
 	release_sock(sk);
-	kfree(buf);
 	return err;
 }
 
@@ -1109,10 +1101,10 @@ static void sco_conn_ready(struct sco_conn *conn)
 
 	if (sk) {
 		sco_sock_clear_timer(sk);
-		lock_sock(sk);
+		bh_lock_sock(sk);
 		sk->sk_state = BT_CONNECTED;
 		sk->sk_state_change(sk);
-		release_sock(sk);
+		bh_unlock_sock(sk);
 	} else {
 		sco_conn_lock(conn);
 
@@ -1127,12 +1119,12 @@ static void sco_conn_ready(struct sco_conn *conn)
 			return;
 		}
 
-		lock_sock(parent);
+		bh_lock_sock(parent);
 
 		sk = sco_sock_alloc(sock_net(parent), NULL,
 				    BTPROTO_SCO, GFP_ATOMIC, 0);
 		if (!sk) {
-			release_sock(parent);
+			bh_unlock_sock(parent);
 			sco_conn_unlock(conn);
 			return;
 		}
@@ -1153,7 +1145,7 @@ static void sco_conn_ready(struct sco_conn *conn)
 		/* Wake up parent */
 		parent->sk_data_ready(parent);
 
-		release_sock(parent);
+		bh_unlock_sock(parent);
 
 		sco_conn_unlock(conn);
 	}
diff --git a/net/rfkill/Kconfig b/net/rfkill/Kconfig
index 83a7af898..33ab1f7a3 100644
--- a/net/rfkill/Kconfig
+++ b/net/rfkill/Kconfig
@@ -32,3 +32,12 @@ config RFKILL_GPIO
 	help
 	  If you say yes here you get support of a generic gpio RFKILL
 	  driver.
+
+config RFKILL_RK
+	tristate "Rockchip RFKILL driver"
+	depends on RFKILL
+	depends on MMC
+	depends on ARCH_ROCKCHIP
+	default y
+	help
+	  Rockchip rfkill driver for rk29/rk3X
diff --git a/net/rfkill/Makefile b/net/rfkill/Makefile
index dc47b6174..beed5b506 100644
--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -7,3 +7,5 @@ rfkill-y			+= core.o
 rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
 obj-$(CONFIG_RFKILL)		+= rfkill.o
 obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
+rfkill-rk-y			+= rfkill-wlan.o rfkill-bt.o
+obj-$(CONFIG_RFKILL_RK)		+= rfkill-rk.o
diff --git a/net/rfkill/rfkill-bt.c b/net/rfkill/rfkill-bt.c
new file mode 100644
index 000000000..f30564677
--- /dev/null
+++ b/net/rfkill/rfkill-bt.c
@@ -0,0 +1,827 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/* Rock-chips rfkill driver for bluetooth
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/rfkill.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/rfkill-bt.h>
+#include <linux/rfkill-wlan.h>
+#include <linux/wakelock.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <linux/suspend.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/fs.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <uapi/linux/rfkill.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#if 0
+#define DBG(x...) pr_info("[BT_RFKILL]: " x)
+#else
+#define DBG(x...)
+#endif
+
+#define LOG(x...) pr_info("[BT_RFKILL]: " x)
+
+#define BT_WAKEUP_TIMEOUT 10000
+#define BT_IRQ_WAKELOCK_TIMEOUT (10 * 1000)
+
+#define BT_BLOCKED true
+#define BT_UNBLOCK false
+#define BT_SLEEP true
+#define BT_WAKEUP false
+
+enum {
+	IOMUX_FNORMAL = 0,
+	IOMUX_FGPIO,
+	IOMUX_FMUX,
+};
+
+struct rfkill_rk_data {
+	struct rfkill_rk_platform_data *pdata;
+	struct platform_device *pdev;
+	struct rfkill *rfkill_dev;
+	struct wake_lock bt_irq_wl;
+	struct delayed_work bt_sleep_delay_work;
+	int irq_req;
+};
+
+static struct rfkill_rk_data *g_rfkill = NULL;
+
+static const char bt_name[] =
+#if defined(CONFIG_BCM4330)
+#if defined(CONFIG_BT_MODULE_NH660)
+	"nh660"
+#else
+	"bcm4330"
+#endif
+#elif defined(CONFIG_RK903)
+#if defined(CONFIG_RKWIFI_26M)
+	"rk903_26M"
+#else
+	"rk903"
+#endif
+#elif defined(CONFIG_BCM4329)
+	"bcm4329"
+#elif defined(CONFIG_MV8787)
+	"mv8787"
+#elif defined(CONFIG_AP6210)
+#if defined(CONFIG_RKWIFI_26M)
+	"ap6210"
+#else
+	"ap6210_24M"
+#endif
+#elif defined(CONFIG_AP6330)
+	"ap6330"
+#elif defined(CONFIG_AP6476)
+	"ap6476"
+#elif defined(CONFIG_AP6493)
+	"ap6493"
+#elif defined(CONFIG_AP6441)
+	"ap6441"
+#elif defined(CONFIG_AP6335)
+	"ap6335"
+#elif defined(CONFIG_GB86302I)
+	"gb86302i"
+#else
+	"bt_default"
+#endif
+	;
+
+static irqreturn_t rfkill_rk_wake_host_irq(int irq, void *dev)
+{
+	struct rfkill_rk_data *rfkill = dev;
+
+	LOG("BT_WAKE_HOST IRQ fired\n");
+
+	DBG("BT IRQ wakeup, request %dms wakelock\n", BT_IRQ_WAKELOCK_TIMEOUT);
+
+	wake_lock_timeout(&rfkill->bt_irq_wl,
+			  msecs_to_jiffies(BT_IRQ_WAKELOCK_TIMEOUT));
+
+	return IRQ_HANDLED;
+}
+
+static int rfkill_rk_setup_gpio(struct platform_device *pdev,
+				struct rfkill_rk_gpio *gpio, const char *prefix,
+				const char *name)
+{
+	if (gpio_is_valid(gpio->io)) {
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
+		ret = devm_gpio_request(&pdev->dev, gpio->io, gpio->name);
+		if (ret) {
+			LOG("Failed to get %s gpio.\n", gpio->name);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int rfkill_rk_setup_wake_irq(struct rfkill_rk_data *rfkill, int flag)
+{
+	int ret = 0;
+	struct rfkill_rk_irq *irq = &rfkill->pdata->wake_host_irq;
+
+	if (!flag) {
+		rfkill->irq_req = 0;
+		ret = rfkill_rk_setup_gpio(rfkill->pdev, &irq->gpio,
+					   rfkill->pdata->name, "wake_host");
+		if (ret)
+			goto fail1;
+	}
+	if (gpio_is_valid(irq->gpio.io)) {
+		if (rfkill->irq_req) {
+			rfkill->irq_req = 0;
+			free_irq(irq->irq, rfkill);
+		}
+		LOG("Request irq for bt wakeup host\n");
+		irq->irq = gpio_to_irq(irq->gpio.io);
+		sprintf(irq->name, "%s_irq", irq->gpio.name);
+		ret = request_irq(irq->irq, rfkill_rk_wake_host_irq,
+				  (irq->gpio.enable == GPIO_ACTIVE_LOW) ?
+					  IRQF_TRIGGER_FALLING :
+					  IRQF_TRIGGER_RISING,
+				  irq->name, rfkill);
+		if (ret)
+			goto fail2;
+		rfkill->irq_req = 1;
+		LOG("** disable irq\n");
+		disable_irq(irq->irq);
+		ret = enable_irq_wake(irq->irq);
+		if (ret)
+			goto fail3;
+	}
+
+	return ret;
+
+fail3:
+	free_irq(irq->irq, rfkill);
+fail2:
+	gpio_free(irq->gpio.io);
+fail1:
+	return ret;
+}
+
+static inline void rfkill_rk_sleep_bt_internal(struct rfkill_rk_data *rfkill,
+					       bool sleep)
+{
+	struct rfkill_rk_gpio *wake = &rfkill->pdata->wake_gpio;
+
+	DBG("*** bt sleep: %d ***\n", sleep);
+#ifndef CONFIG_BK3515A_COMBO
+	gpio_direction_output(wake->io, sleep ? !wake->enable : wake->enable);
+#else
+	if (!sleep) {
+		DBG("HOST_UART0_TX pull down 10us\n");
+		if (rfkill_rk_setup_gpio(rfkill->pdev, wake,
+					 rfkill->pdata->name, "wake") != 0) {
+			return;
+		}
+
+		gpio_direction_output(wake->io, wake->enable);
+		usleep_range(10, 20);
+		gpio_direction_output(wake->io, !wake->enable);
+
+		gpio_free(wake->io);
+	}
+#endif
+}
+
+static void rfkill_rk_delay_sleep_bt(struct work_struct *work)
+{
+	struct rfkill_rk_data *rfkill = NULL;
+
+	DBG("Enter %s\n", __func__);
+
+	rfkill = container_of(work, struct rfkill_rk_data,
+			      bt_sleep_delay_work.work);
+
+	rfkill_rk_sleep_bt_internal(rfkill, BT_SLEEP);
+}
+
+void rfkill_rk_sleep_bt(bool sleep)
+{
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_gpio *wake;
+	bool ret;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!rfkill) {
+		LOG("*** RFKILL is empty???\n");
+		return;
+	}
+
+	wake = &rfkill->pdata->wake_gpio;
+	if (!gpio_is_valid(wake->io)) {
+		DBG("*** Not support bt wakeup and sleep\n");
+		return;
+	}
+
+	ret = cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
+
+	rfkill_rk_sleep_bt_internal(rfkill, sleep);
+
+#ifdef CONFIG_BT_AUTOSLEEP
+	if (sleep == BT_WAKEUP) {
+		schedule_delayed_work(&rfkill->bt_sleep_delay_work,
+				      msecs_to_jiffies(BT_WAKEUP_TIMEOUT));
+	}
+#endif
+}
+EXPORT_SYMBOL(rfkill_rk_sleep_bt);
+
+static int bt_power_state = 0;
+int rfkill_get_bt_power_state(int *power, bool *toggle)
+{
+	struct rfkill_rk_data *mrfkill = g_rfkill;
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-bt driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	*toggle = mrfkill->pdata->power_toggle;
+	*power = bt_power_state;
+
+	return 0;
+}
+
+static int rfkill_rk_set_power(void *data, bool blocked)
+{
+	struct rfkill_rk_data *rfkill = data;
+	struct rfkill_rk_gpio *wake_host = &rfkill->pdata->wake_host_irq.gpio;
+	struct rfkill_rk_gpio *poweron = &rfkill->pdata->poweron_gpio;
+	struct rfkill_rk_gpio *reset = &rfkill->pdata->reset_gpio;
+	struct rfkill_rk_gpio *rts = &rfkill->pdata->rts_gpio;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+	int wifi_power = 0;
+	bool toggle = false;
+
+	DBG("Enter %s\n", __func__);
+
+	DBG("Set blocked:%d\n", blocked);
+
+	toggle = rfkill->pdata->power_toggle;
+
+	if (toggle) {
+		if (rfkill_get_wifi_power_state(&wifi_power)) {
+			LOG("%s: cannot get wifi power state!\n", __func__);
+			return -1;
+		}
+	}
+
+	DBG("%s: toggle = %s\n", __func__, toggle ? "true" : "false");
+
+	if (!blocked) {
+		if (toggle) {
+			rfkill_set_wifi_bt_power(1);
+			msleep(100);
+		}
+
+		rfkill_rk_sleep_bt(BT_WAKEUP); // ensure bt is wakeup
+
+		if (gpio_is_valid(wake_host->io)) {
+			LOG("%s: set bt wake_host high!\n", __func__);
+			gpio_direction_output(wake_host->io, 1);
+			msleep(20);
+		}
+
+		if (gpio_is_valid(poweron->io)) {
+			if (gpio_get_value(poweron->io) == !poweron->enable) {
+				gpio_direction_output(poweron->io,
+						      !poweron->enable);
+				msleep(20);
+				gpio_direction_output(poweron->io,
+						      poweron->enable);
+				msleep(20);
+				if (gpio_is_valid(wake_host->io))
+					gpio_direction_input(wake_host->io);
+			}
+		}
+
+		if (gpio_is_valid(reset->io)) {
+			if (gpio_get_value(reset->io) == !reset->enable) {
+				gpio_direction_output(reset->io,
+						      !reset->enable);
+				msleep(20);
+				gpio_direction_output(reset->io, reset->enable);
+			}
+		}
+
+		if (pinctrl && gpio_is_valid(rts->io)) {
+			pinctrl_select_state(pinctrl, rts->gpio_state);
+			LOG("ENABLE UART_RTS\n");
+			gpio_direction_output(rts->io, rts->enable);
+			msleep(100);
+			LOG("DISABLE UART_RTS\n");
+			gpio_direction_output(rts->io, !rts->enable);
+			pinctrl_select_state(pinctrl, rts->default_state);
+		}
+
+		bt_power_state = 1;
+		LOG("bt turn on power\n");
+		rfkill_rk_setup_wake_irq(rfkill, 1);
+	} else {
+		if (gpio_is_valid(poweron->io)) {
+			if (gpio_get_value(poweron->io) == poweron->enable) {
+				gpio_direction_output(poweron->io,
+						      !poweron->enable);
+				msleep(20);
+			}
+		}
+
+		bt_power_state = 0;
+		LOG("bt shut off power\n");
+		if (gpio_is_valid(reset->io)) {
+			if (gpio_get_value(reset->io) == reset->enable) {
+				gpio_direction_output(reset->io,
+						      !reset->enable);
+				msleep(20);
+			}
+		}
+		if (toggle) {
+			if (!wifi_power) {
+				LOG("%s: bt will set vbat to low\n", __func__);
+				rfkill_set_wifi_bt_power(0);
+			} else {
+				LOG("%s: bt shouldn't control the vbat\n", __func__);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int rfkill_rk_pm_prepare(struct device *dev)
+{
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_gpio *rts;
+	struct rfkill_rk_irq *wake_host_irq;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!rfkill)
+		return 0;
+
+	rts = &rfkill->pdata->rts_gpio;
+	wake_host_irq = &rfkill->pdata->wake_host_irq;
+
+	//To prevent uart to receive bt data when suspended
+	if (pinctrl && gpio_is_valid(rts->io)) {
+		DBG("Disable UART_RTS\n");
+		pinctrl_select_state(pinctrl, rts->gpio_state);
+		gpio_direction_output(rts->io, !rts->enable);
+	}
+
+#ifdef CONFIG_BT_AUTOSLEEP
+	rfkill_rk_sleep_bt(BT_SLEEP);
+#endif
+
+	// enable bt wakeup host
+	if (gpio_is_valid(wake_host_irq->gpio.io) && bt_power_state) {
+		DBG("enable irq for bt wakeup host\n");
+		enable_irq(wake_host_irq->irq);
+	}
+
+#ifdef CONFIG_RFKILL_RESET
+	rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
+	rfkill_rk_set_power(rfkill, BT_BLOCKED);
+#endif
+
+	return 0;
+}
+
+static void rfkill_rk_pm_complete(struct device *dev)
+{
+	struct rfkill_rk_data *rfkill = g_rfkill;
+	struct rfkill_rk_irq *wake_host_irq;
+	struct rfkill_rk_gpio *rts;
+	struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!rfkill)
+		return;
+
+	wake_host_irq = &rfkill->pdata->wake_host_irq;
+	rts = &rfkill->pdata->rts_gpio;
+
+	if (gpio_is_valid(wake_host_irq->gpio.io) && bt_power_state) {
+		LOG("** disable irq\n");
+		disable_irq(wake_host_irq->irq);
+	}
+
+	if (pinctrl && gpio_is_valid(rts->io)) {
+		DBG("Enable UART_RTS\n");
+		gpio_direction_output(rts->io, rts->enable);
+		pinctrl_select_state(pinctrl, rts->default_state);
+	}
+}
+
+static const struct rfkill_ops rfkill_rk_ops = {
+	.set_block = rfkill_rk_set_power,
+};
+
+#define PROC_DIR "bluetooth/sleep"
+
+static struct proc_dir_entry *bluetooth_dir, *sleep_dir;
+
+static ssize_t bluesleep_read_proc_lpm(struct file *file, char __user *buffer,
+				       size_t count, loff_t *data)
+{
+	return sprintf(buffer, "unsupported to read\n");
+}
+
+static ssize_t bluesleep_write_proc_lpm(struct file *file,
+					const char __user *buffer, size_t count,
+					loff_t *data)
+{
+	return count;
+}
+
+static ssize_t bluesleep_read_proc_btwrite(struct file *file,
+					   char __user *buffer, size_t count,
+					   loff_t *data)
+{
+	return sprintf(buffer, "unsupported to read\n");
+}
+
+static ssize_t bluesleep_write_proc_btwrite(struct file *file,
+					    const char __user *buffer,
+					    size_t count, loff_t *data)
+{
+	char b;
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (copy_from_user(&b, buffer, 1))
+		return -EFAULT;
+
+	DBG("btwrite %c\n", b);
+	/* HCI_DEV_WRITE */
+	if (b != '0')
+		rfkill_rk_sleep_bt(BT_WAKEUP);
+	else
+		rfkill_rk_sleep_bt(BT_SLEEP);
+
+	return count;
+}
+
+#ifdef CONFIG_OF
+static int bluetooth_platdata_parse_dt(struct device *dev,
+				       struct rfkill_rk_platform_data *data)
+{
+	struct device_node *node = dev->of_node;
+	int gpio;
+	enum of_gpio_flags flags;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+	if (of_find_property(node, "wifi-bt-power-toggle", NULL)) {
+		data->power_toggle = true;
+		LOG("%s: get property wifi-bt-power-toggle.\n", __func__);
+	} else {
+		data->power_toggle = false;
+	}
+
+	gpio = of_get_named_gpio_flags(node, "uart_rts_gpios", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->rts_gpio.io = gpio;
+		data->rts_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: uart_rts_gpios = %d.\n", __func__, gpio);
+		data->pinctrl = devm_pinctrl_get(dev);
+		if (!IS_ERR(data->pinctrl)) {
+			data->rts_gpio.default_state =
+				pinctrl_lookup_state(data->pinctrl, "default");
+			data->rts_gpio.gpio_state =
+				pinctrl_lookup_state(data->pinctrl, "rts_gpio");
+		} else {
+			data->pinctrl = NULL;
+			LOG("%s: dts does't define the uart rts iomux.\n",
+			    __func__);
+			return -EINVAL;
+		}
+	} else {
+		data->pinctrl = NULL;
+		data->rts_gpio.io = -EINVAL;
+		LOG("%s: uart_rts_gpios is no-in-use.\n", __func__);
+	}
+
+	gpio = of_get_named_gpio_flags(node, "BT,power_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->poweron_gpio.io = gpio;
+		data->poweron_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,power_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->poweron_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,reset_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->reset_gpio.io = gpio;
+		data->reset_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,reset_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->reset_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,wake_gpio", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->wake_gpio.io = gpio;
+		data->wake_gpio.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,wake_gpio = %d.\n", __func__, gpio);
+	} else {
+		data->wake_gpio.io = -1;
+	}
+	gpio = of_get_named_gpio_flags(node, "BT,wake_host_irq", 0, &flags);
+	if (gpio_is_valid(gpio)) {
+		data->wake_host_irq.gpio.io = gpio;
+		data->wake_host_irq.gpio.enable = flags;
+		LOG("%s: get property: BT,wake_host_irq = %d.\n", __func__,
+		    gpio);
+	} else {
+		data->wake_host_irq.gpio.io = -1;
+	}
+
+	data->ext_clk = devm_clk_get(dev, "ext_clock");
+	if (IS_ERR(data->ext_clk)) {
+		LOG("%s: clk_get failed!!!.\n", __func__);
+	} else {
+		clk_prepare_enable(data->ext_clk);
+	}
+	return 0;
+}
+#endif //CONFIG_OF
+
+static const struct file_operations bluesleep_lpm = {
+	.owner = THIS_MODULE,
+	.read = bluesleep_read_proc_lpm,
+	.write = bluesleep_write_proc_lpm,
+};
+
+static const struct file_operations bluesleep_btwrite = {
+	.owner = THIS_MODULE,
+	.read = bluesleep_read_proc_btwrite,
+	.write = bluesleep_write_proc_btwrite,
+};
+
+static int rfkill_rk_probe(struct platform_device *pdev)
+{
+	struct rfkill_rk_data *rfkill;
+	struct rfkill_rk_platform_data *pdata = pdev->dev.platform_data;
+	int ret = 0;
+	struct proc_dir_entry *ent;
+
+	DBG("Enter %s\n", __func__);
+
+	if (!pdata) {
+#ifdef CONFIG_OF
+		pdata = devm_kzalloc(&pdev->dev,
+				     sizeof(struct rfkill_rk_platform_data),
+				     GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		ret = bluetooth_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
+#endif
+			LOG("%s: No platform data specified\n", __func__);
+			return ret;
+#ifdef CONFIG_OF
+		}
+#endif
+	}
+
+	pdata->name = (char *)bt_name;
+	pdata->type = RFKILL_TYPE_BLUETOOTH;
+
+	rfkill = devm_kzalloc(&pdev->dev, sizeof(*rfkill), GFP_KERNEL);
+	if (!rfkill)
+		return -ENOMEM;
+
+	rfkill->pdata = pdata;
+	rfkill->pdev = pdev;
+	g_rfkill = rfkill;
+
+	bluetooth_dir = proc_mkdir("bluetooth", NULL);
+	if (!bluetooth_dir) {
+		LOG("Unable to create /proc/bluetooth directory");
+		return -ENOMEM;
+	}
+
+	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
+	if (!sleep_dir) {
+		LOG("Unable to create /proc/%s directory", PROC_DIR);
+		return -ENOMEM;
+	}
+
+	/* read/write proc entries */
+	ent = proc_create("lpm", 0, sleep_dir, (struct proc_ops*)&bluesleep_lpm);
+	if (!ent) {
+		LOG("Unable to create /proc/%s/lpm entry", PROC_DIR);
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
+
+	/* read/write proc entries */
+	ent = proc_create("btwrite", 0, sleep_dir, (struct proc_ops*)&bluesleep_btwrite);
+	if (!ent) {
+		LOG("Unable to create /proc/%s/btwrite entry", PROC_DIR);
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
+
+	DBG("init gpio\n");
+
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->poweron_gpio, pdata->name,
+				   "poweron");
+	if (ret)
+		goto fail_gpio;
+
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->reset_gpio, pdata->name,
+				   "reset");
+	if (ret)
+		goto fail_gpio;
+
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->wake_gpio, pdata->name,
+				   "wake");
+	if (ret)
+		goto fail_gpio;
+
+	ret = rfkill_rk_setup_gpio(pdev, &pdata->rts_gpio, rfkill->pdata->name,
+				   "rts");
+	if (ret)
+		goto fail_gpio;
+
+	wake_lock_init(&rfkill->bt_irq_wl, WAKE_LOCK_SUSPEND,
+		       "rfkill_rk_irq_wl");
+
+	ret = rfkill_rk_setup_wake_irq(rfkill, 0);
+	if (ret)
+		goto fail_setup_wake_irq;
+
+	DBG("setup rfkill\n");
+	rfkill->rfkill_dev = rfkill_alloc(pdata->name, &pdev->dev, pdata->type,
+					  &rfkill_rk_ops, rfkill);
+	if (!rfkill->rfkill_dev)
+		goto fail_alloc;
+
+	rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
+	ret = rfkill_register(rfkill->rfkill_dev);
+	if (ret < 0)
+		goto fail_rfkill;
+
+	INIT_DELAYED_WORK(&rfkill->bt_sleep_delay_work,
+			  rfkill_rk_delay_sleep_bt);
+
+	//rfkill_rk_set_power(rfkill, BT_BLOCKED);
+	// bt turn off power
+	if (gpio_is_valid(pdata->poweron_gpio.io)) {
+		gpio_direction_output(pdata->poweron_gpio.io,
+				      !pdata->poweron_gpio.enable);
+	}
+	if (gpio_is_valid(pdata->reset_gpio.io)) {
+		gpio_direction_output(pdata->reset_gpio.io,
+				      !pdata->reset_gpio.enable);
+	}
+
+	platform_set_drvdata(pdev, rfkill);
+
+	LOG("%s device registered.\n", pdata->name);
+
+	return 0;
+
+fail_rfkill:
+	rfkill_destroy(rfkill->rfkill_dev);
+fail_alloc:
+
+	remove_proc_entry("btwrite", sleep_dir);
+	remove_proc_entry("lpm", sleep_dir);
+fail_setup_wake_irq:
+	wake_lock_destroy(&rfkill->bt_irq_wl);
+fail_gpio:
+
+	g_rfkill = NULL;
+	return ret;
+}
+
+static int rfkill_rk_remove(struct platform_device *pdev)
+{
+	struct rfkill_rk_data *rfkill = platform_get_drvdata(pdev);
+
+	LOG("Enter %s\n", __func__);
+
+	rfkill_unregister(rfkill->rfkill_dev);
+	rfkill_destroy(rfkill->rfkill_dev);
+
+	cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
+
+	// free gpio
+	if (gpio_is_valid(rfkill->pdata->rts_gpio.io))
+		gpio_free(rfkill->pdata->rts_gpio.io);
+
+	if (gpio_is_valid(rfkill->pdata->wake_host_irq.gpio.io)) {
+		free_irq(rfkill->pdata->wake_host_irq.irq, rfkill);
+#ifndef CONFIG_BK3515A_COMBO
+		gpio_free(rfkill->pdata->wake_host_irq.gpio.io);
+#endif
+	}
+
+#ifndef CONFIG_BK3515A_COMBO
+	if (gpio_is_valid(rfkill->pdata->wake_gpio.io))
+		gpio_free(rfkill->pdata->wake_gpio.io);
+#endif
+
+	if (gpio_is_valid(rfkill->pdata->reset_gpio.io))
+		gpio_free(rfkill->pdata->reset_gpio.io);
+
+	if (gpio_is_valid(rfkill->pdata->poweron_gpio.io))
+		gpio_free(rfkill->pdata->poweron_gpio.io);
+	clk_disable_unprepare(rfkill->pdata->ext_clk);
+	wake_lock_destroy(&rfkill->bt_irq_wl);
+	g_rfkill = NULL;
+
+	return 0;
+}
+
+static const struct dev_pm_ops rfkill_rk_pm_ops = {
+	.prepare = rfkill_rk_pm_prepare,
+	.complete = rfkill_rk_pm_complete,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id bt_platdata_of_match[] = {
+	{ .compatible = "bluetooth-platdata" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, bt_platdata_of_match);
+#endif //CONFIG_OF
+
+static struct platform_driver rfkill_rk_driver = {
+	.probe = rfkill_rk_probe,
+	.remove = rfkill_rk_remove,
+	.driver = {
+		.name = "rfkill_bt",
+		.owner = THIS_MODULE,
+		.pm = &rfkill_rk_pm_ops,
+        .of_match_table = of_match_ptr(bt_platdata_of_match),
+	},
+};
+
+static int __init rfkill_rk_init(void)
+{
+	int err;
+
+	LOG("Enter %s\n", __func__);
+	err = rfkill_wlan_init();
+	if (err)
+		return err;
+	return platform_driver_register(&rfkill_rk_driver);
+}
+
+static void __exit rfkill_rk_exit(void)
+{
+	LOG("Enter %s\n", __func__);
+	platform_driver_unregister(&rfkill_rk_driver);
+	rfkill_wlan_exit();
+}
+
+module_init(rfkill_rk_init);
+module_exit(rfkill_rk_exit);
+
+MODULE_DESCRIPTION("rock-chips rfkill for Bluetooth v0.3");
+MODULE_AUTHOR("cmy@rock-chips.com, gwl@rock-chips.com");
+MODULE_LICENSE("GPL");
diff --git a/net/rfkill/rfkill-wlan.c b/net/rfkill/rfkill-wlan.c
new file mode 100644
index 000000000..ebed232f9
--- /dev/null
+++ b/net/rfkill/rfkill-wlan.c
@@ -0,0 +1,978 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/* Rock-chips rfkill driver for wifi
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/rfkill.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/rfkill-wlan.h>
+#include <linux/rfkill-bt.h>
+#include <linux/wakelock.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <linux/suspend.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <linux/skbuff.h>
+#include <linux/fb.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mmc/host.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+#include <linux/soc/rockchip/rk_vendor_storage.h>
+#include <linux/device.h>
+
+#include "../../drivers/mmc/core/pwrseq.h"
+
+#if 0
+#define DBG(x...) pr_info("[WLAN_RFKILL]: " x)
+#else
+#define DBG(x...)
+#endif
+
+#define LOG(x...) pr_info("[WLAN_RFKILL]: " x)
+
+struct rfkill_wlan_data {
+	struct rksdmmc_gpio_wifi_moudle *pdata;
+	struct wake_lock wlan_irq_wl;
+};
+
+static struct rfkill_wlan_data *g_rfkill = NULL;
+static int power_set_time = 0;
+static int wifi_bt_vbat_state;
+static int wifi_power_state;
+
+static const char wlan_name[] = "rkwifi";
+
+static char wifi_chip_type_string[64];
+/***********************************************************
+ *
+ * Broadcom Wifi Static Memory
+ *
+ **********************************************************/
+#ifdef CONFIG_RKWIFI
+#define BCM_STATIC_MEMORY_SUPPORT 0
+#else
+#define BCM_STATIC_MEMORY_SUPPORT 0
+#endif
+//===========================
+#if BCM_STATIC_MEMORY_SUPPORT
+#define PREALLOC_WLAN_SEC_NUM 4
+#define PREALLOC_WLAN_BUF_NUM 160
+#define PREALLOC_WLAN_SECTION_HEADER 0
+#define WLAN_SKB_BUF_NUM 16
+
+#define WLAN_SECTION_SIZE_0 (12 * 1024)
+#define WLAN_SECTION_SIZE_1 (12 * 1024)
+#define WLAN_SECTION_SIZE_2 (32 * 1024)
+#define WLAN_SECTION_SIZE_3 (136 * 1024)
+#define WLAN_SECTION_SIZE_4 (4 * 1024)
+#define WLAN_SECTION_SIZE_5 (64 * 1024)
+#define WLAN_SECTION_SIZE_6 (4 * 1024)
+#define WLAN_SECTION_SIZE_7 (4 * 1024)
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM + 1];
+
+struct wifi_mem_prealloc {
+	void *mem_ptr;
+	unsigned long size;
+};
+
+static struct wifi_mem_prealloc wifi_mem_array[8] = {
+	{ NULL, (WLAN_SECTION_SIZE_0) }, { NULL, (WLAN_SECTION_SIZE_1) },
+	{ NULL, (WLAN_SECTION_SIZE_2) }, { NULL, (WLAN_SECTION_SIZE_3) },
+	{ NULL, (WLAN_SECTION_SIZE_4) }, { NULL, (WLAN_SECTION_SIZE_5) },
+	{ NULL, (WLAN_SECTION_SIZE_6) }, { NULL, (WLAN_SECTION_SIZE_7) }
+};
+
+static int rockchip_init_wifi_mem(void)
+{
+	int i;
+	int j;
+
+	for (i = 0; i < WLAN_SKB_BUF_NUM; i++) {
+		wlan_static_skb[i] =
+			dev_alloc_skb(((i < (WLAN_SKB_BUF_NUM / 2)) ?
+				(PAGE_SIZE * 1) :
+				(PAGE_SIZE * 2)));
+
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
+
+	wlan_static_skb[i] = dev_alloc_skb((PAGE_SIZE * 4));
+	if (!wlan_static_skb[i])
+		goto err_skb_alloc;
+
+	for (i = 0; i <= 7; i++) {
+		wifi_mem_array[i].mem_ptr =
+			kmalloc(wifi_mem_array[i].size, GFP_KERNEL);
+
+		if (!wifi_mem_array[i].mem_ptr)
+			goto err_mem_alloc;
+	}
+	return 0;
+
+err_mem_alloc:
+	pr_err("Failed to mem_alloc for WLAN\n");
+	for (j = 0; j < i; j++)
+		kfree(wifi_mem_array[j].mem_ptr);
+	i = WLAN_SKB_BUF_NUM;
+err_skb_alloc:
+	pr_err("Failed to skb_alloc for WLAN\n");
+	for (j = 0; j < i; j++)
+		dev_kfree_skb(wlan_static_skb[j]);
+	dev_kfree_skb(wlan_static_skb[j]);
+
+	return -ENOMEM;
+}
+
+void *rockchip_mem_prealloc(int section, unsigned long size)
+{
+	if (section == PREALLOC_WLAN_SEC_NUM)
+		return wlan_static_skb;
+
+	if (section < 0 || section > 7)
+		return NULL;
+
+	if (wifi_mem_array[section].size < size)
+		return NULL;
+
+	return wifi_mem_array[section].mem_ptr;
+}
+#else
+void *rockchip_mem_prealloc(int section, unsigned long size)
+{
+	return NULL;
+}
+#endif
+EXPORT_SYMBOL(rockchip_mem_prealloc);
+
+int rfkill_set_wifi_bt_power(int on)
+{
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rksdmmc_gpio *vbat;
+
+	LOG("%s: %d\n", __func__, on);
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	vbat = &mrfkill->pdata->vbat_n;
+	if (on) {
+		if (gpio_is_valid(vbat->io))
+			gpio_direction_output(vbat->io, vbat->enable);
+	} else {
+		if (gpio_is_valid(vbat->io))
+			gpio_direction_output(vbat->io, !(vbat->enable));
+	}
+	wifi_bt_vbat_state = on;
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * get wifi power state Func
+ *
+ *************************************************************************/
+int rfkill_get_wifi_power_state(int *power)
+{
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	*power = wifi_power_state;
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Wifi Power Control Func
+ * 0 -> power off
+ * 1 -> power on
+ *
+ *************************************************************************/
+int rockchip_wifi_power(int on)
+{
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rksdmmc_gpio *poweron, *reset;
+	struct regulator *ldo = NULL;
+	int bt_power = 0;
+	bool toggle = false;
+
+	LOG("%s: %d\n", __func__, on);
+
+	if (!on && primary_sdio_host)
+		mmc_pwrseq_power_off(primary_sdio_host);
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	if (mrfkill->pdata->wifi_power_remain && power_set_time) {
+		LOG("%s: wifi power is setted to be remain on.", __func__);
+		return 0;
+	}
+	power_set_time++;
+
+	if (!rfkill_get_bt_power_state(&bt_power, &toggle)) {
+		LOG("%s: toggle = %s\n", __func__, toggle ? "true" : "false");
+	}
+
+	if (mrfkill->pdata->mregulator.power_ctrl_by_pmu) {
+		int ret = -1;
+		char *ldostr;
+		int level = mrfkill->pdata->mregulator.enable;
+
+		ldostr = mrfkill->pdata->mregulator.pmu_regulator;
+		if (!ldostr)
+			return -1;
+		ldo = regulator_get(NULL, ldostr);
+		if (!ldo || IS_ERR(ldo)) {
+			LOG("\n\n\n%s get ldo error,please mod this\n\n\n",
+			    __func__);
+			return -1;
+		}
+		if (on == level) {
+			regulator_set_voltage(ldo, 3000000, 3000000);
+			LOG("%s: %s enabled\n", __func__, ldostr);
+			ret = regulator_enable(ldo);
+			wifi_power_state = 1;
+			LOG("wifi turn on power.\n");
+		} else {
+			LOG("%s: %s disabled\n", __func__, ldostr);
+			while (regulator_is_enabled(ldo) > 0)
+				ret = regulator_disable(ldo);
+			wifi_power_state = 0;
+			LOG("wifi shut off power.\n");
+		}
+		regulator_put(ldo);
+		msleep(100);
+	} else {
+		poweron = &mrfkill->pdata->power_n;
+		reset = &mrfkill->pdata->reset_n;
+
+		if (on) {
+			if (toggle) {
+				rfkill_set_wifi_bt_power(1);
+				msleep(100);
+			}
+
+			if (gpio_is_valid(poweron->io)) {
+				gpio_direction_output(poweron->io, poweron->enable);
+				msleep(100);
+			}
+
+			if (gpio_is_valid(reset->io)) {
+				gpio_direction_output(reset->io, reset->enable);
+				msleep(100);
+			}
+
+			wifi_power_state = 1;
+			LOG("wifi turn on power [GPIO%d-%d]\n", poweron->io, poweron->enable);
+		} else {
+			if (gpio_is_valid(poweron->io)) {
+				printk("wifi power off\n");
+				gpio_direction_output(poweron->io, !(poweron->enable));
+				msleep(100);
+			}
+
+			if (gpio_is_valid(reset->io)) {
+				gpio_direction_output(reset->io, !(reset->enable));
+			}
+
+			wifi_power_state = 0;
+			if (toggle) {
+				if (!bt_power) {
+					LOG("%s: wifi will set vbat to low\n", __func__);
+					rfkill_set_wifi_bt_power(0);
+				} else {
+					LOG("%s: wifi shouldn't control the vbat\n", __func__);
+				}
+			}
+			LOG("wifi shut off power [GPIO%d-%d]\n", poweron->io, !poweron->enable);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_wifi_power);
+
+/**************************************************************************
+ *
+ * Wifi Sdio Detect Func
+ *
+ *************************************************************************/
+extern int mmc_host_rescan(struct mmc_host *host, int val, int irq_type);
+int rockchip_wifi_set_carddetect(int val)
+{
+	return mmc_host_rescan(NULL, val, 1);
+}
+EXPORT_SYMBOL(rockchip_wifi_set_carddetect);
+
+/**************************************************************************
+ *
+ * Wifi Get Interrupt irq Func
+ *
+ *************************************************************************/
+int rockchip_wifi_get_oob_irq(void)
+{
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rksdmmc_gpio *wifi_int_irq;
+
+	LOG("%s: Enter\n", __func__);
+
+	if (!mrfkill) {
+		LOG("%s: rfkill-wlan driver has not Successful initialized\n",
+		    __func__);
+		return -1;
+	}
+
+	wifi_int_irq = &mrfkill->pdata->wifi_int_b;
+	if (gpio_is_valid(wifi_int_irq->io)) {
+		return gpio_to_irq(wifi_int_irq->io);
+		//return wifi_int_irq->io;
+	} else {
+		LOG("%s: wifi OOB pin isn't defined.\n", __func__);
+	}
+
+	return -1;
+}
+EXPORT_SYMBOL(rockchip_wifi_get_oob_irq);
+
+int rockchip_wifi_get_oob_irq_flag(void)
+{
+	struct rfkill_wlan_data *mrfkill = g_rfkill;
+	struct rksdmmc_gpio *wifi_int_irq;
+	int gpio_flags = -1;
+
+	if (mrfkill) {
+		wifi_int_irq = &mrfkill->pdata->wifi_int_b;
+		if (gpio_is_valid(wifi_int_irq->io))
+			gpio_flags = wifi_int_irq->enable;
+	}
+
+	return gpio_flags;
+}
+EXPORT_SYMBOL(rockchip_wifi_get_oob_irq_flag);
+
+/**************************************************************************
+ *
+ * Wifi Reset Func
+ *
+ *************************************************************************/
+int rockchip_wifi_reset(int on)
+{
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_wifi_reset);
+
+/**************************************************************************
+ *
+ * Wifi MAC custom Func
+ *
+ *************************************************************************/
+#include <linux/etherdevice.h>
+#include <linux/errno.h>
+u8 wifi_custom_mac_addr[6] = { 0, 0, 0, 0, 0, 0 };
+
+//#define RANDOM_ADDRESS_SAVE
+static int get_wifi_addr_vendor(unsigned char *addr)
+{
+	int ret;
+	int count = 5;
+
+	while (count-- > 0) {
+		if (is_rk_vendor_ready())
+			break;
+		/* sleep 500ms wait rk vendor driver ready */
+		msleep(500);
+	}
+	ret = rk_vendor_read(WIFI_MAC_ID, addr, 6);
+	if (ret != 6 || is_zero_ether_addr(addr)) {
+		LOG("%s: rk_vendor_read wifi mac address failed (%d)\n",
+		    __func__, ret);
+#ifdef CONFIG_WIFI_GENERATE_RANDOM_MAC_ADDR
+		random_ether_addr(addr);
+		LOG("%s: generate random wifi mac address: "
+		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    __func__, addr[0], addr[1], addr[2], addr[3], addr[4],
+		    addr[5]);
+		ret = rk_vendor_write(WIFI_MAC_ID, addr, 6);
+		if (ret != 0) {
+			LOG("%s: rk_vendor_write failed %d\n"
+			    __func__, ret);
+			memset(addr, 0, 6);
+			return -1;
+		}
+#else
+		return -1;
+#endif
+	} else {
+		LOG("%s: rk_vendor_read wifi mac address: "
+		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    __func__, addr[0], addr[1], addr[2], addr[3], addr[4],
+		    addr[5]);
+	}
+	return 0;
+}
+
+int rockchip_wifi_mac_addr(unsigned char *buf)
+{
+	char mac_buf[20] = { 0 };
+
+	LOG("%s: enter.\n", __func__);
+
+	// from vendor storage
+	if (is_zero_ether_addr(wifi_custom_mac_addr)) {
+		if (get_wifi_addr_vendor(wifi_custom_mac_addr) != 0)
+			return -1;
+	}
+
+	sprintf(mac_buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+		wifi_custom_mac_addr[0], wifi_custom_mac_addr[1],
+		wifi_custom_mac_addr[2], wifi_custom_mac_addr[3],
+		wifi_custom_mac_addr[4], wifi_custom_mac_addr[5]);
+	LOG("falsh wifi_custom_mac_addr=[%s]\n", mac_buf);
+
+	if (is_valid_ether_addr(wifi_custom_mac_addr)) {
+		if (!strncmp(wifi_chip_type_string, "rtl", 3))
+			wifi_custom_mac_addr[0] &= ~0x2; // for p2p
+	} else {
+		LOG("This mac address is not valid, ignored...\n");
+		return -1;
+	}
+
+	memcpy(buf, wifi_custom_mac_addr, 6);
+
+	return 0;
+}
+EXPORT_SYMBOL(rockchip_wifi_mac_addr);
+
+/**************************************************************************
+ *
+ * wifi get country code func
+ *
+ *************************************************************************/
+struct cntry_locales_custom {
+	char iso_abbrev[4]; /* ISO 3166-1 country abbreviation */
+	char custom_locale[4]; /* Custom firmware locale */
+	int custom_locale_rev; /* Custom local revisin default -1 */
+};
+
+static struct cntry_locales_custom country_cloc;
+
+void *rockchip_wifi_country_code(char *ccode)
+{
+	struct cntry_locales_custom *mcloc;
+
+	LOG("%s: set country code [%s]\n", __func__, ccode);
+	mcloc = &country_cloc;
+	memcpy(mcloc->custom_locale, ccode, 4);
+	mcloc->custom_locale_rev = 0;
+
+	return mcloc;
+}
+EXPORT_SYMBOL(rockchip_wifi_country_code);
+/**************************************************************************/
+
+static int rfkill_rk_setup_gpio(struct rksdmmc_gpio *gpio, const char *prefix,
+				const char *name)
+{
+	if (gpio_is_valid(gpio->io)) {
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
+		ret = gpio_request(gpio->io, gpio->name);
+		if (ret) {
+			LOG("Failed to get %s gpio.\n", gpio->name);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int wlan_platdata_parse_dt(struct device *dev,
+				  struct rksdmmc_gpio_wifi_moudle *data)
+{
+	struct device_node *node = dev->of_node;
+	const char *strings;
+	u32 value;
+	int gpio, ret;
+	enum of_gpio_flags flags;
+	u32 ext_clk_value = 0;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+#ifdef CONFIG_MFD_SYSCON
+	data->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+	if (IS_ERR(data->grf)) {
+		LOG("can't find rockchip,grf property\n");
+		//return -1;
+	}
+#endif
+
+	ret = of_property_read_string(node, "wifi_chip_type", &strings);
+	if (ret) {
+		LOG("%s: Can not read wifi_chip_type, set default to rkwifi.\n",
+		    __func__);
+		strcpy(wifi_chip_type_string, "rkwifi");
+	} else {
+		strcpy(wifi_chip_type_string, strings);
+	}
+	LOG("%s: wifi_chip_type = %s\n", __func__, wifi_chip_type_string);
+
+	if (of_find_property(node, "keep_wifi_power_on", NULL)) {
+		data->wifi_power_remain = true;
+		LOG("%s: wifi power remain\n", __func__);
+	} else {
+		data->wifi_power_remain = false;
+		LOG("%s: enable wifi power control.\n", __func__);
+	}
+
+	if (of_find_property(node, "power_ctrl_by_pmu", NULL)) {
+		data->mregulator.power_ctrl_by_pmu = true;
+		ret = of_property_read_string(node, "power_pmu_regulator",
+					      &strings);
+		if (ret) {
+			LOG("%s: Can not read property: power_pmu_regulator.\n",
+			    __func__);
+			data->mregulator.power_ctrl_by_pmu = false;
+		} else {
+			LOG("%s: wifi power controlled by pmu(%s).\n", __func__,
+			    strings);
+			sprintf(data->mregulator.pmu_regulator, "%s", strings);
+		}
+		ret = of_property_read_u32(node, "power_pmu_enable_level",
+					   &value);
+		if (ret) {
+			LOG("%s: Can not read: power_pmu_enable_level.\n",
+			    __func__);
+			data->mregulator.power_ctrl_by_pmu = false;
+		} else {
+			LOG("%s: wifi power controlled by pmu(level = %s).\n",
+			    __func__, (value == 1) ? "HIGH" : "LOW");
+			data->mregulator.enable = value;
+		}
+	} else {
+		data->mregulator.power_ctrl_by_pmu = false;
+		LOG("%s: wifi power controled by gpio.\n", __func__);
+		gpio = of_get_named_gpio_flags(node, "WIFI,poweren_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
+			data->power_n.io = gpio;
+			data->power_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,poweren_gpio = %d flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->power_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,vbat_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
+			data->vbat_n.io = gpio;
+			data->vbat_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,vbat_gpio = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->vbat_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,reset_gpio", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
+			data->reset_n.io = gpio;
+			data->reset_n.enable =
+				(flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+			LOG("%s: WIFI,reset_gpio = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->reset_n.io = -1;
+		}
+		gpio = of_get_named_gpio_flags(node, "WIFI,host_wake_irq", 0,
+					       &flags);
+		if (gpio_is_valid(gpio)) {
+			data->wifi_int_b.io = gpio;
+			data->wifi_int_b.enable = !flags;
+			LOG("%s: WIFI,host_wake_irq = %d, flags = %d.\n",
+			    __func__, gpio, flags);
+		} else {
+			data->wifi_int_b.io = -1;
+		}
+	}
+
+	data->ext_clk = devm_clk_get(dev, "clk_wifi");
+	if (IS_ERR(data->ext_clk)) {
+		LOG("%s: The ref_wifi_clk not found !\n", __func__);
+	} else {
+		of_property_read_u32(node, "ref-clock-frequency",
+				     &ext_clk_value);
+		if (ext_clk_value > 0) {
+			ret = clk_set_rate(data->ext_clk, ext_clk_value);
+			if (ret)
+				LOG("%s: set ref clk error!\n", __func__);
+		}
+
+		ret = clk_prepare_enable(data->ext_clk);
+		if (ret)
+			LOG("%s: enable ref clk error!\n", __func__);
+
+		/* WIFI clock (REF_CLKOUT) output enable.
+		 * 1'b0: drive disable
+		 * 1'b1: output enable
+		 */
+		if (of_machine_is_compatible("rockchip,rk3308"))
+			regmap_write(data->grf, 0x0314, 0x00020002);
+	}
+
+	return 0;
+}
+#endif //CONFIG_OF
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+
+static void wlan_early_suspend(struct early_suspend *h)
+{
+	LOG("%s :enter\n", __func__);
+
+	return;
+}
+
+static void wlan_late_resume(struct early_suspend *h)
+{
+	LOG("%s :enter\n", __func__);
+
+	return;
+}
+
+struct early_suspend wlan_early_suspend {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+	.suspend = wlan_early_suspend;
+	.resume = wlan_late_resume;
+}
+#endif
+
+static void
+rfkill_wlan_early_suspend(void)
+{
+	//LOG("%s :enter\n", __func__);
+
+	return;
+}
+
+static void rfkill_wlan_later_resume(void)
+{
+	//LOG("%s :enter\n", __func__);
+
+	return;
+}
+
+static int rfkill_wlan_fb_event_notify(struct notifier_block *self,
+				       unsigned long action, void *data)
+{
+	struct fb_event *event = data;
+	int blank_mode = *((int *)event->data);
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rfkill_wlan_later_resume();
+		break;
+	case FB_BLANK_NORMAL:
+		rfkill_wlan_early_suspend();
+		break;
+	default:
+		rfkill_wlan_early_suspend();
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block rfkill_wlan_fb_notifier = {
+	.notifier_call = rfkill_wlan_fb_event_notify,
+};
+
+static ssize_t wifi_power_show(struct class *cls, struct class_attribute *attr, char *_buf)
+{
+	return sprintf(_buf, "%d\n", wifi_power_state);
+}
+
+static ssize_t wifi_power_store(struct class *cls, struct class_attribute *attr, const char *_buf, size_t _count)
+{
+	long poweren = 0;
+
+	if (kstrtol(_buf, 10, &poweren) < 0)
+		return -EINVAL;
+
+	LOG("%s: poweren = %ld\n", __func__, poweren);
+
+	if (poweren > 0)
+		rockchip_wifi_power(1);
+	else
+		rockchip_wifi_power(0);
+
+	return _count;
+}
+
+static CLASS_ATTR_RW(wifi_power);
+
+static ssize_t wifi_bt_vbat_show(struct class *cls, struct class_attribute *attr, char *_buf)
+{
+	return sprintf(_buf, "%d\n", wifi_bt_vbat_state);
+}
+
+static ssize_t wifi_bt_vbat_store(struct class *cls, struct class_attribute *attr, const char *_buf, size_t _count)
+{
+	long vbat = 0;
+
+	if (kstrtol(_buf, 10, &vbat) < 0)
+		return -EINVAL;
+
+	LOG("%s: vbat = %ld\n", __func__, vbat);
+
+	if (vbat > 0)
+		rfkill_set_wifi_bt_power(1);
+	else
+		rfkill_set_wifi_bt_power(0);
+
+	return _count;
+}
+
+static CLASS_ATTR_RW(wifi_bt_vbat);
+
+static ssize_t wifi_set_carddetect_store(struct class *cls, struct class_attribute *attr, const char *_buf, size_t _count)
+{
+	long val = 0;
+
+	if (kstrtol(_buf, 10, &val) < 0)
+		return -EINVAL;
+
+	LOG("%s: val = %ld\n", __func__, val);
+
+	if (val > 0)
+		rockchip_wifi_set_carddetect(1);
+	else
+		rockchip_wifi_set_carddetect(0);
+
+	return _count;
+}
+
+static CLASS_ATTR_WO(wifi_set_carddetect);
+
+static struct attribute *rkwifi_power_attrs[] = {
+	&class_attr_wifi_power.attr,
+	&class_attr_wifi_bt_vbat.attr,
+	&class_attr_wifi_set_carddetect.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(rkwifi_power);
+
+/** Device model classes */
+static struct class rkwifi_power = {
+	.name        = "rkwifi",
+	.class_groups = rkwifi_power_groups,
+};
+
+static int rfkill_wlan_probe(struct platform_device *pdev)
+{
+	struct rfkill_wlan_data *rfkill;
+	struct rksdmmc_gpio_wifi_moudle *pdata = pdev->dev.platform_data;
+	int ret = -1;
+
+	LOG("Enter %s\n", __func__);
+
+	class_register(&rkwifi_power);
+
+	if (!pdata) {
+#ifdef CONFIG_OF
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		ret = wlan_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
+#endif
+			LOG("%s: No platform data specified\n", __func__);
+			return ret;
+#ifdef CONFIG_OF
+		}
+#endif
+	}
+
+	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);
+	if (!rfkill)
+		goto rfkill_alloc_fail;
+
+	rfkill->pdata = pdata;
+	g_rfkill = rfkill;
+
+	LOG("%s: init gpio\n", __func__);
+
+	if (!pdata->mregulator.power_ctrl_by_pmu) {
+		ret = rfkill_rk_setup_gpio(&pdata->vbat_n, wlan_name,
+					   "wlan_vbat");
+		if (ret)
+			goto fail_alloc;
+
+		ret = rfkill_rk_setup_gpio(&pdata->power_n, wlan_name,
+					   "wlan_poweren");
+		if (ret)
+			goto fail_alloc;
+
+		ret = rfkill_rk_setup_gpio(&pdata->reset_n, wlan_name,
+					   "wlan_reset");
+		if (ret)
+			goto fail_alloc;
+	}
+
+	wake_lock_init(&rfkill->wlan_irq_wl, WAKE_LOCK_SUSPEND,
+		       "rfkill_wlan_wake");
+
+	rfkill_set_wifi_bt_power(1);
+
+#ifdef CONFIG_SDIO_KEEPALIVE
+	if (gpio_is_valid(pdata->power_n.io) &&
+	    primary_sdio_host && primary_sdio_host->support_chip_alive)
+		gpio_direction_output(pdata->power_n.io, pdata->power_n.enable);
+#else
+	if (gpio_is_valid(pdata->power_n.io))
+		gpio_direction_output(pdata->power_n.io, !pdata->power_n.enable);
+#endif
+
+
+	if (pdata->wifi_power_remain)
+		rockchip_wifi_power(1);
+
+#if BCM_STATIC_MEMORY_SUPPORT
+	rockchip_init_wifi_mem();
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+	register_early_suspend(wlan_early_suspend);
+#endif
+
+	fb_register_client(&rfkill_wlan_fb_notifier);
+
+	LOG("Exit %s\n", __func__);
+
+	return 0;
+
+fail_alloc:
+	kfree(rfkill);
+rfkill_alloc_fail:
+	kfree(pdata);
+
+	g_rfkill = NULL;
+
+	return ret;
+}
+
+static int rfkill_wlan_remove(struct platform_device *pdev)
+{
+	struct rfkill_wlan_data *rfkill = platform_get_drvdata(pdev);
+
+	LOG("Enter %s\n", __func__);
+
+	wake_lock_destroy(&rfkill->wlan_irq_wl);
+
+	fb_unregister_client(&rfkill_wlan_fb_notifier);
+
+	if (gpio_is_valid(rfkill->pdata->power_n.io))
+		gpio_free(rfkill->pdata->power_n.io);
+
+	if (gpio_is_valid(rfkill->pdata->reset_n.io))
+		gpio_free(rfkill->pdata->reset_n.io);
+
+	kfree(rfkill);
+	g_rfkill = NULL;
+
+	return 0;
+}
+
+static int rfkill_wlan_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	LOG("Enter %s\n", __func__);
+	return 0;
+}
+
+static int rfkill_wlan_resume(struct platform_device *pdev)
+{
+	LOG("Enter %s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id wlan_platdata_of_match[] = {
+	{ .compatible = "wlan-platdata" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, wlan_platdata_of_match);
+#endif //CONFIG_OF
+
+static struct platform_driver rfkill_wlan_driver = {
+	.probe = rfkill_wlan_probe,
+	.remove = rfkill_wlan_remove,
+    .suspend = rfkill_wlan_suspend,
+    .resume = rfkill_wlan_resume,
+	.driver = {
+		.name = "wlan-platdata",
+		.owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(wlan_platdata_of_match),
+	},
+};
+
+int __init rfkill_wlan_init(void)
+{
+	LOG("Enter %s\n", __func__);
+	return platform_driver_register(&rfkill_wlan_driver);
+}
+
+void __exit rfkill_wlan_exit(void)
+{
+	LOG("Enter %s\n", __func__);
+	platform_driver_unregister(&rfkill_wlan_driver);
+}
+
+MODULE_DESCRIPTION("rock-chips rfkill for wifi v0.1");
+MODULE_AUTHOR("gwl@rock-chips.com");
+MODULE_LICENSE("GPL");
-- 
2.25.1

